
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type sessionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user_actions: user_actionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    startTime: Date
    endTime: Date | null
  }, ExtArgs["result"]["session"]>
  composites: {}
}

/**
 * Model session
 * 
 */
export type session = runtime.Types.DefaultSelection<sessionPayload>
export type user_actionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    session: sessionPayload<ExtArgs>
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    session_id: number
    time: Date
    user_id: number
    action: string
  }, ExtArgs["result"]["user_action"]>
  composites: {}
}

/**
 * Model user_action
 * 
 */
export type user_action = runtime.Types.DefaultSelection<user_actionPayload>
export type centerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user_centers: user_centerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    type: CenterType
    name: string
  }, ExtArgs["result"]["center"]>
  composites: {}
}

/**
 * Model center
 * 
 */
export type center = runtime.Types.DefaultSelection<centerPayload>
export type messagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    from: userPayload<ExtArgs>
    to: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    from_id: number
    to_id: number
    read_on: Date | null
    content: string
  }, ExtArgs["result"]["message"]>
  composites: {}
}

/**
 * Model message
 * 
 */
export type message = runtime.Types.DefaultSelection<messagePayload>
export type patient_caregiverPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    patient: userPayload<ExtArgs>
    caregiver: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    confirmed: boolean
    patient_id: number
    caregiver_id: number
    role: PatientCaregiverType
  }, ExtArgs["result"]["patient_caregiver"]>
  composites: {}
}

/**
 * Model patient_caregiver
 * 
 */
export type patient_caregiver = runtime.Types.DefaultSelection<patient_caregiverPayload>
export type userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user_actions: user_actionPayload<ExtArgs>[]
    favorites: favoritePayload<ExtArgs>[]
    fractionings: fractioningPayload<ExtArgs>[]
    meals: mealPayload<ExtArgs>[]
    messages_from: messagePayload<ExtArgs>[]
    messages_to: messagePayload<ExtArgs>[]
    patients: patient_caregiverPayload<ExtArgs>[]
    caregivers: patient_caregiverPayload<ExtArgs>[]
    user_centers: user_centerPayload<ExtArgs>[]
    user_goals: user_goalPayload<ExtArgs>[]
    user_measurements: user_measurementPayload<ExtArgs>[]
    user_withings: user_withingsPayload<ExtArgs>[]
    user_patients: user_patientPayload<ExtArgs>[]
    user_qcuanswers: user_qcuanswerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    sub: string | null
    password: string | null
    type: UserType
    birthdate: Date | null
    title: string | null
    email: string | null
    phone: string | null
    firstname: string | null
    lastname: string | null
    alias: string | null
    notes: string | null
    avatarUrl: string | null
    install_token: string | null
    subscription: string | null
    gender: number | null
    height_cm: number | null
    weight: Prisma.Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    hypertriglyceridemia: boolean | null
    hypercholesterolemia: boolean | null
    salt_diet: number | null
    energy_goal: number | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model user
 * 
 */
export type user = runtime.Types.DefaultSelection<userPayload>
export type user_centerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
    center: centerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    center_id: number
    role: CenterRole
  }, ExtArgs["result"]["user_center"]>
  composites: {}
}

/**
 * Model user_center
 * 
 */
export type user_center = runtime.Types.DefaultSelection<user_centerPayload>
export type user_goalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    date: Date
    type: GoalType
    value: string
  }, ExtArgs["result"]["user_goal"]>
  composites: {}
}

/**
 * Model user_goal
 * 
 */
export type user_goal = runtime.Types.DefaultSelection<user_goalPayload>
export type user_measurementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    date: Date
    type: MeasurementType
    value: Prisma.Decimal | null
  }, ExtArgs["result"]["user_measurement"]>
  composites: {}
}

/**
 * Model user_measurement
 * 
 */
export type user_measurement = runtime.Types.DefaultSelection<user_measurementPayload>
export type user_withingsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    withings_userid: string
    access_token: string
    refresh_token: string
  }, ExtArgs["result"]["user_withings"]>
  composites: {}
}

/**
 * Model user_withings
 * 
 */
export type user_withings = runtime.Types.DefaultSelection<user_withingsPayload>
export type user_patientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    protocol_code: string | null
    protocol_inclusion_date: string | null
  }, ExtArgs["result"]["user_patient"]>
  composites: {}
}

/**
 * Model user_patient
 * 
 */
export type user_patient = runtime.Types.DefaultSelection<user_patientPayload>
export type fractioningPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    date: string | null
    meal_types: string | null
  }, ExtArgs["result"]["fractioning"]>
  composites: {}
}

/**
 * Model fractioning
 * 
 */
export type fractioning = runtime.Types.DefaultSelection<fractioningPayload>
export type meal_elementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food: foodPayload<ExtArgs> | null
    meal: mealPayload<ExtArgs>
    foodPortion: food_portionPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    meal_id: number
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Prisma.Decimal | null
  }, ExtArgs["result"]["meal_element"]>
  composites: {}
}

/**
 * Model meal_element
 * 
 */
export type meal_element = runtime.Types.DefaultSelection<meal_elementPayload>
export type mealPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    meal_elements: meal_elementPayload<ExtArgs>[]
    users: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    date: string | null
    mealtype: string | null
    really_eaten: boolean | null
  }, ExtArgs["result"]["meal"]>
  composites: {}
}

/**
 * Model meal
 * 
 */
export type meal = runtime.Types.DefaultSelection<mealPayload>
export type favoritePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food: foodPayload<ExtArgs> | null
    foodPortion: food_portionPayload<ExtArgs> | null
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    user_id: number
    mealtype: string | null
    count: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Prisma.Decimal | null
  }, ExtArgs["result"]["favorite"]>
  composites: {}
}

/**
 * Model favorite
 * 
 */
export type favorite = runtime.Types.DefaultSelection<favoritePayload>
export type categoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food_categories: food_categoryPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    ciqual_gpcd: string | null
    member_of_id: number | null
    rank: number | null
    tag: string | null
  }, ExtArgs["result"]["category"]>
  composites: {}
}

/**
 * Model category
 * 
 */
export type category = runtime.Types.DefaultSelection<categoryPayload>
export type food_categoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    categoriy: categoryPayload<ExtArgs>
    food: foodPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    food_id: number
    category_id: number
  }, ExtArgs["result"]["food_category"]>
  composites: {}
}

/**
 * Model food_category
 * 
 */
export type food_category = runtime.Types.DefaultSelection<food_categoryPayload>
export type food_portionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food: foodPayload<ExtArgs>
    mealElements: meal_elementPayload<ExtArgs>[]
    favorites: favoritePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    qty: string
    shrt_desc: string
    long_desc: string | null
    note: string | null
    pict: string | null
    food_id: number
  }, ExtArgs["result"]["food_portion"]>
  composites: {}
}

/**
 * Model food_portion
 * 
 */
export type food_portion = runtime.Types.DefaultSelection<food_portionPayload>
export type foodPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food_categories: food_categoryPayload<ExtArgs>[]
    food_portions: food_portionPayload<ExtArgs>[]
    source: sourcePayload<ExtArgs>
    nutdata: nutdataPayload<ExtArgs>[]
    mealElements: meal_elementPayload<ExtArgs>[]
    favorites: favoritePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    ciqual_name: string | null
    ctdit_shrt_desc: string | null
    ctdit_long_desc: string | null
    keywords: string | null
    ciqual_num: string | null
    note: string | null
    max_qty: string | null
    pict: string | null
    source_id: number
    is_brand: boolean | null
    is_raw: boolean | null
    is_indivisible: boolean | null
    is_chu: boolean | null
    is_demo: boolean | null
    is_patient_full: boolean | null
    is_patient_simplified: boolean | null
    pack_pict: string | null
    is_validated: boolean | null
  }, ExtArgs["result"]["food"]>
  composites: {}
}

/**
 * Model food
 * 
 */
export type food = runtime.Types.DefaultSelection<foodPayload>
export type nutdataPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    food: foodPayload<ExtArgs>
    nutrient: nutrientPayload<ExtArgs>
    source: sourcePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    val: string | null
    note: string | null
    food_id: number
    nutr_no: string
    source_id: number
  }, ExtArgs["result"]["nutdata"]>
  composites: {}
}

/**
 * Model nutdata
 * 
 */
export type nutdata = runtime.Types.DefaultSelection<nutdataPayload>
export type nutrientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    nutdata: nutdataPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    nutr_no: string
    created_at: Date | null
    ifda_no: string | null
    unit: string | null
    shrt_desc: string | null
    long_desc: string | null
    energy_density: Prisma.Decimal | null
  }, ExtArgs["result"]["nutrient"]>
  composites: {}
}

/**
 * Model nutrient
 * 
 */
export type nutrient = runtime.Types.DefaultSelection<nutrientPayload>
export type sourcePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    foods: foodPayload<ExtArgs>[]
    nutdata: nutdataPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
  }, ExtArgs["result"]["source"]>
  composites: {}
}

/**
 * Model source
 * 
 */
export type source = runtime.Types.DefaultSelection<sourcePayload>
export type dishPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    pict: string | null
    note: string | null
    shrt_source: string
    long_source: string | null
    qty_max: string | null
    resume: string | null
    recette: string | null
    nbpersonnes: number
    qte: string
    diabete: string
    cardiaque: string
    obese: string
    ssel: string
    chol: string
    trigly: string
    maxqty: number
  }, ExtArgs["result"]["dish"]>
  composites: {}
}

/**
 * Model dish
 * 
 */
export type dish = runtime.Types.DefaultSelection<dishPayload>
export type lexiconPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    code: string
    title: string
    text: string
  }, ExtArgs["result"]["lexicon"]>
  composites: {}
}

/**
 * Model lexicon
 * 
 */
export type lexicon = runtime.Types.DefaultSelection<lexiconPayload>
export type qcu_imagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    question: qcu_questionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    pict: string
    question_id: number
  }, ExtArgs["result"]["qcu_image"]>
  composites: {}
}

/**
 * Model qcu_image
 * 
 */
export type qcu_image = runtime.Types.DefaultSelection<qcu_imagePayload>
export type qcu_questionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    items: qcu_itemPayload<ExtArgs>[]
    images: qcu_imagePayload<ExtArgs>[]
    answers: user_qcuanswerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
  }, ExtArgs["result"]["qcu_question"]>
  composites: {}
}

/**
 * Model qcu_question
 * 
 */
export type qcu_question = runtime.Types.DefaultSelection<qcu_questionPayload>
export type qcu_itemPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    question: qcu_questionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    created_at: Date | null
    proposition: string
    pict: string
    answer: string
    success: boolean
    question_id: number
  }, ExtArgs["result"]["qcu_item"]>
  composites: {}
}

/**
 * Model qcu_item
 * 
 */
export type qcu_item = runtime.Types.DefaultSelection<qcu_itemPayload>
export type user_qcuanswerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: userPayload<ExtArgs>
    question: qcu_questionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    timestamp: Date | null
    user_id: number
    qcuquestion_id: number
    success: boolean
  }, ExtArgs["result"]["user_qcuanswer"]>
  composites: {}
}

/**
 * Model user_qcuanswer
 * 
 */
export type user_qcuanswer = runtime.Types.DefaultSelection<user_qcuanswerPayload>

/**
 * Enums
 */

export const CenterType: {
  institution: 'institution',
  family: 'family'
};

export type CenterType = (typeof CenterType)[keyof typeof CenterType]


export const PatientCaregiverType: {
  referent: 'referent',
  coach: 'coach',
  diet: 'diet',
  familydoctor: 'familydoctor',
  other: 'other'
};

export type PatientCaregiverType = (typeof PatientCaregiverType)[keyof typeof PatientCaregiverType]


export const UserType: {
  admin: 'admin',
  patient: 'patient',
  caregiver: 'caregiver',
  coordinator: 'coordinator'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const CenterRole: {
  patient: 'patient',
  caregiver: 'caregiver',
  coordinator: 'coordinator'
};

export type CenterRole = (typeof CenterRole)[keyof typeof CenterRole]


export const GoalType: {
  weight: 'weight',
  steps: 'steps'
};

export type GoalType = (typeof GoalType)[keyof typeof GoalType]


export const MeasurementType: {
  weight: 'weight',
  fat: 'fat',
  steps: 'steps',
  elevation: 'elevation',
  soft: 'soft',
  moderate: 'moderate',
  intense: 'intense'
};

export type MeasurementType = (typeof MeasurementType)[keyof typeof MeasurementType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sessions
 * const sessions = await prisma.session.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_action`: Exposes CRUD operations for the **user_action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_actions
    * const user_actions = await prisma.user_action.findMany()
    * ```
    */
  get user_action(): Prisma.user_actionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.center`: Exposes CRUD operations for the **center** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Centers
    * const centers = await prisma.center.findMany()
    * ```
    */
  get center(): Prisma.centerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.patient_caregiver`: Exposes CRUD operations for the **patient_caregiver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_caregivers
    * const patient_caregivers = await prisma.patient_caregiver.findMany()
    * ```
    */
  get patient_caregiver(): Prisma.patient_caregiverDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_center`: Exposes CRUD operations for the **user_center** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_centers
    * const user_centers = await prisma.user_center.findMany()
    * ```
    */
  get user_center(): Prisma.user_centerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_goal`: Exposes CRUD operations for the **user_goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_goals
    * const user_goals = await prisma.user_goal.findMany()
    * ```
    */
  get user_goal(): Prisma.user_goalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_measurement`: Exposes CRUD operations for the **user_measurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_measurements
    * const user_measurements = await prisma.user_measurement.findMany()
    * ```
    */
  get user_measurement(): Prisma.user_measurementDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_withings`: Exposes CRUD operations for the **user_withings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_withings
    * const user_withings = await prisma.user_withings.findMany()
    * ```
    */
  get user_withings(): Prisma.user_withingsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_patient`: Exposes CRUD operations for the **user_patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_patients
    * const user_patients = await prisma.user_patient.findMany()
    * ```
    */
  get user_patient(): Prisma.user_patientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.fractioning`: Exposes CRUD operations for the **fractioning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fractionings
    * const fractionings = await prisma.fractioning.findMany()
    * ```
    */
  get fractioning(): Prisma.fractioningDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.meal_element`: Exposes CRUD operations for the **meal_element** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meal_elements
    * const meal_elements = await prisma.meal_element.findMany()
    * ```
    */
  get meal_element(): Prisma.meal_elementDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.meal`: Exposes CRUD operations for the **meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meals
    * const meals = await prisma.meal.findMany()
    * ```
    */
  get meal(): Prisma.mealDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.favoriteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.food_category`: Exposes CRUD operations for the **food_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Food_categories
    * const food_categories = await prisma.food_category.findMany()
    * ```
    */
  get food_category(): Prisma.food_categoryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.food_portion`: Exposes CRUD operations for the **food_portion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Food_portions
    * const food_portions = await prisma.food_portion.findMany()
    * ```
    */
  get food_portion(): Prisma.food_portionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.foodDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.nutdata`: Exposes CRUD operations for the **nutdata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nutdata
    * const nutdata = await prisma.nutdata.findMany()
    * ```
    */
  get nutdata(): Prisma.nutdataDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.nutrient`: Exposes CRUD operations for the **nutrient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nutrients
    * const nutrients = await prisma.nutrient.findMany()
    * ```
    */
  get nutrient(): Prisma.nutrientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.sourceDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): Prisma.dishDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.lexicon`: Exposes CRUD operations for the **lexicon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lexicons
    * const lexicons = await prisma.lexicon.findMany()
    * ```
    */
  get lexicon(): Prisma.lexiconDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.qcu_image`: Exposes CRUD operations for the **qcu_image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qcu_images
    * const qcu_images = await prisma.qcu_image.findMany()
    * ```
    */
  get qcu_image(): Prisma.qcu_imageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.qcu_question`: Exposes CRUD operations for the **qcu_question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qcu_questions
    * const qcu_questions = await prisma.qcu_question.findMany()
    * ```
    */
  get qcu_question(): Prisma.qcu_questionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.qcu_item`: Exposes CRUD operations for the **qcu_item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qcu_items
    * const qcu_items = await prisma.qcu_item.findMany()
    * ```
    */
  get qcu_item(): Prisma.qcu_itemDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.user_qcuanswer`: Exposes CRUD operations for the **user_qcuanswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_qcuanswers
    * const user_qcuanswers = await prisma.user_qcuanswer.findMany()
    * ```
    */
  get user_qcuanswer(): Prisma.user_qcuanswerDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.1
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    session: 'session',
    user_action: 'user_action',
    center: 'center',
    message: 'message',
    patient_caregiver: 'patient_caregiver',
    user: 'user',
    user_center: 'user_center',
    user_goal: 'user_goal',
    user_measurement: 'user_measurement',
    user_withings: 'user_withings',
    user_patient: 'user_patient',
    fractioning: 'fractioning',
    meal_element: 'meal_element',
    meal: 'meal',
    favorite: 'favorite',
    category: 'category',
    food_category: 'food_category',
    food_portion: 'food_portion',
    food: 'food',
    nutdata: 'nutdata',
    nutrient: 'nutrient',
    source: 'source',
    dish: 'dish',
    lexicon: 'lexicon',
    qcu_image: 'qcu_image',
    qcu_question: 'qcu_question',
    qcu_item: 'qcu_item',
    user_qcuanswer: 'user_qcuanswer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'session' | 'user_action' | 'center' | 'message' | 'patient_caregiver' | 'user' | 'user_center' | 'user_goal' | 'user_measurement' | 'user_withings' | 'user_patient' | 'fractioning' | 'meal_element' | 'meal' | 'favorite' | 'category' | 'food_category' | 'food_portion' | 'food' | 'nutdata' | 'nutrient' | 'source' | 'dish' | 'lexicon' | 'qcu_image' | 'qcu_question' | 'qcu_item' | 'user_qcuanswer'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      session: {
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload> | null
            payload: sessionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload> | null
            payload: sessionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>[]
            payload: sessionPayload<ExtArgs>
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sessionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sessionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sessionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sessionPayload>
            payload: sessionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
            payload: sessionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
            payload: sessionPayload<ExtArgs>
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
            payload: sessionPayload<ExtArgs>
          }
        }
      }
      user_action: {
        operations: {
          findUnique: {
            args: Prisma.user_actionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload> | null
            payload: user_actionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_actionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_actionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload> | null
            payload: user_actionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_actionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_actionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>[]
            payload: user_actionPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_actionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_actionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_actionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_actionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_actionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_actionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_actionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_actionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_actionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_actionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_actionPayload>
            payload: user_actionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_actionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_action>
            payload: user_actionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_actionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_actionGroupByOutputType>[]
            payload: user_actionPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_actionCountArgs<ExtArgs>,
            result: $Utils.Optional<User_actionCountAggregateOutputType> | number
            payload: user_actionPayload<ExtArgs>
          }
        }
      }
      center: {
        operations: {
          findUnique: {
            args: Prisma.centerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload> | null
            payload: centerPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.centerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.centerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload> | null
            payload: centerPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.centerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.centerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>[]
            payload: centerPayload<ExtArgs>
          }
          create: {
            args: Prisma.centerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.centerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: centerPayload<ExtArgs>
          }
          delete: {
            args: Prisma.centerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          update: {
            args: Prisma.centerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.centerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: centerPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.centerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: centerPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.centerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<centerPayload>
            payload: centerPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CenterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCenter>
            payload: centerPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.CenterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CenterGroupByOutputType>[]
            payload: centerPayload<ExtArgs>
          }
          count: {
            args: Prisma.centerCountArgs<ExtArgs>,
            result: $Utils.Optional<CenterCountAggregateOutputType> | number
            payload: centerPayload<ExtArgs>
          }
        }
      }
      message: {
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload> | null
            payload: messagePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload> | null
            payload: messagePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>[]
            payload: messagePayload<ExtArgs>
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: messagePayload<ExtArgs>
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: messagePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: messagePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<messagePayload>
            payload: messagePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
            payload: messagePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
            payload: messagePayload<ExtArgs>
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
            payload: messagePayload<ExtArgs>
          }
        }
      }
      patient_caregiver: {
        operations: {
          findUnique: {
            args: Prisma.patient_caregiverFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload> | null
            payload: patient_caregiverPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.patient_caregiverFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.patient_caregiverFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload> | null
            payload: patient_caregiverPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.patient_caregiverFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.patient_caregiverFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>[]
            payload: patient_caregiverPayload<ExtArgs>
          }
          create: {
            args: Prisma.patient_caregiverCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.patient_caregiverCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: patient_caregiverPayload<ExtArgs>
          }
          delete: {
            args: Prisma.patient_caregiverDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          update: {
            args: Prisma.patient_caregiverUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.patient_caregiverDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: patient_caregiverPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.patient_caregiverUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: patient_caregiverPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.patient_caregiverUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<patient_caregiverPayload>
            payload: patient_caregiverPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Patient_caregiverAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient_caregiver>
            payload: patient_caregiverPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Patient_caregiverGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Patient_caregiverGroupByOutputType>[]
            payload: patient_caregiverPayload<ExtArgs>
          }
          count: {
            args: Prisma.patient_caregiverCountArgs<ExtArgs>,
            result: $Utils.Optional<Patient_caregiverCountAggregateOutputType> | number
            payload: patient_caregiverPayload<ExtArgs>
          }
        }
      }
      user: {
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
            payload: userPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
            payload: userPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>[]
            payload: userPayload<ExtArgs>
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: userPayload<ExtArgs>
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: userPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: userPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
            payload: userPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
            payload: userPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
            payload: userPayload<ExtArgs>
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
            payload: userPayload<ExtArgs>
          }
        }
      }
      user_center: {
        operations: {
          findUnique: {
            args: Prisma.user_centerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload> | null
            payload: user_centerPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_centerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_centerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload> | null
            payload: user_centerPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_centerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_centerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>[]
            payload: user_centerPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_centerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_centerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_centerPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_centerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_centerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_centerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_centerPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_centerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_centerPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_centerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_centerPayload>
            payload: user_centerPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_centerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_center>
            payload: user_centerPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_centerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_centerGroupByOutputType>[]
            payload: user_centerPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_centerCountArgs<ExtArgs>,
            result: $Utils.Optional<User_centerCountAggregateOutputType> | number
            payload: user_centerPayload<ExtArgs>
          }
        }
      }
      user_goal: {
        operations: {
          findUnique: {
            args: Prisma.user_goalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload> | null
            payload: user_goalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_goalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_goalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload> | null
            payload: user_goalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_goalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_goalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>[]
            payload: user_goalPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_goalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_goalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_goalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_goalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_goalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_goalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_goalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_goalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_goalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_goalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_goalPayload>
            payload: user_goalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_goalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_goal>
            payload: user_goalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_goalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_goalGroupByOutputType>[]
            payload: user_goalPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_goalCountArgs<ExtArgs>,
            result: $Utils.Optional<User_goalCountAggregateOutputType> | number
            payload: user_goalPayload<ExtArgs>
          }
        }
      }
      user_measurement: {
        operations: {
          findUnique: {
            args: Prisma.user_measurementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload> | null
            payload: user_measurementPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_measurementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_measurementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload> | null
            payload: user_measurementPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_measurementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_measurementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>[]
            payload: user_measurementPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_measurementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_measurementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_measurementPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_measurementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_measurementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_measurementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_measurementPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_measurementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_measurementPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_measurementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_measurementPayload>
            payload: user_measurementPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_measurementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_measurement>
            payload: user_measurementPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_measurementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_measurementGroupByOutputType>[]
            payload: user_measurementPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_measurementCountArgs<ExtArgs>,
            result: $Utils.Optional<User_measurementCountAggregateOutputType> | number
            payload: user_measurementPayload<ExtArgs>
          }
        }
      }
      user_withings: {
        operations: {
          findUnique: {
            args: Prisma.user_withingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload> | null
            payload: user_withingsPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_withingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_withingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload> | null
            payload: user_withingsPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_withingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_withingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>[]
            payload: user_withingsPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_withingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_withingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_withingsPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_withingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_withingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_withingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_withingsPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_withingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_withingsPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_withingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_withingsPayload>
            payload: user_withingsPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_withingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_withings>
            payload: user_withingsPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_withingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_withingsGroupByOutputType>[]
            payload: user_withingsPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_withingsCountArgs<ExtArgs>,
            result: $Utils.Optional<User_withingsCountAggregateOutputType> | number
            payload: user_withingsPayload<ExtArgs>
          }
        }
      }
      user_patient: {
        operations: {
          findUnique: {
            args: Prisma.user_patientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload> | null
            payload: user_patientPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_patientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_patientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload> | null
            payload: user_patientPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_patientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_patientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>[]
            payload: user_patientPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_patientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_patientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_patientPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_patientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_patientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_patientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_patientPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_patientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_patientPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_patientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_patientPayload>
            payload: user_patientPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_patientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_patient>
            payload: user_patientPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_patientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_patientGroupByOutputType>[]
            payload: user_patientPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_patientCountArgs<ExtArgs>,
            result: $Utils.Optional<User_patientCountAggregateOutputType> | number
            payload: user_patientPayload<ExtArgs>
          }
        }
      }
      fractioning: {
        operations: {
          findUnique: {
            args: Prisma.fractioningFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload> | null
            payload: fractioningPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.fractioningFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.fractioningFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload> | null
            payload: fractioningPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.fractioningFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.fractioningFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>[]
            payload: fractioningPayload<ExtArgs>
          }
          create: {
            args: Prisma.fractioningCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.fractioningCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fractioningPayload<ExtArgs>
          }
          delete: {
            args: Prisma.fractioningDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          update: {
            args: Prisma.fractioningUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.fractioningDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fractioningPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.fractioningUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: fractioningPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.fractioningUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<fractioningPayload>
            payload: fractioningPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.FractioningAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFractioning>
            payload: fractioningPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.FractioningGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FractioningGroupByOutputType>[]
            payload: fractioningPayload<ExtArgs>
          }
          count: {
            args: Prisma.fractioningCountArgs<ExtArgs>,
            result: $Utils.Optional<FractioningCountAggregateOutputType> | number
            payload: fractioningPayload<ExtArgs>
          }
        }
      }
      meal_element: {
        operations: {
          findUnique: {
            args: Prisma.meal_elementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload> | null
            payload: meal_elementPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.meal_elementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.meal_elementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload> | null
            payload: meal_elementPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.meal_elementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.meal_elementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>[]
            payload: meal_elementPayload<ExtArgs>
          }
          create: {
            args: Prisma.meal_elementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.meal_elementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: meal_elementPayload<ExtArgs>
          }
          delete: {
            args: Prisma.meal_elementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          update: {
            args: Prisma.meal_elementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.meal_elementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: meal_elementPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.meal_elementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: meal_elementPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.meal_elementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<meal_elementPayload>
            payload: meal_elementPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Meal_elementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeal_element>
            payload: meal_elementPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Meal_elementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Meal_elementGroupByOutputType>[]
            payload: meal_elementPayload<ExtArgs>
          }
          count: {
            args: Prisma.meal_elementCountArgs<ExtArgs>,
            result: $Utils.Optional<Meal_elementCountAggregateOutputType> | number
            payload: meal_elementPayload<ExtArgs>
          }
        }
      }
      meal: {
        operations: {
          findUnique: {
            args: Prisma.mealFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload> | null
            payload: mealPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.mealFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.mealFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload> | null
            payload: mealPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.mealFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.mealFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>[]
            payload: mealPayload<ExtArgs>
          }
          create: {
            args: Prisma.mealCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.mealCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mealPayload<ExtArgs>
          }
          delete: {
            args: Prisma.mealDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          update: {
            args: Prisma.mealUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.mealDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mealPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.mealUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: mealPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.mealUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<mealPayload>
            payload: mealPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.MealAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeal>
            payload: mealPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.MealGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MealGroupByOutputType>[]
            payload: mealPayload<ExtArgs>
          }
          count: {
            args: Prisma.mealCountArgs<ExtArgs>,
            result: $Utils.Optional<MealCountAggregateOutputType> | number
            payload: mealPayload<ExtArgs>
          }
        }
      }
      favorite: {
        operations: {
          findUnique: {
            args: Prisma.favoriteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload> | null
            payload: favoritePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.favoriteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.favoriteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload> | null
            payload: favoritePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.favoriteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.favoriteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>[]
            payload: favoritePayload<ExtArgs>
          }
          create: {
            args: Prisma.favoriteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.favoriteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: favoritePayload<ExtArgs>
          }
          delete: {
            args: Prisma.favoriteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          update: {
            args: Prisma.favoriteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.favoriteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: favoritePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.favoriteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: favoritePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.favoriteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<favoritePayload>
            payload: favoritePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFavorite>
            payload: favoritePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
            payload: favoritePayload<ExtArgs>
          }
          count: {
            args: Prisma.favoriteCountArgs<ExtArgs>,
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
            payload: favoritePayload<ExtArgs>
          }
        }
      }
      category: {
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload> | null
            payload: categoryPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload> | null
            payload: categoryPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>[]
            payload: categoryPayload<ExtArgs>
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoryPayload<ExtArgs>
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoryPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: categoryPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<categoryPayload>
            payload: categoryPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
            payload: categoryPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
            payload: categoryPayload<ExtArgs>
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
            payload: categoryPayload<ExtArgs>
          }
        }
      }
      food_category: {
        operations: {
          findUnique: {
            args: Prisma.food_categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload> | null
            payload: food_categoryPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.food_categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.food_categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload> | null
            payload: food_categoryPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.food_categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.food_categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>[]
            payload: food_categoryPayload<ExtArgs>
          }
          create: {
            args: Prisma.food_categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.food_categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_categoryPayload<ExtArgs>
          }
          delete: {
            args: Prisma.food_categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          update: {
            args: Prisma.food_categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.food_categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_categoryPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.food_categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_categoryPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.food_categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_categoryPayload>
            payload: food_categoryPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Food_categoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFood_category>
            payload: food_categoryPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Food_categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Food_categoryGroupByOutputType>[]
            payload: food_categoryPayload<ExtArgs>
          }
          count: {
            args: Prisma.food_categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Food_categoryCountAggregateOutputType> | number
            payload: food_categoryPayload<ExtArgs>
          }
        }
      }
      food_portion: {
        operations: {
          findUnique: {
            args: Prisma.food_portionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload> | null
            payload: food_portionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.food_portionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.food_portionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload> | null
            payload: food_portionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.food_portionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.food_portionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>[]
            payload: food_portionPayload<ExtArgs>
          }
          create: {
            args: Prisma.food_portionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.food_portionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_portionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.food_portionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          update: {
            args: Prisma.food_portionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.food_portionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_portionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.food_portionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: food_portionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.food_portionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<food_portionPayload>
            payload: food_portionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Food_portionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFood_portion>
            payload: food_portionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Food_portionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Food_portionGroupByOutputType>[]
            payload: food_portionPayload<ExtArgs>
          }
          count: {
            args: Prisma.food_portionCountArgs<ExtArgs>,
            result: $Utils.Optional<Food_portionCountAggregateOutputType> | number
            payload: food_portionPayload<ExtArgs>
          }
        }
      }
      food: {
        operations: {
          findUnique: {
            args: Prisma.foodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload> | null
            payload: foodPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.foodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.foodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload> | null
            payload: foodPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.foodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.foodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>[]
            payload: foodPayload<ExtArgs>
          }
          create: {
            args: Prisma.foodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.foodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: foodPayload<ExtArgs>
          }
          delete: {
            args: Prisma.foodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          update: {
            args: Prisma.foodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.foodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: foodPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.foodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: foodPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.foodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<foodPayload>
            payload: foodPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFood>
            payload: foodPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FoodGroupByOutputType>[]
            payload: foodPayload<ExtArgs>
          }
          count: {
            args: Prisma.foodCountArgs<ExtArgs>,
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
            payload: foodPayload<ExtArgs>
          }
        }
      }
      nutdata: {
        operations: {
          findUnique: {
            args: Prisma.nutdataFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload> | null
            payload: nutdataPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.nutdataFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.nutdataFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload> | null
            payload: nutdataPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.nutdataFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.nutdataFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>[]
            payload: nutdataPayload<ExtArgs>
          }
          create: {
            args: Prisma.nutdataCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.nutdataCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutdataPayload<ExtArgs>
          }
          delete: {
            args: Prisma.nutdataDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          update: {
            args: Prisma.nutdataUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.nutdataDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutdataPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.nutdataUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutdataPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.nutdataUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutdataPayload>
            payload: nutdataPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NutdataAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNutdata>
            payload: nutdataPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.NutdataGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NutdataGroupByOutputType>[]
            payload: nutdataPayload<ExtArgs>
          }
          count: {
            args: Prisma.nutdataCountArgs<ExtArgs>,
            result: $Utils.Optional<NutdataCountAggregateOutputType> | number
            payload: nutdataPayload<ExtArgs>
          }
        }
      }
      nutrient: {
        operations: {
          findUnique: {
            args: Prisma.nutrientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload> | null
            payload: nutrientPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.nutrientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.nutrientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload> | null
            payload: nutrientPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.nutrientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.nutrientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>[]
            payload: nutrientPayload<ExtArgs>
          }
          create: {
            args: Prisma.nutrientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.nutrientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutrientPayload<ExtArgs>
          }
          delete: {
            args: Prisma.nutrientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          update: {
            args: Prisma.nutrientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.nutrientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutrientPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.nutrientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: nutrientPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.nutrientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<nutrientPayload>
            payload: nutrientPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.NutrientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNutrient>
            payload: nutrientPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.NutrientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NutrientGroupByOutputType>[]
            payload: nutrientPayload<ExtArgs>
          }
          count: {
            args: Prisma.nutrientCountArgs<ExtArgs>,
            result: $Utils.Optional<NutrientCountAggregateOutputType> | number
            payload: nutrientPayload<ExtArgs>
          }
        }
      }
      source: {
        operations: {
          findUnique: {
            args: Prisma.sourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload> | null
            payload: sourcePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.sourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.sourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload> | null
            payload: sourcePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.sourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.sourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>[]
            payload: sourcePayload<ExtArgs>
          }
          create: {
            args: Prisma.sourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.sourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sourcePayload<ExtArgs>
          }
          delete: {
            args: Prisma.sourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          update: {
            args: Prisma.sourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.sourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sourcePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.sourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: sourcePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.sourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<sourcePayload>
            payload: sourcePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSource>
            payload: sourcePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SourceGroupByOutputType>[]
            payload: sourcePayload<ExtArgs>
          }
          count: {
            args: Prisma.sourceCountArgs<ExtArgs>,
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
            payload: sourcePayload<ExtArgs>
          }
        }
      }
      dish: {
        operations: {
          findUnique: {
            args: Prisma.dishFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload> | null
            payload: dishPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.dishFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.dishFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload> | null
            payload: dishPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.dishFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.dishFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>[]
            payload: dishPayload<ExtArgs>
          }
          create: {
            args: Prisma.dishCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.dishCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: dishPayload<ExtArgs>
          }
          delete: {
            args: Prisma.dishDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          update: {
            args: Prisma.dishUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.dishDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: dishPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.dishUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: dishPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.dishUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<dishPayload>
            payload: dishPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.DishAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDish>
            payload: dishPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.DishGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DishGroupByOutputType>[]
            payload: dishPayload<ExtArgs>
          }
          count: {
            args: Prisma.dishCountArgs<ExtArgs>,
            result: $Utils.Optional<DishCountAggregateOutputType> | number
            payload: dishPayload<ExtArgs>
          }
        }
      }
      lexicon: {
        operations: {
          findUnique: {
            args: Prisma.lexiconFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload> | null
            payload: lexiconPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.lexiconFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.lexiconFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload> | null
            payload: lexiconPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.lexiconFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.lexiconFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>[]
            payload: lexiconPayload<ExtArgs>
          }
          create: {
            args: Prisma.lexiconCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.lexiconCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lexiconPayload<ExtArgs>
          }
          delete: {
            args: Prisma.lexiconDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          update: {
            args: Prisma.lexiconUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.lexiconDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lexiconPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.lexiconUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: lexiconPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.lexiconUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<lexiconPayload>
            payload: lexiconPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.LexiconAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLexicon>
            payload: lexiconPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.LexiconGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LexiconGroupByOutputType>[]
            payload: lexiconPayload<ExtArgs>
          }
          count: {
            args: Prisma.lexiconCountArgs<ExtArgs>,
            result: $Utils.Optional<LexiconCountAggregateOutputType> | number
            payload: lexiconPayload<ExtArgs>
          }
        }
      }
      qcu_image: {
        operations: {
          findUnique: {
            args: Prisma.qcu_imageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload> | null
            payload: qcu_imagePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.qcu_imageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.qcu_imageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload> | null
            payload: qcu_imagePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.qcu_imageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.qcu_imageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>[]
            payload: qcu_imagePayload<ExtArgs>
          }
          create: {
            args: Prisma.qcu_imageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.qcu_imageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_imagePayload<ExtArgs>
          }
          delete: {
            args: Prisma.qcu_imageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          update: {
            args: Prisma.qcu_imageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.qcu_imageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_imagePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.qcu_imageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_imagePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.qcu_imageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_imagePayload>
            payload: qcu_imagePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Qcu_imageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQcu_image>
            payload: qcu_imagePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Qcu_imageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_imageGroupByOutputType>[]
            payload: qcu_imagePayload<ExtArgs>
          }
          count: {
            args: Prisma.qcu_imageCountArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_imageCountAggregateOutputType> | number
            payload: qcu_imagePayload<ExtArgs>
          }
        }
      }
      qcu_question: {
        operations: {
          findUnique: {
            args: Prisma.qcu_questionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload> | null
            payload: qcu_questionPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.qcu_questionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.qcu_questionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload> | null
            payload: qcu_questionPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.qcu_questionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.qcu_questionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>[]
            payload: qcu_questionPayload<ExtArgs>
          }
          create: {
            args: Prisma.qcu_questionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.qcu_questionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_questionPayload<ExtArgs>
          }
          delete: {
            args: Prisma.qcu_questionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          update: {
            args: Prisma.qcu_questionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.qcu_questionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_questionPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.qcu_questionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_questionPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.qcu_questionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_questionPayload>
            payload: qcu_questionPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Qcu_questionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQcu_question>
            payload: qcu_questionPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Qcu_questionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_questionGroupByOutputType>[]
            payload: qcu_questionPayload<ExtArgs>
          }
          count: {
            args: Prisma.qcu_questionCountArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_questionCountAggregateOutputType> | number
            payload: qcu_questionPayload<ExtArgs>
          }
        }
      }
      qcu_item: {
        operations: {
          findUnique: {
            args: Prisma.qcu_itemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload> | null
            payload: qcu_itemPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.qcu_itemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.qcu_itemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload> | null
            payload: qcu_itemPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.qcu_itemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.qcu_itemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>[]
            payload: qcu_itemPayload<ExtArgs>
          }
          create: {
            args: Prisma.qcu_itemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.qcu_itemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_itemPayload<ExtArgs>
          }
          delete: {
            args: Prisma.qcu_itemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          update: {
            args: Prisma.qcu_itemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.qcu_itemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_itemPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.qcu_itemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: qcu_itemPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.qcu_itemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<qcu_itemPayload>
            payload: qcu_itemPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.Qcu_itemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateQcu_item>
            payload: qcu_itemPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.Qcu_itemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_itemGroupByOutputType>[]
            payload: qcu_itemPayload<ExtArgs>
          }
          count: {
            args: Prisma.qcu_itemCountArgs<ExtArgs>,
            result: $Utils.Optional<Qcu_itemCountAggregateOutputType> | number
            payload: qcu_itemPayload<ExtArgs>
          }
        }
      }
      user_qcuanswer: {
        operations: {
          findUnique: {
            args: Prisma.user_qcuanswerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload> | null
            payload: user_qcuanswerPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.user_qcuanswerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.user_qcuanswerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload> | null
            payload: user_qcuanswerPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.user_qcuanswerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.user_qcuanswerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>[]
            payload: user_qcuanswerPayload<ExtArgs>
          }
          create: {
            args: Prisma.user_qcuanswerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.user_qcuanswerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_qcuanswerPayload<ExtArgs>
          }
          delete: {
            args: Prisma.user_qcuanswerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          update: {
            args: Prisma.user_qcuanswerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.user_qcuanswerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_qcuanswerPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.user_qcuanswerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: user_qcuanswerPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.user_qcuanswerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<user_qcuanswerPayload>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.User_qcuanswerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_qcuanswer>
            payload: user_qcuanswerPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.User_qcuanswerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_qcuanswerGroupByOutputType>[]
            payload: user_qcuanswerPayload<ExtArgs>
          }
          count: {
            args: Prisma.user_qcuanswerCountArgs<ExtArgs>,
            result: $Utils.Optional<User_qcuanswerCountAggregateOutputType> | number
            payload: user_qcuanswerPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SessionCountOutputType
   */


  export type SessionCountOutputType = {
    user_actions: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_actions?: boolean | SessionCountOutputTypeCountUser_actionsArgs
  }

  // Custom InputTypes

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountUser_actionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_actionWhereInput
  }



  /**
   * Count Type CenterCountOutputType
   */


  export type CenterCountOutputType = {
    user_centers: number
  }

  export type CenterCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_centers?: boolean | CenterCountOutputTypeCountUser_centersArgs
  }

  // Custom InputTypes

  /**
   * CenterCountOutputType without action
   */
  export type CenterCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CenterCountOutputType
     */
    select?: CenterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CenterCountOutputType without action
   */
  export type CenterCountOutputTypeCountUser_centersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_centerWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    user_actions: number
    favorites: number
    fractionings: number
    meals: number
    messages_from: number
    messages_to: number
    patients: number
    caregivers: number
    user_centers: number
    user_goals: number
    user_measurements: number
    user_withings: number
    user_patients: number
    user_qcuanswers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_actions?: boolean | UserCountOutputTypeCountUser_actionsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    fractionings?: boolean | UserCountOutputTypeCountFractioningsArgs
    meals?: boolean | UserCountOutputTypeCountMealsArgs
    messages_from?: boolean | UserCountOutputTypeCountMessages_fromArgs
    messages_to?: boolean | UserCountOutputTypeCountMessages_toArgs
    patients?: boolean | UserCountOutputTypeCountPatientsArgs
    caregivers?: boolean | UserCountOutputTypeCountCaregiversArgs
    user_centers?: boolean | UserCountOutputTypeCountUser_centersArgs
    user_goals?: boolean | UserCountOutputTypeCountUser_goalsArgs
    user_measurements?: boolean | UserCountOutputTypeCountUser_measurementsArgs
    user_withings?: boolean | UserCountOutputTypeCountUser_withingsArgs
    user_patients?: boolean | UserCountOutputTypeCountUser_patientsArgs
    user_qcuanswers?: boolean | UserCountOutputTypeCountUser_qcuanswersArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_actionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_actionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: favoriteWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFractioningsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fractioningWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mealWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessages_fromArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessages_toArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: patient_caregiverWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCaregiversArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: patient_caregiverWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_centersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_centerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_goalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_goalWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_measurementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_measurementWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_withingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_withingsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_patientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_patientWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_qcuanswersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_qcuanswerWhereInput
  }



  /**
   * Count Type MealCountOutputType
   */


  export type MealCountOutputType = {
    meal_elements: number
  }

  export type MealCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meal_elements?: boolean | MealCountOutputTypeCountMeal_elementsArgs
  }

  // Custom InputTypes

  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealCountOutputType
     */
    select?: MealCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeCountMeal_elementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: meal_elementWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    food_categories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food_categories?: boolean | CategoryCountOutputTypeCountFood_categoriesArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountFood_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: food_categoryWhereInput
  }



  /**
   * Count Type Food_portionCountOutputType
   */


  export type Food_portionCountOutputType = {
    mealElements: number
    favorites: number
  }

  export type Food_portionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    mealElements?: boolean | Food_portionCountOutputTypeCountMealElementsArgs
    favorites?: boolean | Food_portionCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes

  /**
   * Food_portionCountOutputType without action
   */
  export type Food_portionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food_portionCountOutputType
     */
    select?: Food_portionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Food_portionCountOutputType without action
   */
  export type Food_portionCountOutputTypeCountMealElementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: meal_elementWhereInput
  }


  /**
   * Food_portionCountOutputType without action
   */
  export type Food_portionCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: favoriteWhereInput
  }



  /**
   * Count Type FoodCountOutputType
   */


  export type FoodCountOutputType = {
    food_categories: number
    food_portions: number
    nutdata: number
    mealElements: number
    favorites: number
  }

  export type FoodCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food_categories?: boolean | FoodCountOutputTypeCountFood_categoriesArgs
    food_portions?: boolean | FoodCountOutputTypeCountFood_portionsArgs
    nutdata?: boolean | FoodCountOutputTypeCountNutdataArgs
    mealElements?: boolean | FoodCountOutputTypeCountMealElementsArgs
    favorites?: boolean | FoodCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes

  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCountOutputType
     */
    select?: FoodCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFood_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: food_categoryWhereInput
  }


  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFood_portionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: food_portionWhereInput
  }


  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountNutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: nutdataWhereInput
  }


  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountMealElementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: meal_elementWhereInput
  }


  /**
   * FoodCountOutputType without action
   */
  export type FoodCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: favoriteWhereInput
  }



  /**
   * Count Type NutrientCountOutputType
   */


  export type NutrientCountOutputType = {
    nutdata: number
  }

  export type NutrientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    nutdata?: boolean | NutrientCountOutputTypeCountNutdataArgs
  }

  // Custom InputTypes

  /**
   * NutrientCountOutputType without action
   */
  export type NutrientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutrientCountOutputType
     */
    select?: NutrientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NutrientCountOutputType without action
   */
  export type NutrientCountOutputTypeCountNutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: nutdataWhereInput
  }



  /**
   * Count Type SourceCountOutputType
   */


  export type SourceCountOutputType = {
    foods: number
    nutdata: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    foods?: boolean | SourceCountOutputTypeCountFoodsArgs
    nutdata?: boolean | SourceCountOutputTypeCountNutdataArgs
  }

  // Custom InputTypes

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountFoodsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: foodWhereInput
  }


  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountNutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: nutdataWhereInput
  }



  /**
   * Count Type Qcu_questionCountOutputType
   */


  export type Qcu_questionCountOutputType = {
    items: number
    images: number
    answers: number
  }

  export type Qcu_questionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    items?: boolean | Qcu_questionCountOutputTypeCountItemsArgs
    images?: boolean | Qcu_questionCountOutputTypeCountImagesArgs
    answers?: boolean | Qcu_questionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes

  /**
   * Qcu_questionCountOutputType without action
   */
  export type Qcu_questionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Qcu_questionCountOutputType
     */
    select?: Qcu_questionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Qcu_questionCountOutputType without action
   */
  export type Qcu_questionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: qcu_itemWhereInput
  }


  /**
   * Qcu_questionCountOutputType without action
   */
  export type Qcu_questionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: qcu_imageWhereInput
  }


  /**
   * Qcu_questionCountOutputType without action
   */
  export type Qcu_questionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_qcuanswerWhereInput
  }



  /**
   * Models
   */

  /**
   * Model session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: Enumerable<sessionOrderByWithAggregationInput>
    by: SessionScalarFieldEnum[]
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    user_actions?: boolean | session$user_actionsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
  }

  export type sessionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_actions?: boolean | session$user_actionsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeArgs<ExtArgs>
  }


  type sessionGetPayload<S extends boolean | null | undefined | sessionArgs> = $Types.GetResult<sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'session'> extends True ? Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'session'> extends True ? Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends sessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionCreateArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends sessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends sessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>
    ): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user_actions<T extends session$user_actionsArgs<ExtArgs> = {}>(args?: Subset<T, session$user_actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * session base type for findUnique actions
   */
  export type sessionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUnique
   */
  export interface sessionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sessionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session base type for findFirst actions
   */
  export type sessionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }

  /**
   * session findFirst
   */
  export interface sessionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sessionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: Enumerable<sessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }


  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: Enumerable<sessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
  }


  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }


  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
  }


  /**
   * session.user_actions
   */
  export type session$user_actionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    where?: user_actionWhereInput
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    cursor?: user_actionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_actionScalarFieldEnum>
  }


  /**
   * session without action
   */
  export type sessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sessionInclude<ExtArgs> | null
  }



  /**
   * Model user_action
   */


  export type AggregateUser_action = {
    _count: User_actionCountAggregateOutputType | null
    _avg: User_actionAvgAggregateOutputType | null
    _sum: User_actionSumAggregateOutputType | null
    _min: User_actionMinAggregateOutputType | null
    _max: User_actionMaxAggregateOutputType | null
  }

  export type User_actionAvgAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
  }

  export type User_actionSumAggregateOutputType = {
    id: number | null
    session_id: number | null
    user_id: number | null
  }

  export type User_actionMinAggregateOutputType = {
    id: number | null
    session_id: number | null
    time: Date | null
    user_id: number | null
    action: string | null
  }

  export type User_actionMaxAggregateOutputType = {
    id: number | null
    session_id: number | null
    time: Date | null
    user_id: number | null
    action: string | null
  }

  export type User_actionCountAggregateOutputType = {
    id: number
    session_id: number
    time: number
    user_id: number
    action: number
    _all: number
  }


  export type User_actionAvgAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
  }

  export type User_actionSumAggregateInputType = {
    id?: true
    session_id?: true
    user_id?: true
  }

  export type User_actionMinAggregateInputType = {
    id?: true
    session_id?: true
    time?: true
    user_id?: true
    action?: true
  }

  export type User_actionMaxAggregateInputType = {
    id?: true
    session_id?: true
    time?: true
    user_id?: true
    action?: true
  }

  export type User_actionCountAggregateInputType = {
    id?: true
    session_id?: true
    time?: true
    user_id?: true
    action?: true
    _all?: true
  }

  export type User_actionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_action to aggregate.
     */
    where?: user_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_actions to fetch.
     */
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_actions
    **/
    _count?: true | User_actionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_actionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_actionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_actionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_actionMaxAggregateInputType
  }

  export type GetUser_actionAggregateType<T extends User_actionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_action]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_action[P]>
      : GetScalarType<T[P], AggregateUser_action[P]>
  }




  export type User_actionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_actionWhereInput
    orderBy?: Enumerable<user_actionOrderByWithAggregationInput>
    by: User_actionScalarFieldEnum[]
    having?: user_actionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_actionCountAggregateInputType | true
    _avg?: User_actionAvgAggregateInputType
    _sum?: User_actionSumAggregateInputType
    _min?: User_actionMinAggregateInputType
    _max?: User_actionMaxAggregateInputType
  }


  export type User_actionGroupByOutputType = {
    id: number
    session_id: number
    time: Date
    user_id: number
    action: string
    _count: User_actionCountAggregateOutputType | null
    _avg: User_actionAvgAggregateOutputType | null
    _sum: User_actionSumAggregateOutputType | null
    _min: User_actionMinAggregateOutputType | null
    _max: User_actionMaxAggregateOutputType | null
  }

  type GetUser_actionGroupByPayload<T extends User_actionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_actionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_actionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_actionGroupByOutputType[P]>
            : GetScalarType<T[P], User_actionGroupByOutputType[P]>
        }
      >
    >


  export type user_actionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_id?: boolean
    time?: boolean
    user_id?: boolean
    action?: boolean
    session?: boolean | sessionArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["user_action"]>

  export type user_actionSelectScalar = {
    id?: boolean
    session_id?: boolean
    time?: boolean
    user_id?: boolean
    action?: boolean
  }

  export type user_actionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    session?: boolean | sessionArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }


  type user_actionGetPayload<S extends boolean | null | undefined | user_actionArgs> = $Types.GetResult<user_actionPayload, S>

  type user_actionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_actionFindManyArgs, 'select' | 'include'> & {
      select?: User_actionCountAggregateInputType | true
    }

  export interface user_actionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_action'], meta: { name: 'user_action' } }
    /**
     * Find zero or one User_action that matches the filter.
     * @param {user_actionFindUniqueArgs} args - Arguments to find a User_action
     * @example
     * // Get one User_action
     * const user_action = await prisma.user_action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_actionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_actionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_action'> extends True ? Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_action that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_actionFindUniqueOrThrowArgs} args - Arguments to find a User_action
     * @example
     * // Get one User_action
     * const user_action = await prisma.user_action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_actionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_actionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_actionFindFirstArgs} args - Arguments to find a User_action
     * @example
     * // Get one User_action
     * const user_action = await prisma.user_action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_actionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_actionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_action'> extends True ? Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_action that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_actionFindFirstOrThrowArgs} args - Arguments to find a User_action
     * @example
     * // Get one User_action
     * const user_action = await prisma.user_action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_actionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_actionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_actionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_actions
     * const user_actions = await prisma.user_action.findMany()
     * 
     * // Get first 10 User_actions
     * const user_actions = await prisma.user_action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_actionWithIdOnly = await prisma.user_action.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_actionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_actionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_action.
     * @param {user_actionCreateArgs} args - Arguments to create a User_action.
     * @example
     * // Create one User_action
     * const User_action = await prisma.user_action.create({
     *   data: {
     *     // ... data to create a User_action
     *   }
     * })
     * 
    **/
    create<T extends user_actionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_actionCreateArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_actions.
     *     @param {user_actionCreateManyArgs} args - Arguments to create many User_actions.
     *     @example
     *     // Create many User_actions
     *     const user_action = await prisma.user_action.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_actionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_actionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_action.
     * @param {user_actionDeleteArgs} args - Arguments to delete one User_action.
     * @example
     * // Delete one User_action
     * const User_action = await prisma.user_action.delete({
     *   where: {
     *     // ... filter to delete one User_action
     *   }
     * })
     * 
    **/
    delete<T extends user_actionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_actionDeleteArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_action.
     * @param {user_actionUpdateArgs} args - Arguments to update one User_action.
     * @example
     * // Update one User_action
     * const user_action = await prisma.user_action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_actionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_actionUpdateArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_actions.
     * @param {user_actionDeleteManyArgs} args - Arguments to filter User_actions to delete.
     * @example
     * // Delete a few User_actions
     * const { count } = await prisma.user_action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_actionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_actionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_actionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_actions
     * const user_action = await prisma.user_action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_actionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_actionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_action.
     * @param {user_actionUpsertArgs} args - Arguments to update or create a User_action.
     * @example
     * // Update or create a User_action
     * const user_action = await prisma.user_action.upsert({
     *   create: {
     *     // ... data to create a User_action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_action we want to update
     *   }
     * })
    **/
    upsert<T extends user_actionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_actionUpsertArgs<ExtArgs>>
    ): Prisma__user_actionClient<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_actionCountArgs} args - Arguments to filter User_actions to count.
     * @example
     * // Count the number of User_actions
     * const count = await prisma.user_action.count({
     *   where: {
     *     // ... the filter for the User_actions we want to count
     *   }
     * })
    **/
    count<T extends user_actionCountArgs>(
      args?: Subset<T, user_actionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_actionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_actionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_actionAggregateArgs>(args: Subset<T, User_actionAggregateArgs>): Prisma.PrismaPromise<GetUser_actionAggregateType<T>>

    /**
     * Group by User_action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_actionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_actionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_actionGroupByArgs['orderBy'] }
        : { orderBy?: User_actionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_actionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_actionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_actionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    session<T extends sessionArgs<ExtArgs> = {}>(args?: Subset<T, sessionArgs<ExtArgs>>): Prisma__sessionClient<$Types.GetResult<sessionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_action base type for findUnique actions
   */
  export type user_actionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter, which user_action to fetch.
     */
    where: user_actionWhereUniqueInput
  }

  /**
   * user_action findUnique
   */
  export interface user_actionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_actionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_action findUniqueOrThrow
   */
  export type user_actionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter, which user_action to fetch.
     */
    where: user_actionWhereUniqueInput
  }


  /**
   * user_action base type for findFirst actions
   */
  export type user_actionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter, which user_action to fetch.
     */
    where?: user_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_actions to fetch.
     */
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_actions.
     */
    cursor?: user_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_actions.
     */
    distinct?: Enumerable<User_actionScalarFieldEnum>
  }

  /**
   * user_action findFirst
   */
  export interface user_actionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_actionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_action findFirstOrThrow
   */
  export type user_actionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter, which user_action to fetch.
     */
    where?: user_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_actions to fetch.
     */
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_actions.
     */
    cursor?: user_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_actions.
     */
    distinct?: Enumerable<User_actionScalarFieldEnum>
  }


  /**
   * user_action findMany
   */
  export type user_actionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter, which user_actions to fetch.
     */
    where?: user_actionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_actions to fetch.
     */
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_actions.
     */
    cursor?: user_actionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_actions.
     */
    skip?: number
    distinct?: Enumerable<User_actionScalarFieldEnum>
  }


  /**
   * user_action create
   */
  export type user_actionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * The data needed to create a user_action.
     */
    data: XOR<user_actionCreateInput, user_actionUncheckedCreateInput>
  }


  /**
   * user_action createMany
   */
  export type user_actionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_actions.
     */
    data: Enumerable<user_actionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_action update
   */
  export type user_actionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * The data needed to update a user_action.
     */
    data: XOR<user_actionUpdateInput, user_actionUncheckedUpdateInput>
    /**
     * Choose, which user_action to update.
     */
    where: user_actionWhereUniqueInput
  }


  /**
   * user_action updateMany
   */
  export type user_actionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_actions.
     */
    data: XOR<user_actionUpdateManyMutationInput, user_actionUncheckedUpdateManyInput>
    /**
     * Filter which user_actions to update
     */
    where?: user_actionWhereInput
  }


  /**
   * user_action upsert
   */
  export type user_actionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * The filter to search for the user_action to update in case it exists.
     */
    where: user_actionWhereUniqueInput
    /**
     * In case the user_action found by the `where` argument doesn't exist, create a new user_action with this data.
     */
    create: XOR<user_actionCreateInput, user_actionUncheckedCreateInput>
    /**
     * In case the user_action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_actionUpdateInput, user_actionUncheckedUpdateInput>
  }


  /**
   * user_action delete
   */
  export type user_actionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    /**
     * Filter which user_action to delete.
     */
    where: user_actionWhereUniqueInput
  }


  /**
   * user_action deleteMany
   */
  export type user_actionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_actions to delete
     */
    where?: user_actionWhereInput
  }


  /**
   * user_action without action
   */
  export type user_actionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
  }



  /**
   * Model center
   */


  export type AggregateCenter = {
    _count: CenterCountAggregateOutputType | null
    _avg: CenterAvgAggregateOutputType | null
    _sum: CenterSumAggregateOutputType | null
    _min: CenterMinAggregateOutputType | null
    _max: CenterMaxAggregateOutputType | null
  }

  export type CenterAvgAggregateOutputType = {
    id: number | null
  }

  export type CenterSumAggregateOutputType = {
    id: number | null
  }

  export type CenterMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: CenterType | null
    name: string | null
  }

  export type CenterMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    type: CenterType | null
    name: string | null
  }

  export type CenterCountAggregateOutputType = {
    id: number
    created_at: number
    type: number
    name: number
    _all: number
  }


  export type CenterAvgAggregateInputType = {
    id?: true
  }

  export type CenterSumAggregateInputType = {
    id?: true
  }

  export type CenterMinAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    name?: true
  }

  export type CenterMaxAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    name?: true
  }

  export type CenterCountAggregateInputType = {
    id?: true
    created_at?: true
    type?: true
    name?: true
    _all?: true
  }

  export type CenterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which center to aggregate.
     */
    where?: centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of centers to fetch.
     */
    orderBy?: Enumerable<centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned centers
    **/
    _count?: true | CenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CenterMaxAggregateInputType
  }

  export type GetCenterAggregateType<T extends CenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCenter[P]>
      : GetScalarType<T[P], AggregateCenter[P]>
  }




  export type CenterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: centerWhereInput
    orderBy?: Enumerable<centerOrderByWithAggregationInput>
    by: CenterScalarFieldEnum[]
    having?: centerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CenterCountAggregateInputType | true
    _avg?: CenterAvgAggregateInputType
    _sum?: CenterSumAggregateInputType
    _min?: CenterMinAggregateInputType
    _max?: CenterMaxAggregateInputType
  }


  export type CenterGroupByOutputType = {
    id: number
    created_at: Date | null
    type: CenterType
    name: string
    _count: CenterCountAggregateOutputType | null
    _avg: CenterAvgAggregateOutputType | null
    _sum: CenterSumAggregateOutputType | null
    _min: CenterMinAggregateOutputType | null
    _max: CenterMaxAggregateOutputType | null
  }

  type GetCenterGroupByPayload<T extends CenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CenterGroupByOutputType[P]>
            : GetScalarType<T[P], CenterGroupByOutputType[P]>
        }
      >
    >


  export type centerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    type?: boolean
    name?: boolean
    user_centers?: boolean | center$user_centersArgs<ExtArgs>
    _count?: boolean | CenterCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["center"]>

  export type centerSelectScalar = {
    id?: boolean
    created_at?: boolean
    type?: boolean
    name?: boolean
  }

  export type centerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_centers?: boolean | center$user_centersArgs<ExtArgs>
    _count?: boolean | CenterCountOutputTypeArgs<ExtArgs>
  }


  type centerGetPayload<S extends boolean | null | undefined | centerArgs> = $Types.GetResult<centerPayload, S>

  type centerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<centerFindManyArgs, 'select' | 'include'> & {
      select?: CenterCountAggregateInputType | true
    }

  export interface centerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['center'], meta: { name: 'center' } }
    /**
     * Find zero or one Center that matches the filter.
     * @param {centerFindUniqueArgs} args - Arguments to find a Center
     * @example
     * // Get one Center
     * const center = await prisma.center.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends centerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, centerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'center'> extends True ? Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Center that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {centerFindUniqueOrThrowArgs} args - Arguments to find a Center
     * @example
     * // Get one Center
     * const center = await prisma.center.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends centerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, centerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Center that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {centerFindFirstArgs} args - Arguments to find a Center
     * @example
     * // Get one Center
     * const center = await prisma.center.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends centerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, centerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'center'> extends True ? Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Center that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {centerFindFirstOrThrowArgs} args - Arguments to find a Center
     * @example
     * // Get one Center
     * const center = await prisma.center.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends centerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, centerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Centers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {centerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Centers
     * const centers = await prisma.center.findMany()
     * 
     * // Get first 10 Centers
     * const centers = await prisma.center.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const centerWithIdOnly = await prisma.center.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends centerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, centerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<centerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Center.
     * @param {centerCreateArgs} args - Arguments to create a Center.
     * @example
     * // Create one Center
     * const Center = await prisma.center.create({
     *   data: {
     *     // ... data to create a Center
     *   }
     * })
     * 
    **/
    create<T extends centerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, centerCreateArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Centers.
     *     @param {centerCreateManyArgs} args - Arguments to create many Centers.
     *     @example
     *     // Create many Centers
     *     const center = await prisma.center.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends centerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, centerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Center.
     * @param {centerDeleteArgs} args - Arguments to delete one Center.
     * @example
     * // Delete one Center
     * const Center = await prisma.center.delete({
     *   where: {
     *     // ... filter to delete one Center
     *   }
     * })
     * 
    **/
    delete<T extends centerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, centerDeleteArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Center.
     * @param {centerUpdateArgs} args - Arguments to update one Center.
     * @example
     * // Update one Center
     * const center = await prisma.center.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends centerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, centerUpdateArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Centers.
     * @param {centerDeleteManyArgs} args - Arguments to filter Centers to delete.
     * @example
     * // Delete a few Centers
     * const { count } = await prisma.center.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends centerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, centerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Centers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {centerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Centers
     * const center = await prisma.center.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends centerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, centerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Center.
     * @param {centerUpsertArgs} args - Arguments to update or create a Center.
     * @example
     * // Update or create a Center
     * const center = await prisma.center.upsert({
     *   create: {
     *     // ... data to create a Center
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Center we want to update
     *   }
     * })
    **/
    upsert<T extends centerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, centerUpsertArgs<ExtArgs>>
    ): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Centers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {centerCountArgs} args - Arguments to filter Centers to count.
     * @example
     * // Count the number of Centers
     * const count = await prisma.center.count({
     *   where: {
     *     // ... the filter for the Centers we want to count
     *   }
     * })
    **/
    count<T extends centerCountArgs>(
      args?: Subset<T, centerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Center.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CenterAggregateArgs>(args: Subset<T, CenterAggregateArgs>): Prisma.PrismaPromise<GetCenterAggregateType<T>>

    /**
     * Group by Center.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CenterGroupByArgs['orderBy'] }
        : { orderBy?: CenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for center.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__centerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user_centers<T extends center$user_centersArgs<ExtArgs> = {}>(args?: Subset<T, center$user_centersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * center base type for findUnique actions
   */
  export type centerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter, which center to fetch.
     */
    where: centerWhereUniqueInput
  }

  /**
   * center findUnique
   */
  export interface centerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends centerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * center findUniqueOrThrow
   */
  export type centerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter, which center to fetch.
     */
    where: centerWhereUniqueInput
  }


  /**
   * center base type for findFirst actions
   */
  export type centerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter, which center to fetch.
     */
    where?: centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of centers to fetch.
     */
    orderBy?: Enumerable<centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for centers.
     */
    cursor?: centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of centers.
     */
    distinct?: Enumerable<CenterScalarFieldEnum>
  }

  /**
   * center findFirst
   */
  export interface centerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends centerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * center findFirstOrThrow
   */
  export type centerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter, which center to fetch.
     */
    where?: centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of centers to fetch.
     */
    orderBy?: Enumerable<centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for centers.
     */
    cursor?: centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of centers.
     */
    distinct?: Enumerable<CenterScalarFieldEnum>
  }


  /**
   * center findMany
   */
  export type centerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter, which centers to fetch.
     */
    where?: centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of centers to fetch.
     */
    orderBy?: Enumerable<centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing centers.
     */
    cursor?: centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` centers.
     */
    skip?: number
    distinct?: Enumerable<CenterScalarFieldEnum>
  }


  /**
   * center create
   */
  export type centerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * The data needed to create a center.
     */
    data: XOR<centerCreateInput, centerUncheckedCreateInput>
  }


  /**
   * center createMany
   */
  export type centerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many centers.
     */
    data: Enumerable<centerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * center update
   */
  export type centerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * The data needed to update a center.
     */
    data: XOR<centerUpdateInput, centerUncheckedUpdateInput>
    /**
     * Choose, which center to update.
     */
    where: centerWhereUniqueInput
  }


  /**
   * center updateMany
   */
  export type centerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update centers.
     */
    data: XOR<centerUpdateManyMutationInput, centerUncheckedUpdateManyInput>
    /**
     * Filter which centers to update
     */
    where?: centerWhereInput
  }


  /**
   * center upsert
   */
  export type centerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * The filter to search for the center to update in case it exists.
     */
    where: centerWhereUniqueInput
    /**
     * In case the center found by the `where` argument doesn't exist, create a new center with this data.
     */
    create: XOR<centerCreateInput, centerUncheckedCreateInput>
    /**
     * In case the center was found with the provided `where` argument, update it with this data.
     */
    update: XOR<centerUpdateInput, centerUncheckedUpdateInput>
  }


  /**
   * center delete
   */
  export type centerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
    /**
     * Filter which center to delete.
     */
    where: centerWhereUniqueInput
  }


  /**
   * center deleteMany
   */
  export type centerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which centers to delete
     */
    where?: centerWhereInput
  }


  /**
   * center.user_centers
   */
  export type center$user_centersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    where?: user_centerWhereInput
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    cursor?: user_centerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_centerScalarFieldEnum>
  }


  /**
   * center without action
   */
  export type centerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the center
     */
    select?: centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: centerInclude<ExtArgs> | null
  }



  /**
   * Model message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    from_id: number | null
    to_id: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    from_id: number | null
    to_id: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    from_id: number | null
    to_id: number | null
    read_on: Date | null
    content: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    from_id: number | null
    to_id: number | null
    read_on: Date | null
    content: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    created_at: number
    from_id: number
    to_id: number
    read_on: number
    content: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    from_id?: true
    to_id?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    from_id?: true
    to_id?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    created_at?: true
    from_id?: true
    to_id?: true
    read_on?: true
    content?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    created_at?: true
    from_id?: true
    to_id?: true
    read_on?: true
    content?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    created_at?: true
    from_id?: true
    to_id?: true
    read_on?: true
    content?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: Enumerable<messageOrderByWithAggregationInput>
    by: MessageScalarFieldEnum[]
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: number
    created_at: Date | null
    from_id: number
    to_id: number
    read_on: Date | null
    content: string
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    from_id?: boolean
    to_id?: boolean
    read_on?: boolean
    content?: boolean
    from?: boolean | userArgs<ExtArgs>
    to?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    id?: boolean
    created_at?: boolean
    from_id?: boolean
    to_id?: boolean
    read_on?: boolean
    content?: boolean
  }

  export type messageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    from?: boolean | userArgs<ExtArgs>
    to?: boolean | userArgs<ExtArgs>
  }


  type messageGetPayload<S extends boolean | null | undefined | messageArgs> = $Types.GetResult<messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<messageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends messageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'message'> extends True ? Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends messageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'message'> extends True ? Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends messageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<messagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends messageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, messageCreateArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {messageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends messageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends messageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, messageDeleteArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends messageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpdateArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends messageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends messageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends messageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, messageUpsertArgs<ExtArgs>>
    ): Prisma__messageClient<$Types.GetResult<messagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    from<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    to<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * message base type for findUnique actions
   */
  export type messageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUnique
   */
  export interface messageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends messageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message base type for findFirst actions
   */
  export type messageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * message findFirst
   */
  export interface messageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends messageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data: XOR<messageCreateInput, messageUncheckedCreateInput>
  }


  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: Enumerable<messageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
  }


  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }


  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }


  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
  }


  /**
   * message without action
   */
  export type messageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
  }



  /**
   * Model patient_caregiver
   */


  export type AggregatePatient_caregiver = {
    _count: Patient_caregiverCountAggregateOutputType | null
    _avg: Patient_caregiverAvgAggregateOutputType | null
    _sum: Patient_caregiverSumAggregateOutputType | null
    _min: Patient_caregiverMinAggregateOutputType | null
    _max: Patient_caregiverMaxAggregateOutputType | null
  }

  export type Patient_caregiverAvgAggregateOutputType = {
    id: number | null
    patient_id: number | null
    caregiver_id: number | null
  }

  export type Patient_caregiverSumAggregateOutputType = {
    id: number | null
    patient_id: number | null
    caregiver_id: number | null
  }

  export type Patient_caregiverMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    confirmed: boolean | null
    patient_id: number | null
    caregiver_id: number | null
    role: PatientCaregiverType | null
  }

  export type Patient_caregiverMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    confirmed: boolean | null
    patient_id: number | null
    caregiver_id: number | null
    role: PatientCaregiverType | null
  }

  export type Patient_caregiverCountAggregateOutputType = {
    id: number
    created_at: number
    confirmed: number
    patient_id: number
    caregiver_id: number
    role: number
    _all: number
  }


  export type Patient_caregiverAvgAggregateInputType = {
    id?: true
    patient_id?: true
    caregiver_id?: true
  }

  export type Patient_caregiverSumAggregateInputType = {
    id?: true
    patient_id?: true
    caregiver_id?: true
  }

  export type Patient_caregiverMinAggregateInputType = {
    id?: true
    created_at?: true
    confirmed?: true
    patient_id?: true
    caregiver_id?: true
    role?: true
  }

  export type Patient_caregiverMaxAggregateInputType = {
    id?: true
    created_at?: true
    confirmed?: true
    patient_id?: true
    caregiver_id?: true
    role?: true
  }

  export type Patient_caregiverCountAggregateInputType = {
    id?: true
    created_at?: true
    confirmed?: true
    patient_id?: true
    caregiver_id?: true
    role?: true
    _all?: true
  }

  export type Patient_caregiverAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_caregiver to aggregate.
     */
    where?: patient_caregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_caregivers to fetch.
     */
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_caregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_caregivers
    **/
    _count?: true | Patient_caregiverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_caregiverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_caregiverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_caregiverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_caregiverMaxAggregateInputType
  }

  export type GetPatient_caregiverAggregateType<T extends Patient_caregiverAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_caregiver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_caregiver[P]>
      : GetScalarType<T[P], AggregatePatient_caregiver[P]>
  }




  export type Patient_caregiverGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: patient_caregiverWhereInput
    orderBy?: Enumerable<patient_caregiverOrderByWithAggregationInput>
    by: Patient_caregiverScalarFieldEnum[]
    having?: patient_caregiverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_caregiverCountAggregateInputType | true
    _avg?: Patient_caregiverAvgAggregateInputType
    _sum?: Patient_caregiverSumAggregateInputType
    _min?: Patient_caregiverMinAggregateInputType
    _max?: Patient_caregiverMaxAggregateInputType
  }


  export type Patient_caregiverGroupByOutputType = {
    id: number
    created_at: Date | null
    confirmed: boolean
    patient_id: number
    caregiver_id: number
    role: PatientCaregiverType
    _count: Patient_caregiverCountAggregateOutputType | null
    _avg: Patient_caregiverAvgAggregateOutputType | null
    _sum: Patient_caregiverSumAggregateOutputType | null
    _min: Patient_caregiverMinAggregateOutputType | null
    _max: Patient_caregiverMaxAggregateOutputType | null
  }

  type GetPatient_caregiverGroupByPayload<T extends Patient_caregiverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Patient_caregiverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_caregiverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_caregiverGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_caregiverGroupByOutputType[P]>
        }
      >
    >


  export type patient_caregiverSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    confirmed?: boolean
    patient_id?: boolean
    caregiver_id?: boolean
    role?: boolean
    patient?: boolean | userArgs<ExtArgs>
    caregiver?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["patient_caregiver"]>

  export type patient_caregiverSelectScalar = {
    id?: boolean
    created_at?: boolean
    confirmed?: boolean
    patient_id?: boolean
    caregiver_id?: boolean
    role?: boolean
  }

  export type patient_caregiverInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    patient?: boolean | userArgs<ExtArgs>
    caregiver?: boolean | userArgs<ExtArgs>
  }


  type patient_caregiverGetPayload<S extends boolean | null | undefined | patient_caregiverArgs> = $Types.GetResult<patient_caregiverPayload, S>

  type patient_caregiverCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<patient_caregiverFindManyArgs, 'select' | 'include'> & {
      select?: Patient_caregiverCountAggregateInputType | true
    }

  export interface patient_caregiverDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_caregiver'], meta: { name: 'patient_caregiver' } }
    /**
     * Find zero or one Patient_caregiver that matches the filter.
     * @param {patient_caregiverFindUniqueArgs} args - Arguments to find a Patient_caregiver
     * @example
     * // Get one Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends patient_caregiverFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, patient_caregiverFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'patient_caregiver'> extends True ? Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Patient_caregiver that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {patient_caregiverFindUniqueOrThrowArgs} args - Arguments to find a Patient_caregiver
     * @example
     * // Get one Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends patient_caregiverFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, patient_caregiverFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Patient_caregiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_caregiverFindFirstArgs} args - Arguments to find a Patient_caregiver
     * @example
     * // Get one Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends patient_caregiverFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, patient_caregiverFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'patient_caregiver'> extends True ? Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Patient_caregiver that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_caregiverFindFirstOrThrowArgs} args - Arguments to find a Patient_caregiver
     * @example
     * // Get one Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends patient_caregiverFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, patient_caregiverFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Patient_caregivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_caregiverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_caregivers
     * const patient_caregivers = await prisma.patient_caregiver.findMany()
     * 
     * // Get first 10 Patient_caregivers
     * const patient_caregivers = await prisma.patient_caregiver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patient_caregiverWithIdOnly = await prisma.patient_caregiver.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends patient_caregiverFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, patient_caregiverFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Patient_caregiver.
     * @param {patient_caregiverCreateArgs} args - Arguments to create a Patient_caregiver.
     * @example
     * // Create one Patient_caregiver
     * const Patient_caregiver = await prisma.patient_caregiver.create({
     *   data: {
     *     // ... data to create a Patient_caregiver
     *   }
     * })
     * 
    **/
    create<T extends patient_caregiverCreateArgs<ExtArgs>>(
      args: SelectSubset<T, patient_caregiverCreateArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Patient_caregivers.
     *     @param {patient_caregiverCreateManyArgs} args - Arguments to create many Patient_caregivers.
     *     @example
     *     // Create many Patient_caregivers
     *     const patient_caregiver = await prisma.patient_caregiver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends patient_caregiverCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, patient_caregiverCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient_caregiver.
     * @param {patient_caregiverDeleteArgs} args - Arguments to delete one Patient_caregiver.
     * @example
     * // Delete one Patient_caregiver
     * const Patient_caregiver = await prisma.patient_caregiver.delete({
     *   where: {
     *     // ... filter to delete one Patient_caregiver
     *   }
     * })
     * 
    **/
    delete<T extends patient_caregiverDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, patient_caregiverDeleteArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Patient_caregiver.
     * @param {patient_caregiverUpdateArgs} args - Arguments to update one Patient_caregiver.
     * @example
     * // Update one Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends patient_caregiverUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, patient_caregiverUpdateArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Patient_caregivers.
     * @param {patient_caregiverDeleteManyArgs} args - Arguments to filter Patient_caregivers to delete.
     * @example
     * // Delete a few Patient_caregivers
     * const { count } = await prisma.patient_caregiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends patient_caregiverDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, patient_caregiverDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_caregiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_caregivers
     * const patient_caregiver = await prisma.patient_caregiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends patient_caregiverUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, patient_caregiverUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient_caregiver.
     * @param {patient_caregiverUpsertArgs} args - Arguments to update or create a Patient_caregiver.
     * @example
     * // Update or create a Patient_caregiver
     * const patient_caregiver = await prisma.patient_caregiver.upsert({
     *   create: {
     *     // ... data to create a Patient_caregiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_caregiver we want to update
     *   }
     * })
    **/
    upsert<T extends patient_caregiverUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, patient_caregiverUpsertArgs<ExtArgs>>
    ): Prisma__patient_caregiverClient<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Patient_caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_caregiverCountArgs} args - Arguments to filter Patient_caregivers to count.
     * @example
     * // Count the number of Patient_caregivers
     * const count = await prisma.patient_caregiver.count({
     *   where: {
     *     // ... the filter for the Patient_caregivers we want to count
     *   }
     * })
    **/
    count<T extends patient_caregiverCountArgs>(
      args?: Subset<T, patient_caregiverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_caregiverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_caregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_caregiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_caregiverAggregateArgs>(args: Subset<T, Patient_caregiverAggregateArgs>): Prisma.PrismaPromise<GetPatient_caregiverAggregateType<T>>

    /**
     * Group by Patient_caregiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_caregiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Patient_caregiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Patient_caregiverGroupByArgs['orderBy'] }
        : { orderBy?: Patient_caregiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Patient_caregiverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_caregiverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_caregiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__patient_caregiverClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    patient<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    caregiver<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * patient_caregiver base type for findUnique actions
   */
  export type patient_caregiverFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter, which patient_caregiver to fetch.
     */
    where: patient_caregiverWhereUniqueInput
  }

  /**
   * patient_caregiver findUnique
   */
  export interface patient_caregiverFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends patient_caregiverFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * patient_caregiver findUniqueOrThrow
   */
  export type patient_caregiverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter, which patient_caregiver to fetch.
     */
    where: patient_caregiverWhereUniqueInput
  }


  /**
   * patient_caregiver base type for findFirst actions
   */
  export type patient_caregiverFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter, which patient_caregiver to fetch.
     */
    where?: patient_caregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_caregivers to fetch.
     */
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_caregivers.
     */
    cursor?: patient_caregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_caregivers.
     */
    distinct?: Enumerable<Patient_caregiverScalarFieldEnum>
  }

  /**
   * patient_caregiver findFirst
   */
  export interface patient_caregiverFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends patient_caregiverFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * patient_caregiver findFirstOrThrow
   */
  export type patient_caregiverFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter, which patient_caregiver to fetch.
     */
    where?: patient_caregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_caregivers to fetch.
     */
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_caregivers.
     */
    cursor?: patient_caregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_caregivers.
     */
    distinct?: Enumerable<Patient_caregiverScalarFieldEnum>
  }


  /**
   * patient_caregiver findMany
   */
  export type patient_caregiverFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter, which patient_caregivers to fetch.
     */
    where?: patient_caregiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_caregivers to fetch.
     */
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_caregivers.
     */
    cursor?: patient_caregiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_caregivers.
     */
    skip?: number
    distinct?: Enumerable<Patient_caregiverScalarFieldEnum>
  }


  /**
   * patient_caregiver create
   */
  export type patient_caregiverCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * The data needed to create a patient_caregiver.
     */
    data: XOR<patient_caregiverCreateInput, patient_caregiverUncheckedCreateInput>
  }


  /**
   * patient_caregiver createMany
   */
  export type patient_caregiverCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_caregivers.
     */
    data: Enumerable<patient_caregiverCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * patient_caregiver update
   */
  export type patient_caregiverUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * The data needed to update a patient_caregiver.
     */
    data: XOR<patient_caregiverUpdateInput, patient_caregiverUncheckedUpdateInput>
    /**
     * Choose, which patient_caregiver to update.
     */
    where: patient_caregiverWhereUniqueInput
  }


  /**
   * patient_caregiver updateMany
   */
  export type patient_caregiverUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_caregivers.
     */
    data: XOR<patient_caregiverUpdateManyMutationInput, patient_caregiverUncheckedUpdateManyInput>
    /**
     * Filter which patient_caregivers to update
     */
    where?: patient_caregiverWhereInput
  }


  /**
   * patient_caregiver upsert
   */
  export type patient_caregiverUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * The filter to search for the patient_caregiver to update in case it exists.
     */
    where: patient_caregiverWhereUniqueInput
    /**
     * In case the patient_caregiver found by the `where` argument doesn't exist, create a new patient_caregiver with this data.
     */
    create: XOR<patient_caregiverCreateInput, patient_caregiverUncheckedCreateInput>
    /**
     * In case the patient_caregiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_caregiverUpdateInput, patient_caregiverUncheckedUpdateInput>
  }


  /**
   * patient_caregiver delete
   */
  export type patient_caregiverDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    /**
     * Filter which patient_caregiver to delete.
     */
    where: patient_caregiverWhereUniqueInput
  }


  /**
   * patient_caregiver deleteMany
   */
  export type patient_caregiverDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_caregivers to delete
     */
    where?: patient_caregiverWhereInput
  }


  /**
   * patient_caregiver without action
   */
  export type patient_caregiverArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    gender: number | null
    height_cm: number | null
    weight: Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    salt_diet: number | null
    energy_goal: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    gender: number | null
    height_cm: number | null
    weight: Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    salt_diet: number | null
    energy_goal: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    sub: string | null
    password: string | null
    type: UserType | null
    birthdate: Date | null
    title: string | null
    email: string | null
    phone: string | null
    firstname: string | null
    lastname: string | null
    alias: string | null
    notes: string | null
    avatarUrl: string | null
    install_token: string | null
    subscription: string | null
    gender: number | null
    height_cm: number | null
    weight: Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    hypertriglyceridemia: boolean | null
    hypercholesterolemia: boolean | null
    salt_diet: number | null
    energy_goal: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    sub: string | null
    password: string | null
    type: UserType | null
    birthdate: Date | null
    title: string | null
    email: string | null
    phone: string | null
    firstname: string | null
    lastname: string | null
    alias: string | null
    notes: string | null
    avatarUrl: string | null
    install_token: string | null
    subscription: string | null
    gender: number | null
    height_cm: number | null
    weight: Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    hypertriglyceridemia: boolean | null
    hypercholesterolemia: boolean | null
    salt_diet: number | null
    energy_goal: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    created_at: number
    sub: number
    password: number
    type: number
    birthdate: number
    title: number
    email: number
    phone: number
    firstname: number
    lastname: number
    alias: number
    notes: number
    avatarUrl: number
    install_token: number
    subscription: number
    gender: number
    height_cm: number
    weight: number
    actsport: number
    actprof: number
    diabetes_type: number
    hypertriglyceridemia: number
    hypercholesterolemia: number
    salt_diet: number
    energy_goal: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    gender?: true
    height_cm?: true
    weight?: true
    actsport?: true
    actprof?: true
    diabetes_type?: true
    salt_diet?: true
    energy_goal?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    gender?: true
    height_cm?: true
    weight?: true
    actsport?: true
    actprof?: true
    diabetes_type?: true
    salt_diet?: true
    energy_goal?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    created_at?: true
    sub?: true
    password?: true
    type?: true
    birthdate?: true
    title?: true
    email?: true
    phone?: true
    firstname?: true
    lastname?: true
    alias?: true
    notes?: true
    avatarUrl?: true
    install_token?: true
    subscription?: true
    gender?: true
    height_cm?: true
    weight?: true
    actsport?: true
    actprof?: true
    diabetes_type?: true
    hypertriglyceridemia?: true
    hypercholesterolemia?: true
    salt_diet?: true
    energy_goal?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    created_at?: true
    sub?: true
    password?: true
    type?: true
    birthdate?: true
    title?: true
    email?: true
    phone?: true
    firstname?: true
    lastname?: true
    alias?: true
    notes?: true
    avatarUrl?: true
    install_token?: true
    subscription?: true
    gender?: true
    height_cm?: true
    weight?: true
    actsport?: true
    actprof?: true
    diabetes_type?: true
    hypertriglyceridemia?: true
    hypercholesterolemia?: true
    salt_diet?: true
    energy_goal?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    created_at?: true
    sub?: true
    password?: true
    type?: true
    birthdate?: true
    title?: true
    email?: true
    phone?: true
    firstname?: true
    lastname?: true
    alias?: true
    notes?: true
    avatarUrl?: true
    install_token?: true
    subscription?: true
    gender?: true
    height_cm?: true
    weight?: true
    actsport?: true
    actprof?: true
    diabetes_type?: true
    hypertriglyceridemia?: true
    hypercholesterolemia?: true
    salt_diet?: true
    energy_goal?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    created_at: Date | null
    sub: string | null
    password: string | null
    type: UserType
    birthdate: Date | null
    title: string | null
    email: string | null
    phone: string | null
    firstname: string | null
    lastname: string | null
    alias: string | null
    notes: string | null
    avatarUrl: string | null
    install_token: string | null
    subscription: string | null
    gender: number | null
    height_cm: number | null
    weight: Decimal | null
    actsport: number | null
    actprof: number | null
    diabetes_type: number | null
    hypertriglyceridemia: boolean | null
    hypercholesterolemia: boolean | null
    salt_diet: number | null
    energy_goal: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    sub?: boolean
    password?: boolean
    type?: boolean
    birthdate?: boolean
    title?: boolean
    email?: boolean
    phone?: boolean
    firstname?: boolean
    lastname?: boolean
    alias?: boolean
    notes?: boolean
    avatarUrl?: boolean
    install_token?: boolean
    subscription?: boolean
    gender?: boolean
    height_cm?: boolean
    weight?: boolean
    actsport?: boolean
    actprof?: boolean
    diabetes_type?: boolean
    hypertriglyceridemia?: boolean
    hypercholesterolemia?: boolean
    salt_diet?: boolean
    energy_goal?: boolean
    user_actions?: boolean | user$user_actionsArgs<ExtArgs>
    favorites?: boolean | user$favoritesArgs<ExtArgs>
    fractionings?: boolean | user$fractioningsArgs<ExtArgs>
    meals?: boolean | user$mealsArgs<ExtArgs>
    messages_from?: boolean | user$messages_fromArgs<ExtArgs>
    messages_to?: boolean | user$messages_toArgs<ExtArgs>
    patients?: boolean | user$patientsArgs<ExtArgs>
    caregivers?: boolean | user$caregiversArgs<ExtArgs>
    user_centers?: boolean | user$user_centersArgs<ExtArgs>
    user_goals?: boolean | user$user_goalsArgs<ExtArgs>
    user_measurements?: boolean | user$user_measurementsArgs<ExtArgs>
    user_withings?: boolean | user$user_withingsArgs<ExtArgs>
    user_patients?: boolean | user$user_patientsArgs<ExtArgs>
    user_qcuanswers?: boolean | user$user_qcuanswersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    created_at?: boolean
    sub?: boolean
    password?: boolean
    type?: boolean
    birthdate?: boolean
    title?: boolean
    email?: boolean
    phone?: boolean
    firstname?: boolean
    lastname?: boolean
    alias?: boolean
    notes?: boolean
    avatarUrl?: boolean
    install_token?: boolean
    subscription?: boolean
    gender?: boolean
    height_cm?: boolean
    weight?: boolean
    actsport?: boolean
    actprof?: boolean
    diabetes_type?: boolean
    hypertriglyceridemia?: boolean
    hypercholesterolemia?: boolean
    salt_diet?: boolean
    energy_goal?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user_actions?: boolean | user$user_actionsArgs<ExtArgs>
    favorites?: boolean | user$favoritesArgs<ExtArgs>
    fractionings?: boolean | user$fractioningsArgs<ExtArgs>
    meals?: boolean | user$mealsArgs<ExtArgs>
    messages_from?: boolean | user$messages_fromArgs<ExtArgs>
    messages_to?: boolean | user$messages_toArgs<ExtArgs>
    patients?: boolean | user$patientsArgs<ExtArgs>
    caregivers?: boolean | user$caregiversArgs<ExtArgs>
    user_centers?: boolean | user$user_centersArgs<ExtArgs>
    user_goals?: boolean | user$user_goalsArgs<ExtArgs>
    user_measurements?: boolean | user$user_measurementsArgs<ExtArgs>
    user_withings?: boolean | user$user_withingsArgs<ExtArgs>
    user_patients?: boolean | user$user_patientsArgs<ExtArgs>
    user_qcuanswers?: boolean | user$user_qcuanswersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type userGetPayload<S extends boolean | null | undefined | userArgs> = $Types.GetResult<userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user_actions<T extends user$user_actionsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_actionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    favorites<T extends user$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, user$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findMany', never>| Null>;

    fractionings<T extends user$fractioningsArgs<ExtArgs> = {}>(args?: Subset<T, user$fractioningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findMany', never>| Null>;

    meals<T extends user$mealsArgs<ExtArgs> = {}>(args?: Subset<T, user$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<mealPayload<ExtArgs>, T, 'findMany', never>| Null>;

    messages_from<T extends user$messages_fromArgs<ExtArgs> = {}>(args?: Subset<T, user$messages_fromArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<messagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    messages_to<T extends user$messages_toArgs<ExtArgs> = {}>(args?: Subset<T, user$messages_toArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<messagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    patients<T extends user$patientsArgs<ExtArgs> = {}>(args?: Subset<T, user$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findMany', never>| Null>;

    caregivers<T extends user$caregiversArgs<ExtArgs> = {}>(args?: Subset<T, user$caregiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<patient_caregiverPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_centers<T extends user$user_centersArgs<ExtArgs> = {}>(args?: Subset<T, user$user_centersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_goals<T extends user$user_goalsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_goalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_measurements<T extends user$user_measurementsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_withings<T extends user$user_withingsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_withingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_patients<T extends user$user_patientsArgs<ExtArgs> = {}>(args?: Subset<T, user$user_patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user_qcuanswers<T extends user$user_qcuanswersArgs<ExtArgs> = {}>(args?: Subset<T, user$user_qcuanswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUnique
   */
  export interface userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user findFirst
   */
  export interface userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends userFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<userCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.user_actions
   */
  export type user$user_actionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_action
     */
    select?: user_actionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_actionInclude<ExtArgs> | null
    where?: user_actionWhereInput
    orderBy?: Enumerable<user_actionOrderByWithRelationInput>
    cursor?: user_actionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_actionScalarFieldEnum>
  }


  /**
   * user.favorites
   */
  export type user$favoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    where?: favoriteWhereInput
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    cursor?: favoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }


  /**
   * user.fractionings
   */
  export type user$fractioningsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    where?: fractioningWhereInput
    orderBy?: Enumerable<fractioningOrderByWithRelationInput>
    cursor?: fractioningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FractioningScalarFieldEnum>
  }


  /**
   * user.meals
   */
  export type user$mealsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    where?: mealWhereInput
    orderBy?: Enumerable<mealOrderByWithRelationInput>
    cursor?: mealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MealScalarFieldEnum>
  }


  /**
   * user.messages_from
   */
  export type user$messages_fromArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * user.messages_to
   */
  export type user$messages_toArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: Enumerable<messageOrderByWithRelationInput>
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * user.patients
   */
  export type user$patientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    where?: patient_caregiverWhereInput
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    cursor?: patient_caregiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Patient_caregiverScalarFieldEnum>
  }


  /**
   * user.caregivers
   */
  export type user$caregiversArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_caregiver
     */
    select?: patient_caregiverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: patient_caregiverInclude<ExtArgs> | null
    where?: patient_caregiverWhereInput
    orderBy?: Enumerable<patient_caregiverOrderByWithRelationInput>
    cursor?: patient_caregiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Patient_caregiverScalarFieldEnum>
  }


  /**
   * user.user_centers
   */
  export type user$user_centersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    where?: user_centerWhereInput
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    cursor?: user_centerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_centerScalarFieldEnum>
  }


  /**
   * user.user_goals
   */
  export type user$user_goalsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    where?: user_goalWhereInput
    orderBy?: Enumerable<user_goalOrderByWithRelationInput>
    cursor?: user_goalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_goalScalarFieldEnum>
  }


  /**
   * user.user_measurements
   */
  export type user$user_measurementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    where?: user_measurementWhereInput
    orderBy?: Enumerable<user_measurementOrderByWithRelationInput>
    cursor?: user_measurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_measurementScalarFieldEnum>
  }


  /**
   * user.user_withings
   */
  export type user$user_withingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    where?: user_withingsWhereInput
    orderBy?: Enumerable<user_withingsOrderByWithRelationInput>
    cursor?: user_withingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_withingsScalarFieldEnum>
  }


  /**
   * user.user_patients
   */
  export type user$user_patientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    where?: user_patientWhereInput
    orderBy?: Enumerable<user_patientOrderByWithRelationInput>
    cursor?: user_patientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_patientScalarFieldEnum>
  }


  /**
   * user.user_qcuanswers
   */
  export type user$user_qcuanswersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    where?: user_qcuanswerWhereInput
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    cursor?: user_qcuanswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_qcuanswerScalarFieldEnum>
  }


  /**
   * user without action
   */
  export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model user_center
   */


  export type AggregateUser_center = {
    _count: User_centerCountAggregateOutputType | null
    _avg: User_centerAvgAggregateOutputType | null
    _sum: User_centerSumAggregateOutputType | null
    _min: User_centerMinAggregateOutputType | null
    _max: User_centerMaxAggregateOutputType | null
  }

  export type User_centerAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    center_id: number | null
  }

  export type User_centerSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    center_id: number | null
  }

  export type User_centerMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    center_id: number | null
    role: CenterRole | null
  }

  export type User_centerMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    center_id: number | null
    role: CenterRole | null
  }

  export type User_centerCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    center_id: number
    role: number
    _all: number
  }


  export type User_centerAvgAggregateInputType = {
    id?: true
    user_id?: true
    center_id?: true
  }

  export type User_centerSumAggregateInputType = {
    id?: true
    user_id?: true
    center_id?: true
  }

  export type User_centerMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    center_id?: true
    role?: true
  }

  export type User_centerMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    center_id?: true
    role?: true
  }

  export type User_centerCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    center_id?: true
    role?: true
    _all?: true
  }

  export type User_centerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_center to aggregate.
     */
    where?: user_centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_centers to fetch.
     */
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_centers
    **/
    _count?: true | User_centerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_centerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_centerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_centerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_centerMaxAggregateInputType
  }

  export type GetUser_centerAggregateType<T extends User_centerAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_center]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_center[P]>
      : GetScalarType<T[P], AggregateUser_center[P]>
  }




  export type User_centerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_centerWhereInput
    orderBy?: Enumerable<user_centerOrderByWithAggregationInput>
    by: User_centerScalarFieldEnum[]
    having?: user_centerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_centerCountAggregateInputType | true
    _avg?: User_centerAvgAggregateInputType
    _sum?: User_centerSumAggregateInputType
    _min?: User_centerMinAggregateInputType
    _max?: User_centerMaxAggregateInputType
  }


  export type User_centerGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    center_id: number
    role: CenterRole
    _count: User_centerCountAggregateOutputType | null
    _avg: User_centerAvgAggregateOutputType | null
    _sum: User_centerSumAggregateOutputType | null
    _min: User_centerMinAggregateOutputType | null
    _max: User_centerMaxAggregateOutputType | null
  }

  type GetUser_centerGroupByPayload<T extends User_centerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_centerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_centerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_centerGroupByOutputType[P]>
            : GetScalarType<T[P], User_centerGroupByOutputType[P]>
        }
      >
    >


  export type user_centerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    center_id?: boolean
    role?: boolean
    user?: boolean | userArgs<ExtArgs>
    center?: boolean | centerArgs<ExtArgs>
  }, ExtArgs["result"]["user_center"]>

  export type user_centerSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    center_id?: boolean
    role?: boolean
  }

  export type user_centerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    center?: boolean | centerArgs<ExtArgs>
  }


  type user_centerGetPayload<S extends boolean | null | undefined | user_centerArgs> = $Types.GetResult<user_centerPayload, S>

  type user_centerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_centerFindManyArgs, 'select' | 'include'> & {
      select?: User_centerCountAggregateInputType | true
    }

  export interface user_centerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_center'], meta: { name: 'user_center' } }
    /**
     * Find zero or one User_center that matches the filter.
     * @param {user_centerFindUniqueArgs} args - Arguments to find a User_center
     * @example
     * // Get one User_center
     * const user_center = await prisma.user_center.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_centerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_centerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_center'> extends True ? Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_center that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_centerFindUniqueOrThrowArgs} args - Arguments to find a User_center
     * @example
     * // Get one User_center
     * const user_center = await prisma.user_center.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_centerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_centerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_center that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_centerFindFirstArgs} args - Arguments to find a User_center
     * @example
     * // Get one User_center
     * const user_center = await prisma.user_center.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_centerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_centerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_center'> extends True ? Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_center that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_centerFindFirstOrThrowArgs} args - Arguments to find a User_center
     * @example
     * // Get one User_center
     * const user_center = await prisma.user_center.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_centerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_centerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_centers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_centerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_centers
     * const user_centers = await prisma.user_center.findMany()
     * 
     * // Get first 10 User_centers
     * const user_centers = await prisma.user_center.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_centerWithIdOnly = await prisma.user_center.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_centerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_centerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_center.
     * @param {user_centerCreateArgs} args - Arguments to create a User_center.
     * @example
     * // Create one User_center
     * const User_center = await prisma.user_center.create({
     *   data: {
     *     // ... data to create a User_center
     *   }
     * })
     * 
    **/
    create<T extends user_centerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_centerCreateArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_centers.
     *     @param {user_centerCreateManyArgs} args - Arguments to create many User_centers.
     *     @example
     *     // Create many User_centers
     *     const user_center = await prisma.user_center.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_centerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_centerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_center.
     * @param {user_centerDeleteArgs} args - Arguments to delete one User_center.
     * @example
     * // Delete one User_center
     * const User_center = await prisma.user_center.delete({
     *   where: {
     *     // ... filter to delete one User_center
     *   }
     * })
     * 
    **/
    delete<T extends user_centerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_centerDeleteArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_center.
     * @param {user_centerUpdateArgs} args - Arguments to update one User_center.
     * @example
     * // Update one User_center
     * const user_center = await prisma.user_center.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_centerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_centerUpdateArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_centers.
     * @param {user_centerDeleteManyArgs} args - Arguments to filter User_centers to delete.
     * @example
     * // Delete a few User_centers
     * const { count } = await prisma.user_center.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_centerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_centerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_centers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_centerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_centers
     * const user_center = await prisma.user_center.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_centerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_centerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_center.
     * @param {user_centerUpsertArgs} args - Arguments to update or create a User_center.
     * @example
     * // Update or create a User_center
     * const user_center = await prisma.user_center.upsert({
     *   create: {
     *     // ... data to create a User_center
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_center we want to update
     *   }
     * })
    **/
    upsert<T extends user_centerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_centerUpsertArgs<ExtArgs>>
    ): Prisma__user_centerClient<$Types.GetResult<user_centerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_centers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_centerCountArgs} args - Arguments to filter User_centers to count.
     * @example
     * // Count the number of User_centers
     * const count = await prisma.user_center.count({
     *   where: {
     *     // ... the filter for the User_centers we want to count
     *   }
     * })
    **/
    count<T extends user_centerCountArgs>(
      args?: Subset<T, user_centerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_centerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_center.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_centerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_centerAggregateArgs>(args: Subset<T, User_centerAggregateArgs>): Prisma.PrismaPromise<GetUser_centerAggregateType<T>>

    /**
     * Group by User_center.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_centerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_centerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_centerGroupByArgs['orderBy'] }
        : { orderBy?: User_centerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_centerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_centerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_center.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_centerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    center<T extends centerArgs<ExtArgs> = {}>(args?: Subset<T, centerArgs<ExtArgs>>): Prisma__centerClient<$Types.GetResult<centerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_center base type for findUnique actions
   */
  export type user_centerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter, which user_center to fetch.
     */
    where: user_centerWhereUniqueInput
  }

  /**
   * user_center findUnique
   */
  export interface user_centerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_centerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_center findUniqueOrThrow
   */
  export type user_centerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter, which user_center to fetch.
     */
    where: user_centerWhereUniqueInput
  }


  /**
   * user_center base type for findFirst actions
   */
  export type user_centerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter, which user_center to fetch.
     */
    where?: user_centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_centers to fetch.
     */
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_centers.
     */
    cursor?: user_centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_centers.
     */
    distinct?: Enumerable<User_centerScalarFieldEnum>
  }

  /**
   * user_center findFirst
   */
  export interface user_centerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_centerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_center findFirstOrThrow
   */
  export type user_centerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter, which user_center to fetch.
     */
    where?: user_centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_centers to fetch.
     */
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_centers.
     */
    cursor?: user_centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_centers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_centers.
     */
    distinct?: Enumerable<User_centerScalarFieldEnum>
  }


  /**
   * user_center findMany
   */
  export type user_centerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter, which user_centers to fetch.
     */
    where?: user_centerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_centers to fetch.
     */
    orderBy?: Enumerable<user_centerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_centers.
     */
    cursor?: user_centerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_centers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_centers.
     */
    skip?: number
    distinct?: Enumerable<User_centerScalarFieldEnum>
  }


  /**
   * user_center create
   */
  export type user_centerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * The data needed to create a user_center.
     */
    data: XOR<user_centerCreateInput, user_centerUncheckedCreateInput>
  }


  /**
   * user_center createMany
   */
  export type user_centerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_centers.
     */
    data: Enumerable<user_centerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_center update
   */
  export type user_centerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * The data needed to update a user_center.
     */
    data: XOR<user_centerUpdateInput, user_centerUncheckedUpdateInput>
    /**
     * Choose, which user_center to update.
     */
    where: user_centerWhereUniqueInput
  }


  /**
   * user_center updateMany
   */
  export type user_centerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_centers.
     */
    data: XOR<user_centerUpdateManyMutationInput, user_centerUncheckedUpdateManyInput>
    /**
     * Filter which user_centers to update
     */
    where?: user_centerWhereInput
  }


  /**
   * user_center upsert
   */
  export type user_centerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * The filter to search for the user_center to update in case it exists.
     */
    where: user_centerWhereUniqueInput
    /**
     * In case the user_center found by the `where` argument doesn't exist, create a new user_center with this data.
     */
    create: XOR<user_centerCreateInput, user_centerUncheckedCreateInput>
    /**
     * In case the user_center was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_centerUpdateInput, user_centerUncheckedUpdateInput>
  }


  /**
   * user_center delete
   */
  export type user_centerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
    /**
     * Filter which user_center to delete.
     */
    where: user_centerWhereUniqueInput
  }


  /**
   * user_center deleteMany
   */
  export type user_centerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_centers to delete
     */
    where?: user_centerWhereInput
  }


  /**
   * user_center without action
   */
  export type user_centerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_center
     */
    select?: user_centerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_centerInclude<ExtArgs> | null
  }



  /**
   * Model user_goal
   */


  export type AggregateUser_goal = {
    _count: User_goalCountAggregateOutputType | null
    _avg: User_goalAvgAggregateOutputType | null
    _sum: User_goalSumAggregateOutputType | null
    _min: User_goalMinAggregateOutputType | null
    _max: User_goalMaxAggregateOutputType | null
  }

  export type User_goalAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_goalSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_goalMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: Date | null
    type: GoalType | null
    value: string | null
  }

  export type User_goalMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: Date | null
    type: GoalType | null
    value: string | null
  }

  export type User_goalCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    date: number
    type: number
    value: number
    _all: number
  }


  export type User_goalAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_goalSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_goalMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
  }

  export type User_goalMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
  }

  export type User_goalCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
    _all?: true
  }

  export type User_goalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_goal to aggregate.
     */
    where?: user_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_goals to fetch.
     */
    orderBy?: Enumerable<user_goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_goals
    **/
    _count?: true | User_goalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_goalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_goalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_goalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_goalMaxAggregateInputType
  }

  export type GetUser_goalAggregateType<T extends User_goalAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_goal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_goal[P]>
      : GetScalarType<T[P], AggregateUser_goal[P]>
  }




  export type User_goalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_goalWhereInput
    orderBy?: Enumerable<user_goalOrderByWithAggregationInput>
    by: User_goalScalarFieldEnum[]
    having?: user_goalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_goalCountAggregateInputType | true
    _avg?: User_goalAvgAggregateInputType
    _sum?: User_goalSumAggregateInputType
    _min?: User_goalMinAggregateInputType
    _max?: User_goalMaxAggregateInputType
  }


  export type User_goalGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    date: Date
    type: GoalType
    value: string
    _count: User_goalCountAggregateOutputType | null
    _avg: User_goalAvgAggregateOutputType | null
    _sum: User_goalSumAggregateOutputType | null
    _min: User_goalMinAggregateOutputType | null
    _max: User_goalMaxAggregateOutputType | null
  }

  type GetUser_goalGroupByPayload<T extends User_goalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_goalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_goalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_goalGroupByOutputType[P]>
            : GetScalarType<T[P], User_goalGroupByOutputType[P]>
        }
      >
    >


  export type user_goalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["user_goal"]>

  export type user_goalSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
  }

  export type user_goalInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type user_goalGetPayload<S extends boolean | null | undefined | user_goalArgs> = $Types.GetResult<user_goalPayload, S>

  type user_goalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_goalFindManyArgs, 'select' | 'include'> & {
      select?: User_goalCountAggregateInputType | true
    }

  export interface user_goalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_goal'], meta: { name: 'user_goal' } }
    /**
     * Find zero or one User_goal that matches the filter.
     * @param {user_goalFindUniqueArgs} args - Arguments to find a User_goal
     * @example
     * // Get one User_goal
     * const user_goal = await prisma.user_goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_goalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_goalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_goal'> extends True ? Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_goal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_goalFindUniqueOrThrowArgs} args - Arguments to find a User_goal
     * @example
     * // Get one User_goal
     * const user_goal = await prisma.user_goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_goalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_goalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_goalFindFirstArgs} args - Arguments to find a User_goal
     * @example
     * // Get one User_goal
     * const user_goal = await prisma.user_goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_goalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_goalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_goal'> extends True ? Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_goal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_goalFindFirstOrThrowArgs} args - Arguments to find a User_goal
     * @example
     * // Get one User_goal
     * const user_goal = await prisma.user_goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_goalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_goalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_goalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_goals
     * const user_goals = await prisma.user_goal.findMany()
     * 
     * // Get first 10 User_goals
     * const user_goals = await prisma.user_goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_goalWithIdOnly = await prisma.user_goal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_goalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_goalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_goal.
     * @param {user_goalCreateArgs} args - Arguments to create a User_goal.
     * @example
     * // Create one User_goal
     * const User_goal = await prisma.user_goal.create({
     *   data: {
     *     // ... data to create a User_goal
     *   }
     * })
     * 
    **/
    create<T extends user_goalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_goalCreateArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_goals.
     *     @param {user_goalCreateManyArgs} args - Arguments to create many User_goals.
     *     @example
     *     // Create many User_goals
     *     const user_goal = await prisma.user_goal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_goalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_goalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_goal.
     * @param {user_goalDeleteArgs} args - Arguments to delete one User_goal.
     * @example
     * // Delete one User_goal
     * const User_goal = await prisma.user_goal.delete({
     *   where: {
     *     // ... filter to delete one User_goal
     *   }
     * })
     * 
    **/
    delete<T extends user_goalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_goalDeleteArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_goal.
     * @param {user_goalUpdateArgs} args - Arguments to update one User_goal.
     * @example
     * // Update one User_goal
     * const user_goal = await prisma.user_goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_goalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_goalUpdateArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_goals.
     * @param {user_goalDeleteManyArgs} args - Arguments to filter User_goals to delete.
     * @example
     * // Delete a few User_goals
     * const { count } = await prisma.user_goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_goalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_goalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_goalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_goals
     * const user_goal = await prisma.user_goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_goalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_goalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_goal.
     * @param {user_goalUpsertArgs} args - Arguments to update or create a User_goal.
     * @example
     * // Update or create a User_goal
     * const user_goal = await prisma.user_goal.upsert({
     *   create: {
     *     // ... data to create a User_goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_goal we want to update
     *   }
     * })
    **/
    upsert<T extends user_goalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_goalUpsertArgs<ExtArgs>>
    ): Prisma__user_goalClient<$Types.GetResult<user_goalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_goalCountArgs} args - Arguments to filter User_goals to count.
     * @example
     * // Count the number of User_goals
     * const count = await prisma.user_goal.count({
     *   where: {
     *     // ... the filter for the User_goals we want to count
     *   }
     * })
    **/
    count<T extends user_goalCountArgs>(
      args?: Subset<T, user_goalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_goalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_goalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_goalAggregateArgs>(args: Subset<T, User_goalAggregateArgs>): Prisma.PrismaPromise<GetUser_goalAggregateType<T>>

    /**
     * Group by User_goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_goalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_goalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_goalGroupByArgs['orderBy'] }
        : { orderBy?: User_goalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_goalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_goalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_goalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_goal base type for findUnique actions
   */
  export type user_goalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter, which user_goal to fetch.
     */
    where: user_goalWhereUniqueInput
  }

  /**
   * user_goal findUnique
   */
  export interface user_goalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_goalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_goal findUniqueOrThrow
   */
  export type user_goalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter, which user_goal to fetch.
     */
    where: user_goalWhereUniqueInput
  }


  /**
   * user_goal base type for findFirst actions
   */
  export type user_goalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter, which user_goal to fetch.
     */
    where?: user_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_goals to fetch.
     */
    orderBy?: Enumerable<user_goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_goals.
     */
    cursor?: user_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_goals.
     */
    distinct?: Enumerable<User_goalScalarFieldEnum>
  }

  /**
   * user_goal findFirst
   */
  export interface user_goalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_goalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_goal findFirstOrThrow
   */
  export type user_goalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter, which user_goal to fetch.
     */
    where?: user_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_goals to fetch.
     */
    orderBy?: Enumerable<user_goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_goals.
     */
    cursor?: user_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_goals.
     */
    distinct?: Enumerable<User_goalScalarFieldEnum>
  }


  /**
   * user_goal findMany
   */
  export type user_goalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter, which user_goals to fetch.
     */
    where?: user_goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_goals to fetch.
     */
    orderBy?: Enumerable<user_goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_goals.
     */
    cursor?: user_goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_goals.
     */
    skip?: number
    distinct?: Enumerable<User_goalScalarFieldEnum>
  }


  /**
   * user_goal create
   */
  export type user_goalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * The data needed to create a user_goal.
     */
    data: XOR<user_goalCreateInput, user_goalUncheckedCreateInput>
  }


  /**
   * user_goal createMany
   */
  export type user_goalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_goals.
     */
    data: Enumerable<user_goalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_goal update
   */
  export type user_goalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * The data needed to update a user_goal.
     */
    data: XOR<user_goalUpdateInput, user_goalUncheckedUpdateInput>
    /**
     * Choose, which user_goal to update.
     */
    where: user_goalWhereUniqueInput
  }


  /**
   * user_goal updateMany
   */
  export type user_goalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_goals.
     */
    data: XOR<user_goalUpdateManyMutationInput, user_goalUncheckedUpdateManyInput>
    /**
     * Filter which user_goals to update
     */
    where?: user_goalWhereInput
  }


  /**
   * user_goal upsert
   */
  export type user_goalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * The filter to search for the user_goal to update in case it exists.
     */
    where: user_goalWhereUniqueInput
    /**
     * In case the user_goal found by the `where` argument doesn't exist, create a new user_goal with this data.
     */
    create: XOR<user_goalCreateInput, user_goalUncheckedCreateInput>
    /**
     * In case the user_goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_goalUpdateInput, user_goalUncheckedUpdateInput>
  }


  /**
   * user_goal delete
   */
  export type user_goalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
    /**
     * Filter which user_goal to delete.
     */
    where: user_goalWhereUniqueInput
  }


  /**
   * user_goal deleteMany
   */
  export type user_goalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_goals to delete
     */
    where?: user_goalWhereInput
  }


  /**
   * user_goal without action
   */
  export type user_goalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_goal
     */
    select?: user_goalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_goalInclude<ExtArgs> | null
  }



  /**
   * Model user_measurement
   */


  export type AggregateUser_measurement = {
    _count: User_measurementCountAggregateOutputType | null
    _avg: User_measurementAvgAggregateOutputType | null
    _sum: User_measurementSumAggregateOutputType | null
    _min: User_measurementMinAggregateOutputType | null
    _max: User_measurementMaxAggregateOutputType | null
  }

  export type User_measurementAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    value: Decimal | null
  }

  export type User_measurementSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    value: Decimal | null
  }

  export type User_measurementMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: Date | null
    type: MeasurementType | null
    value: Decimal | null
  }

  export type User_measurementMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: Date | null
    type: MeasurementType | null
    value: Decimal | null
  }

  export type User_measurementCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    date: number
    type: number
    value: number
    _all: number
  }


  export type User_measurementAvgAggregateInputType = {
    id?: true
    user_id?: true
    value?: true
  }

  export type User_measurementSumAggregateInputType = {
    id?: true
    user_id?: true
    value?: true
  }

  export type User_measurementMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
  }

  export type User_measurementMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
  }

  export type User_measurementCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    type?: true
    value?: true
    _all?: true
  }

  export type User_measurementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_measurement to aggregate.
     */
    where?: user_measurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_measurements to fetch.
     */
    orderBy?: Enumerable<user_measurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_measurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_measurements
    **/
    _count?: true | User_measurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_measurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_measurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_measurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_measurementMaxAggregateInputType
  }

  export type GetUser_measurementAggregateType<T extends User_measurementAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_measurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_measurement[P]>
      : GetScalarType<T[P], AggregateUser_measurement[P]>
  }




  export type User_measurementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_measurementWhereInput
    orderBy?: Enumerable<user_measurementOrderByWithAggregationInput>
    by: User_measurementScalarFieldEnum[]
    having?: user_measurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_measurementCountAggregateInputType | true
    _avg?: User_measurementAvgAggregateInputType
    _sum?: User_measurementSumAggregateInputType
    _min?: User_measurementMinAggregateInputType
    _max?: User_measurementMaxAggregateInputType
  }


  export type User_measurementGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    date: Date
    type: MeasurementType
    value: Decimal | null
    _count: User_measurementCountAggregateOutputType | null
    _avg: User_measurementAvgAggregateOutputType | null
    _sum: User_measurementSumAggregateOutputType | null
    _min: User_measurementMinAggregateOutputType | null
    _max: User_measurementMaxAggregateOutputType | null
  }

  type GetUser_measurementGroupByPayload<T extends User_measurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_measurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_measurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_measurementGroupByOutputType[P]>
            : GetScalarType<T[P], User_measurementGroupByOutputType[P]>
        }
      >
    >


  export type user_measurementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["user_measurement"]>

  export type user_measurementSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
  }

  export type user_measurementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type user_measurementGetPayload<S extends boolean | null | undefined | user_measurementArgs> = $Types.GetResult<user_measurementPayload, S>

  type user_measurementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_measurementFindManyArgs, 'select' | 'include'> & {
      select?: User_measurementCountAggregateInputType | true
    }

  export interface user_measurementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_measurement'], meta: { name: 'user_measurement' } }
    /**
     * Find zero or one User_measurement that matches the filter.
     * @param {user_measurementFindUniqueArgs} args - Arguments to find a User_measurement
     * @example
     * // Get one User_measurement
     * const user_measurement = await prisma.user_measurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_measurementFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_measurementFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_measurement'> extends True ? Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_measurement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_measurementFindUniqueOrThrowArgs} args - Arguments to find a User_measurement
     * @example
     * // Get one User_measurement
     * const user_measurement = await prisma.user_measurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_measurementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_measurementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_measurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_measurementFindFirstArgs} args - Arguments to find a User_measurement
     * @example
     * // Get one User_measurement
     * const user_measurement = await prisma.user_measurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_measurementFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_measurementFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_measurement'> extends True ? Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_measurement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_measurementFindFirstOrThrowArgs} args - Arguments to find a User_measurement
     * @example
     * // Get one User_measurement
     * const user_measurement = await prisma.user_measurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_measurementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_measurementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_measurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_measurementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_measurements
     * const user_measurements = await prisma.user_measurement.findMany()
     * 
     * // Get first 10 User_measurements
     * const user_measurements = await prisma.user_measurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_measurementWithIdOnly = await prisma.user_measurement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_measurementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_measurementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_measurement.
     * @param {user_measurementCreateArgs} args - Arguments to create a User_measurement.
     * @example
     * // Create one User_measurement
     * const User_measurement = await prisma.user_measurement.create({
     *   data: {
     *     // ... data to create a User_measurement
     *   }
     * })
     * 
    **/
    create<T extends user_measurementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_measurementCreateArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_measurements.
     *     @param {user_measurementCreateManyArgs} args - Arguments to create many User_measurements.
     *     @example
     *     // Create many User_measurements
     *     const user_measurement = await prisma.user_measurement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_measurementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_measurementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_measurement.
     * @param {user_measurementDeleteArgs} args - Arguments to delete one User_measurement.
     * @example
     * // Delete one User_measurement
     * const User_measurement = await prisma.user_measurement.delete({
     *   where: {
     *     // ... filter to delete one User_measurement
     *   }
     * })
     * 
    **/
    delete<T extends user_measurementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_measurementDeleteArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_measurement.
     * @param {user_measurementUpdateArgs} args - Arguments to update one User_measurement.
     * @example
     * // Update one User_measurement
     * const user_measurement = await prisma.user_measurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_measurementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_measurementUpdateArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_measurements.
     * @param {user_measurementDeleteManyArgs} args - Arguments to filter User_measurements to delete.
     * @example
     * // Delete a few User_measurements
     * const { count } = await prisma.user_measurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_measurementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_measurementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_measurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_measurements
     * const user_measurement = await prisma.user_measurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_measurementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_measurementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_measurement.
     * @param {user_measurementUpsertArgs} args - Arguments to update or create a User_measurement.
     * @example
     * // Update or create a User_measurement
     * const user_measurement = await prisma.user_measurement.upsert({
     *   create: {
     *     // ... data to create a User_measurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_measurement we want to update
     *   }
     * })
    **/
    upsert<T extends user_measurementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_measurementUpsertArgs<ExtArgs>>
    ): Prisma__user_measurementClient<$Types.GetResult<user_measurementPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_measurementCountArgs} args - Arguments to filter User_measurements to count.
     * @example
     * // Count the number of User_measurements
     * const count = await prisma.user_measurement.count({
     *   where: {
     *     // ... the filter for the User_measurements we want to count
     *   }
     * })
    **/
    count<T extends user_measurementCountArgs>(
      args?: Subset<T, user_measurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_measurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_measurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_measurementAggregateArgs>(args: Subset<T, User_measurementAggregateArgs>): Prisma.PrismaPromise<GetUser_measurementAggregateType<T>>

    /**
     * Group by User_measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_measurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_measurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_measurementGroupByArgs['orderBy'] }
        : { orderBy?: User_measurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_measurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_measurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_measurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_measurementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_measurement base type for findUnique actions
   */
  export type user_measurementFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter, which user_measurement to fetch.
     */
    where: user_measurementWhereUniqueInput
  }

  /**
   * user_measurement findUnique
   */
  export interface user_measurementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_measurementFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_measurement findUniqueOrThrow
   */
  export type user_measurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter, which user_measurement to fetch.
     */
    where: user_measurementWhereUniqueInput
  }


  /**
   * user_measurement base type for findFirst actions
   */
  export type user_measurementFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter, which user_measurement to fetch.
     */
    where?: user_measurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_measurements to fetch.
     */
    orderBy?: Enumerable<user_measurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_measurements.
     */
    cursor?: user_measurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_measurements.
     */
    distinct?: Enumerable<User_measurementScalarFieldEnum>
  }

  /**
   * user_measurement findFirst
   */
  export interface user_measurementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_measurementFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_measurement findFirstOrThrow
   */
  export type user_measurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter, which user_measurement to fetch.
     */
    where?: user_measurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_measurements to fetch.
     */
    orderBy?: Enumerable<user_measurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_measurements.
     */
    cursor?: user_measurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_measurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_measurements.
     */
    distinct?: Enumerable<User_measurementScalarFieldEnum>
  }


  /**
   * user_measurement findMany
   */
  export type user_measurementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter, which user_measurements to fetch.
     */
    where?: user_measurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_measurements to fetch.
     */
    orderBy?: Enumerable<user_measurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_measurements.
     */
    cursor?: user_measurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_measurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_measurements.
     */
    skip?: number
    distinct?: Enumerable<User_measurementScalarFieldEnum>
  }


  /**
   * user_measurement create
   */
  export type user_measurementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * The data needed to create a user_measurement.
     */
    data: XOR<user_measurementCreateInput, user_measurementUncheckedCreateInput>
  }


  /**
   * user_measurement createMany
   */
  export type user_measurementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_measurements.
     */
    data: Enumerable<user_measurementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_measurement update
   */
  export type user_measurementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * The data needed to update a user_measurement.
     */
    data: XOR<user_measurementUpdateInput, user_measurementUncheckedUpdateInput>
    /**
     * Choose, which user_measurement to update.
     */
    where: user_measurementWhereUniqueInput
  }


  /**
   * user_measurement updateMany
   */
  export type user_measurementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_measurements.
     */
    data: XOR<user_measurementUpdateManyMutationInput, user_measurementUncheckedUpdateManyInput>
    /**
     * Filter which user_measurements to update
     */
    where?: user_measurementWhereInput
  }


  /**
   * user_measurement upsert
   */
  export type user_measurementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * The filter to search for the user_measurement to update in case it exists.
     */
    where: user_measurementWhereUniqueInput
    /**
     * In case the user_measurement found by the `where` argument doesn't exist, create a new user_measurement with this data.
     */
    create: XOR<user_measurementCreateInput, user_measurementUncheckedCreateInput>
    /**
     * In case the user_measurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_measurementUpdateInput, user_measurementUncheckedUpdateInput>
  }


  /**
   * user_measurement delete
   */
  export type user_measurementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
    /**
     * Filter which user_measurement to delete.
     */
    where: user_measurementWhereUniqueInput
  }


  /**
   * user_measurement deleteMany
   */
  export type user_measurementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_measurements to delete
     */
    where?: user_measurementWhereInput
  }


  /**
   * user_measurement without action
   */
  export type user_measurementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_measurement
     */
    select?: user_measurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_measurementInclude<ExtArgs> | null
  }



  /**
   * Model user_withings
   */


  export type AggregateUser_withings = {
    _count: User_withingsCountAggregateOutputType | null
    _avg: User_withingsAvgAggregateOutputType | null
    _sum: User_withingsSumAggregateOutputType | null
    _min: User_withingsMinAggregateOutputType | null
    _max: User_withingsMaxAggregateOutputType | null
  }

  export type User_withingsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_withingsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_withingsMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    withings_userid: string | null
    access_token: string | null
    refresh_token: string | null
  }

  export type User_withingsMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    withings_userid: string | null
    access_token: string | null
    refresh_token: string | null
  }

  export type User_withingsCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    withings_userid: number
    access_token: number
    refresh_token: number
    _all: number
  }


  export type User_withingsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_withingsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_withingsMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    withings_userid?: true
    access_token?: true
    refresh_token?: true
  }

  export type User_withingsMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    withings_userid?: true
    access_token?: true
    refresh_token?: true
  }

  export type User_withingsCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    withings_userid?: true
    access_token?: true
    refresh_token?: true
    _all?: true
  }

  export type User_withingsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_withings to aggregate.
     */
    where?: user_withingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_withings to fetch.
     */
    orderBy?: Enumerable<user_withingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_withingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_withings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_withings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_withings
    **/
    _count?: true | User_withingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_withingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_withingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_withingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_withingsMaxAggregateInputType
  }

  export type GetUser_withingsAggregateType<T extends User_withingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_withings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_withings[P]>
      : GetScalarType<T[P], AggregateUser_withings[P]>
  }




  export type User_withingsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_withingsWhereInput
    orderBy?: Enumerable<user_withingsOrderByWithAggregationInput>
    by: User_withingsScalarFieldEnum[]
    having?: user_withingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_withingsCountAggregateInputType | true
    _avg?: User_withingsAvgAggregateInputType
    _sum?: User_withingsSumAggregateInputType
    _min?: User_withingsMinAggregateInputType
    _max?: User_withingsMaxAggregateInputType
  }


  export type User_withingsGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    withings_userid: string
    access_token: string
    refresh_token: string
    _count: User_withingsCountAggregateOutputType | null
    _avg: User_withingsAvgAggregateOutputType | null
    _sum: User_withingsSumAggregateOutputType | null
    _min: User_withingsMinAggregateOutputType | null
    _max: User_withingsMaxAggregateOutputType | null
  }

  type GetUser_withingsGroupByPayload<T extends User_withingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_withingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_withingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_withingsGroupByOutputType[P]>
            : GetScalarType<T[P], User_withingsGroupByOutputType[P]>
        }
      >
    >


  export type user_withingsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    withings_userid?: boolean
    access_token?: boolean
    refresh_token?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["user_withings"]>

  export type user_withingsSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    withings_userid?: boolean
    access_token?: boolean
    refresh_token?: boolean
  }

  export type user_withingsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type user_withingsGetPayload<S extends boolean | null | undefined | user_withingsArgs> = $Types.GetResult<user_withingsPayload, S>

  type user_withingsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_withingsFindManyArgs, 'select' | 'include'> & {
      select?: User_withingsCountAggregateInputType | true
    }

  export interface user_withingsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_withings'], meta: { name: 'user_withings' } }
    /**
     * Find zero or one User_withings that matches the filter.
     * @param {user_withingsFindUniqueArgs} args - Arguments to find a User_withings
     * @example
     * // Get one User_withings
     * const user_withings = await prisma.user_withings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_withingsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_withingsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_withings'> extends True ? Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_withings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_withingsFindUniqueOrThrowArgs} args - Arguments to find a User_withings
     * @example
     * // Get one User_withings
     * const user_withings = await prisma.user_withings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_withingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_withingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_withings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_withingsFindFirstArgs} args - Arguments to find a User_withings
     * @example
     * // Get one User_withings
     * const user_withings = await prisma.user_withings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_withingsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_withingsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_withings'> extends True ? Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_withings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_withingsFindFirstOrThrowArgs} args - Arguments to find a User_withings
     * @example
     * // Get one User_withings
     * const user_withings = await prisma.user_withings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_withingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_withingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_withings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_withingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_withings
     * const user_withings = await prisma.user_withings.findMany()
     * 
     * // Get first 10 User_withings
     * const user_withings = await prisma.user_withings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_withingsWithIdOnly = await prisma.user_withings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_withingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_withingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_withings.
     * @param {user_withingsCreateArgs} args - Arguments to create a User_withings.
     * @example
     * // Create one User_withings
     * const User_withings = await prisma.user_withings.create({
     *   data: {
     *     // ... data to create a User_withings
     *   }
     * })
     * 
    **/
    create<T extends user_withingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_withingsCreateArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_withings.
     *     @param {user_withingsCreateManyArgs} args - Arguments to create many User_withings.
     *     @example
     *     // Create many User_withings
     *     const user_withings = await prisma.user_withings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_withingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_withingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_withings.
     * @param {user_withingsDeleteArgs} args - Arguments to delete one User_withings.
     * @example
     * // Delete one User_withings
     * const User_withings = await prisma.user_withings.delete({
     *   where: {
     *     // ... filter to delete one User_withings
     *   }
     * })
     * 
    **/
    delete<T extends user_withingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_withingsDeleteArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_withings.
     * @param {user_withingsUpdateArgs} args - Arguments to update one User_withings.
     * @example
     * // Update one User_withings
     * const user_withings = await prisma.user_withings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_withingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_withingsUpdateArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_withings.
     * @param {user_withingsDeleteManyArgs} args - Arguments to filter User_withings to delete.
     * @example
     * // Delete a few User_withings
     * const { count } = await prisma.user_withings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_withingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_withingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_withings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_withingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_withings
     * const user_withings = await prisma.user_withings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_withingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_withingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_withings.
     * @param {user_withingsUpsertArgs} args - Arguments to update or create a User_withings.
     * @example
     * // Update or create a User_withings
     * const user_withings = await prisma.user_withings.upsert({
     *   create: {
     *     // ... data to create a User_withings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_withings we want to update
     *   }
     * })
    **/
    upsert<T extends user_withingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_withingsUpsertArgs<ExtArgs>>
    ): Prisma__user_withingsClient<$Types.GetResult<user_withingsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_withings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_withingsCountArgs} args - Arguments to filter User_withings to count.
     * @example
     * // Count the number of User_withings
     * const count = await prisma.user_withings.count({
     *   where: {
     *     // ... the filter for the User_withings we want to count
     *   }
     * })
    **/
    count<T extends user_withingsCountArgs>(
      args?: Subset<T, user_withingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_withingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_withings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_withingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_withingsAggregateArgs>(args: Subset<T, User_withingsAggregateArgs>): Prisma.PrismaPromise<GetUser_withingsAggregateType<T>>

    /**
     * Group by User_withings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_withingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_withingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_withingsGroupByArgs['orderBy'] }
        : { orderBy?: User_withingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_withingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_withingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_withings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_withingsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_withings base type for findUnique actions
   */
  export type user_withingsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter, which user_withings to fetch.
     */
    where: user_withingsWhereUniqueInput
  }

  /**
   * user_withings findUnique
   */
  export interface user_withingsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_withingsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_withings findUniqueOrThrow
   */
  export type user_withingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter, which user_withings to fetch.
     */
    where: user_withingsWhereUniqueInput
  }


  /**
   * user_withings base type for findFirst actions
   */
  export type user_withingsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter, which user_withings to fetch.
     */
    where?: user_withingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_withings to fetch.
     */
    orderBy?: Enumerable<user_withingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_withings.
     */
    cursor?: user_withingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_withings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_withings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_withings.
     */
    distinct?: Enumerable<User_withingsScalarFieldEnum>
  }

  /**
   * user_withings findFirst
   */
  export interface user_withingsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_withingsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_withings findFirstOrThrow
   */
  export type user_withingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter, which user_withings to fetch.
     */
    where?: user_withingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_withings to fetch.
     */
    orderBy?: Enumerable<user_withingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_withings.
     */
    cursor?: user_withingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_withings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_withings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_withings.
     */
    distinct?: Enumerable<User_withingsScalarFieldEnum>
  }


  /**
   * user_withings findMany
   */
  export type user_withingsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter, which user_withings to fetch.
     */
    where?: user_withingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_withings to fetch.
     */
    orderBy?: Enumerable<user_withingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_withings.
     */
    cursor?: user_withingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_withings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_withings.
     */
    skip?: number
    distinct?: Enumerable<User_withingsScalarFieldEnum>
  }


  /**
   * user_withings create
   */
  export type user_withingsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_withings.
     */
    data: XOR<user_withingsCreateInput, user_withingsUncheckedCreateInput>
  }


  /**
   * user_withings createMany
   */
  export type user_withingsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_withings.
     */
    data: Enumerable<user_withingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_withings update
   */
  export type user_withingsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_withings.
     */
    data: XOR<user_withingsUpdateInput, user_withingsUncheckedUpdateInput>
    /**
     * Choose, which user_withings to update.
     */
    where: user_withingsWhereUniqueInput
  }


  /**
   * user_withings updateMany
   */
  export type user_withingsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_withings.
     */
    data: XOR<user_withingsUpdateManyMutationInput, user_withingsUncheckedUpdateManyInput>
    /**
     * Filter which user_withings to update
     */
    where?: user_withingsWhereInput
  }


  /**
   * user_withings upsert
   */
  export type user_withingsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_withings to update in case it exists.
     */
    where: user_withingsWhereUniqueInput
    /**
     * In case the user_withings found by the `where` argument doesn't exist, create a new user_withings with this data.
     */
    create: XOR<user_withingsCreateInput, user_withingsUncheckedCreateInput>
    /**
     * In case the user_withings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_withingsUpdateInput, user_withingsUncheckedUpdateInput>
  }


  /**
   * user_withings delete
   */
  export type user_withingsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
    /**
     * Filter which user_withings to delete.
     */
    where: user_withingsWhereUniqueInput
  }


  /**
   * user_withings deleteMany
   */
  export type user_withingsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_withings to delete
     */
    where?: user_withingsWhereInput
  }


  /**
   * user_withings without action
   */
  export type user_withingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_withings
     */
    select?: user_withingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_withingsInclude<ExtArgs> | null
  }



  /**
   * Model user_patient
   */


  export type AggregateUser_patient = {
    _count: User_patientCountAggregateOutputType | null
    _avg: User_patientAvgAggregateOutputType | null
    _sum: User_patientSumAggregateOutputType | null
    _min: User_patientMinAggregateOutputType | null
    _max: User_patientMaxAggregateOutputType | null
  }

  export type User_patientAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_patientSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type User_patientMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    protocol_code: string | null
    protocol_inclusion_date: string | null
  }

  export type User_patientMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    protocol_code: string | null
    protocol_inclusion_date: string | null
  }

  export type User_patientCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    protocol_code: number
    protocol_inclusion_date: number
    _all: number
  }


  export type User_patientAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_patientSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type User_patientMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    protocol_code?: true
    protocol_inclusion_date?: true
  }

  export type User_patientMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    protocol_code?: true
    protocol_inclusion_date?: true
  }

  export type User_patientCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    protocol_code?: true
    protocol_inclusion_date?: true
    _all?: true
  }

  export type User_patientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_patient to aggregate.
     */
    where?: user_patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_patients to fetch.
     */
    orderBy?: Enumerable<user_patientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_patients
    **/
    _count?: true | User_patientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_patientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_patientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_patientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_patientMaxAggregateInputType
  }

  export type GetUser_patientAggregateType<T extends User_patientAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_patient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_patient[P]>
      : GetScalarType<T[P], AggregateUser_patient[P]>
  }




  export type User_patientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_patientWhereInput
    orderBy?: Enumerable<user_patientOrderByWithAggregationInput>
    by: User_patientScalarFieldEnum[]
    having?: user_patientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_patientCountAggregateInputType | true
    _avg?: User_patientAvgAggregateInputType
    _sum?: User_patientSumAggregateInputType
    _min?: User_patientMinAggregateInputType
    _max?: User_patientMaxAggregateInputType
  }


  export type User_patientGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    protocol_code: string | null
    protocol_inclusion_date: string | null
    _count: User_patientCountAggregateOutputType | null
    _avg: User_patientAvgAggregateOutputType | null
    _sum: User_patientSumAggregateOutputType | null
    _min: User_patientMinAggregateOutputType | null
    _max: User_patientMaxAggregateOutputType | null
  }

  type GetUser_patientGroupByPayload<T extends User_patientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_patientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_patientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_patientGroupByOutputType[P]>
            : GetScalarType<T[P], User_patientGroupByOutputType[P]>
        }
      >
    >


  export type user_patientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    protocol_code?: boolean
    protocol_inclusion_date?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["user_patient"]>

  export type user_patientSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    protocol_code?: boolean
    protocol_inclusion_date?: boolean
  }

  export type user_patientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type user_patientGetPayload<S extends boolean | null | undefined | user_patientArgs> = $Types.GetResult<user_patientPayload, S>

  type user_patientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_patientFindManyArgs, 'select' | 'include'> & {
      select?: User_patientCountAggregateInputType | true
    }

  export interface user_patientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_patient'], meta: { name: 'user_patient' } }
    /**
     * Find zero or one User_patient that matches the filter.
     * @param {user_patientFindUniqueArgs} args - Arguments to find a User_patient
     * @example
     * // Get one User_patient
     * const user_patient = await prisma.user_patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_patientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_patientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_patient'> extends True ? Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_patient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_patientFindUniqueOrThrowArgs} args - Arguments to find a User_patient
     * @example
     * // Get one User_patient
     * const user_patient = await prisma.user_patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_patientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_patientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_patientFindFirstArgs} args - Arguments to find a User_patient
     * @example
     * // Get one User_patient
     * const user_patient = await prisma.user_patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_patientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_patientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_patient'> extends True ? Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_patient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_patientFindFirstOrThrowArgs} args - Arguments to find a User_patient
     * @example
     * // Get one User_patient
     * const user_patient = await prisma.user_patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_patientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_patientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_patientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_patients
     * const user_patients = await prisma.user_patient.findMany()
     * 
     * // Get first 10 User_patients
     * const user_patients = await prisma.user_patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_patientWithIdOnly = await prisma.user_patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_patientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_patientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_patient.
     * @param {user_patientCreateArgs} args - Arguments to create a User_patient.
     * @example
     * // Create one User_patient
     * const User_patient = await prisma.user_patient.create({
     *   data: {
     *     // ... data to create a User_patient
     *   }
     * })
     * 
    **/
    create<T extends user_patientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_patientCreateArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_patients.
     *     @param {user_patientCreateManyArgs} args - Arguments to create many User_patients.
     *     @example
     *     // Create many User_patients
     *     const user_patient = await prisma.user_patient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_patientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_patientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_patient.
     * @param {user_patientDeleteArgs} args - Arguments to delete one User_patient.
     * @example
     * // Delete one User_patient
     * const User_patient = await prisma.user_patient.delete({
     *   where: {
     *     // ... filter to delete one User_patient
     *   }
     * })
     * 
    **/
    delete<T extends user_patientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_patientDeleteArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_patient.
     * @param {user_patientUpdateArgs} args - Arguments to update one User_patient.
     * @example
     * // Update one User_patient
     * const user_patient = await prisma.user_patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_patientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_patientUpdateArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_patients.
     * @param {user_patientDeleteManyArgs} args - Arguments to filter User_patients to delete.
     * @example
     * // Delete a few User_patients
     * const { count } = await prisma.user_patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_patientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_patientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_patientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_patients
     * const user_patient = await prisma.user_patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_patientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_patientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_patient.
     * @param {user_patientUpsertArgs} args - Arguments to update or create a User_patient.
     * @example
     * // Update or create a User_patient
     * const user_patient = await prisma.user_patient.upsert({
     *   create: {
     *     // ... data to create a User_patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_patient we want to update
     *   }
     * })
    **/
    upsert<T extends user_patientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_patientUpsertArgs<ExtArgs>>
    ): Prisma__user_patientClient<$Types.GetResult<user_patientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_patientCountArgs} args - Arguments to filter User_patients to count.
     * @example
     * // Count the number of User_patients
     * const count = await prisma.user_patient.count({
     *   where: {
     *     // ... the filter for the User_patients we want to count
     *   }
     * })
    **/
    count<T extends user_patientCountArgs>(
      args?: Subset<T, user_patientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_patientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_patientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_patientAggregateArgs>(args: Subset<T, User_patientAggregateArgs>): Prisma.PrismaPromise<GetUser_patientAggregateType<T>>

    /**
     * Group by User_patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_patientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_patientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_patientGroupByArgs['orderBy'] }
        : { orderBy?: User_patientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_patientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_patientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_patientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_patient base type for findUnique actions
   */
  export type user_patientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter, which user_patient to fetch.
     */
    where: user_patientWhereUniqueInput
  }

  /**
   * user_patient findUnique
   */
  export interface user_patientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_patientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_patient findUniqueOrThrow
   */
  export type user_patientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter, which user_patient to fetch.
     */
    where: user_patientWhereUniqueInput
  }


  /**
   * user_patient base type for findFirst actions
   */
  export type user_patientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter, which user_patient to fetch.
     */
    where?: user_patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_patients to fetch.
     */
    orderBy?: Enumerable<user_patientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_patients.
     */
    cursor?: user_patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_patients.
     */
    distinct?: Enumerable<User_patientScalarFieldEnum>
  }

  /**
   * user_patient findFirst
   */
  export interface user_patientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_patientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_patient findFirstOrThrow
   */
  export type user_patientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter, which user_patient to fetch.
     */
    where?: user_patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_patients to fetch.
     */
    orderBy?: Enumerable<user_patientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_patients.
     */
    cursor?: user_patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_patients.
     */
    distinct?: Enumerable<User_patientScalarFieldEnum>
  }


  /**
   * user_patient findMany
   */
  export type user_patientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter, which user_patients to fetch.
     */
    where?: user_patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_patients to fetch.
     */
    orderBy?: Enumerable<user_patientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_patients.
     */
    cursor?: user_patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_patients.
     */
    skip?: number
    distinct?: Enumerable<User_patientScalarFieldEnum>
  }


  /**
   * user_patient create
   */
  export type user_patientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * The data needed to create a user_patient.
     */
    data: XOR<user_patientCreateInput, user_patientUncheckedCreateInput>
  }


  /**
   * user_patient createMany
   */
  export type user_patientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_patients.
     */
    data: Enumerable<user_patientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_patient update
   */
  export type user_patientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * The data needed to update a user_patient.
     */
    data: XOR<user_patientUpdateInput, user_patientUncheckedUpdateInput>
    /**
     * Choose, which user_patient to update.
     */
    where: user_patientWhereUniqueInput
  }


  /**
   * user_patient updateMany
   */
  export type user_patientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_patients.
     */
    data: XOR<user_patientUpdateManyMutationInput, user_patientUncheckedUpdateManyInput>
    /**
     * Filter which user_patients to update
     */
    where?: user_patientWhereInput
  }


  /**
   * user_patient upsert
   */
  export type user_patientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * The filter to search for the user_patient to update in case it exists.
     */
    where: user_patientWhereUniqueInput
    /**
     * In case the user_patient found by the `where` argument doesn't exist, create a new user_patient with this data.
     */
    create: XOR<user_patientCreateInput, user_patientUncheckedCreateInput>
    /**
     * In case the user_patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_patientUpdateInput, user_patientUncheckedUpdateInput>
  }


  /**
   * user_patient delete
   */
  export type user_patientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
    /**
     * Filter which user_patient to delete.
     */
    where: user_patientWhereUniqueInput
  }


  /**
   * user_patient deleteMany
   */
  export type user_patientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_patients to delete
     */
    where?: user_patientWhereInput
  }


  /**
   * user_patient without action
   */
  export type user_patientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_patient
     */
    select?: user_patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_patientInclude<ExtArgs> | null
  }



  /**
   * Model fractioning
   */


  export type AggregateFractioning = {
    _count: FractioningCountAggregateOutputType | null
    _avg: FractioningAvgAggregateOutputType | null
    _sum: FractioningSumAggregateOutputType | null
    _min: FractioningMinAggregateOutputType | null
    _max: FractioningMaxAggregateOutputType | null
  }

  export type FractioningAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type FractioningSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type FractioningMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: string | null
    meal_types: string | null
  }

  export type FractioningMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: string | null
    meal_types: string | null
  }

  export type FractioningCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    date: number
    meal_types: number
    _all: number
  }


  export type FractioningAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type FractioningSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type FractioningMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    meal_types?: true
  }

  export type FractioningMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    meal_types?: true
  }

  export type FractioningCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    meal_types?: true
    _all?: true
  }

  export type FractioningAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fractioning to aggregate.
     */
    where?: fractioningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fractionings to fetch.
     */
    orderBy?: Enumerable<fractioningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fractioningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fractionings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fractionings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fractionings
    **/
    _count?: true | FractioningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FractioningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FractioningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FractioningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FractioningMaxAggregateInputType
  }

  export type GetFractioningAggregateType<T extends FractioningAggregateArgs> = {
        [P in keyof T & keyof AggregateFractioning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFractioning[P]>
      : GetScalarType<T[P], AggregateFractioning[P]>
  }




  export type FractioningGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: fractioningWhereInput
    orderBy?: Enumerable<fractioningOrderByWithAggregationInput>
    by: FractioningScalarFieldEnum[]
    having?: fractioningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FractioningCountAggregateInputType | true
    _avg?: FractioningAvgAggregateInputType
    _sum?: FractioningSumAggregateInputType
    _min?: FractioningMinAggregateInputType
    _max?: FractioningMaxAggregateInputType
  }


  export type FractioningGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    date: string | null
    meal_types: string | null
    _count: FractioningCountAggregateOutputType | null
    _avg: FractioningAvgAggregateOutputType | null
    _sum: FractioningSumAggregateOutputType | null
    _min: FractioningMinAggregateOutputType | null
    _max: FractioningMaxAggregateOutputType | null
  }

  type GetFractioningGroupByPayload<T extends FractioningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FractioningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FractioningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FractioningGroupByOutputType[P]>
            : GetScalarType<T[P], FractioningGroupByOutputType[P]>
        }
      >
    >


  export type fractioningSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    meal_types?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["fractioning"]>

  export type fractioningSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    meal_types?: boolean
  }

  export type fractioningInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type fractioningGetPayload<S extends boolean | null | undefined | fractioningArgs> = $Types.GetResult<fractioningPayload, S>

  type fractioningCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<fractioningFindManyArgs, 'select' | 'include'> & {
      select?: FractioningCountAggregateInputType | true
    }

  export interface fractioningDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fractioning'], meta: { name: 'fractioning' } }
    /**
     * Find zero or one Fractioning that matches the filter.
     * @param {fractioningFindUniqueArgs} args - Arguments to find a Fractioning
     * @example
     * // Get one Fractioning
     * const fractioning = await prisma.fractioning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fractioningFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fractioningFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fractioning'> extends True ? Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Fractioning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fractioningFindUniqueOrThrowArgs} args - Arguments to find a Fractioning
     * @example
     * // Get one Fractioning
     * const fractioning = await prisma.fractioning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fractioningFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fractioningFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Fractioning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fractioningFindFirstArgs} args - Arguments to find a Fractioning
     * @example
     * // Get one Fractioning
     * const fractioning = await prisma.fractioning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fractioningFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fractioningFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fractioning'> extends True ? Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Fractioning that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fractioningFindFirstOrThrowArgs} args - Arguments to find a Fractioning
     * @example
     * // Get one Fractioning
     * const fractioning = await prisma.fractioning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fractioningFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, fractioningFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Fractionings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fractioningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fractionings
     * const fractionings = await prisma.fractioning.findMany()
     * 
     * // Get first 10 Fractionings
     * const fractionings = await prisma.fractioning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fractioningWithIdOnly = await prisma.fractioning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fractioningFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fractioningFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Fractioning.
     * @param {fractioningCreateArgs} args - Arguments to create a Fractioning.
     * @example
     * // Create one Fractioning
     * const Fractioning = await prisma.fractioning.create({
     *   data: {
     *     // ... data to create a Fractioning
     *   }
     * })
     * 
    **/
    create<T extends fractioningCreateArgs<ExtArgs>>(
      args: SelectSubset<T, fractioningCreateArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Fractionings.
     *     @param {fractioningCreateManyArgs} args - Arguments to create many Fractionings.
     *     @example
     *     // Create many Fractionings
     *     const fractioning = await prisma.fractioning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fractioningCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fractioningCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fractioning.
     * @param {fractioningDeleteArgs} args - Arguments to delete one Fractioning.
     * @example
     * // Delete one Fractioning
     * const Fractioning = await prisma.fractioning.delete({
     *   where: {
     *     // ... filter to delete one Fractioning
     *   }
     * })
     * 
    **/
    delete<T extends fractioningDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, fractioningDeleteArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Fractioning.
     * @param {fractioningUpdateArgs} args - Arguments to update one Fractioning.
     * @example
     * // Update one Fractioning
     * const fractioning = await prisma.fractioning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fractioningUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, fractioningUpdateArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Fractionings.
     * @param {fractioningDeleteManyArgs} args - Arguments to filter Fractionings to delete.
     * @example
     * // Delete a few Fractionings
     * const { count } = await prisma.fractioning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fractioningDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, fractioningDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fractionings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fractioningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fractionings
     * const fractioning = await prisma.fractioning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fractioningUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, fractioningUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fractioning.
     * @param {fractioningUpsertArgs} args - Arguments to update or create a Fractioning.
     * @example
     * // Update or create a Fractioning
     * const fractioning = await prisma.fractioning.upsert({
     *   create: {
     *     // ... data to create a Fractioning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fractioning we want to update
     *   }
     * })
    **/
    upsert<T extends fractioningUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, fractioningUpsertArgs<ExtArgs>>
    ): Prisma__fractioningClient<$Types.GetResult<fractioningPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Fractionings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fractioningCountArgs} args - Arguments to filter Fractionings to count.
     * @example
     * // Count the number of Fractionings
     * const count = await prisma.fractioning.count({
     *   where: {
     *     // ... the filter for the Fractionings we want to count
     *   }
     * })
    **/
    count<T extends fractioningCountArgs>(
      args?: Subset<T, fractioningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FractioningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fractioning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractioningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FractioningAggregateArgs>(args: Subset<T, FractioningAggregateArgs>): Prisma.PrismaPromise<GetFractioningAggregateType<T>>

    /**
     * Group by Fractioning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FractioningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FractioningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FractioningGroupByArgs['orderBy'] }
        : { orderBy?: FractioningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FractioningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFractioningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fractioning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fractioningClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fractioning base type for findUnique actions
   */
  export type fractioningFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter, which fractioning to fetch.
     */
    where: fractioningWhereUniqueInput
  }

  /**
   * fractioning findUnique
   */
  export interface fractioningFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fractioningFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fractioning findUniqueOrThrow
   */
  export type fractioningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter, which fractioning to fetch.
     */
    where: fractioningWhereUniqueInput
  }


  /**
   * fractioning base type for findFirst actions
   */
  export type fractioningFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter, which fractioning to fetch.
     */
    where?: fractioningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fractionings to fetch.
     */
    orderBy?: Enumerable<fractioningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fractionings.
     */
    cursor?: fractioningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fractionings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fractionings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fractionings.
     */
    distinct?: Enumerable<FractioningScalarFieldEnum>
  }

  /**
   * fractioning findFirst
   */
  export interface fractioningFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends fractioningFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fractioning findFirstOrThrow
   */
  export type fractioningFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter, which fractioning to fetch.
     */
    where?: fractioningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fractionings to fetch.
     */
    orderBy?: Enumerable<fractioningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fractionings.
     */
    cursor?: fractioningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fractionings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fractionings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fractionings.
     */
    distinct?: Enumerable<FractioningScalarFieldEnum>
  }


  /**
   * fractioning findMany
   */
  export type fractioningFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter, which fractionings to fetch.
     */
    where?: fractioningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fractionings to fetch.
     */
    orderBy?: Enumerable<fractioningOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fractionings.
     */
    cursor?: fractioningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fractionings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fractionings.
     */
    skip?: number
    distinct?: Enumerable<FractioningScalarFieldEnum>
  }


  /**
   * fractioning create
   */
  export type fractioningCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * The data needed to create a fractioning.
     */
    data: XOR<fractioningCreateInput, fractioningUncheckedCreateInput>
  }


  /**
   * fractioning createMany
   */
  export type fractioningCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fractionings.
     */
    data: Enumerable<fractioningCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fractioning update
   */
  export type fractioningUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * The data needed to update a fractioning.
     */
    data: XOR<fractioningUpdateInput, fractioningUncheckedUpdateInput>
    /**
     * Choose, which fractioning to update.
     */
    where: fractioningWhereUniqueInput
  }


  /**
   * fractioning updateMany
   */
  export type fractioningUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fractionings.
     */
    data: XOR<fractioningUpdateManyMutationInput, fractioningUncheckedUpdateManyInput>
    /**
     * Filter which fractionings to update
     */
    where?: fractioningWhereInput
  }


  /**
   * fractioning upsert
   */
  export type fractioningUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * The filter to search for the fractioning to update in case it exists.
     */
    where: fractioningWhereUniqueInput
    /**
     * In case the fractioning found by the `where` argument doesn't exist, create a new fractioning with this data.
     */
    create: XOR<fractioningCreateInput, fractioningUncheckedCreateInput>
    /**
     * In case the fractioning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fractioningUpdateInput, fractioningUncheckedUpdateInput>
  }


  /**
   * fractioning delete
   */
  export type fractioningDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
    /**
     * Filter which fractioning to delete.
     */
    where: fractioningWhereUniqueInput
  }


  /**
   * fractioning deleteMany
   */
  export type fractioningDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which fractionings to delete
     */
    where?: fractioningWhereInput
  }


  /**
   * fractioning without action
   */
  export type fractioningArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fractioning
     */
    select?: fractioningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fractioningInclude<ExtArgs> | null
  }



  /**
   * Model meal_element
   */


  export type AggregateMeal_element = {
    _count: Meal_elementCountAggregateOutputType | null
    _avg: Meal_elementAvgAggregateOutputType | null
    _sum: Meal_elementSumAggregateOutputType | null
    _min: Meal_elementMinAggregateOutputType | null
    _max: Meal_elementMaxAggregateOutputType | null
  }

  export type Meal_elementAvgAggregateOutputType = {
    id: number | null
    meal_id: number | null
    food_id: number | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type Meal_elementSumAggregateOutputType = {
    id: number | null
    meal_id: number | null
    food_id: number | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type Meal_elementMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    meal_id: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type Meal_elementMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    meal_id: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type Meal_elementCountAggregateOutputType = {
    id: number
    created_at: number
    meal_id: number
    food_id: number
    weight: number
    portion_id: number
    portion_cnt: number
    _all: number
  }


  export type Meal_elementAvgAggregateInputType = {
    id?: true
    meal_id?: true
    food_id?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type Meal_elementSumAggregateInputType = {
    id?: true
    meal_id?: true
    food_id?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type Meal_elementMinAggregateInputType = {
    id?: true
    created_at?: true
    meal_id?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type Meal_elementMaxAggregateInputType = {
    id?: true
    created_at?: true
    meal_id?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type Meal_elementCountAggregateInputType = {
    id?: true
    created_at?: true
    meal_id?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
    _all?: true
  }

  export type Meal_elementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which meal_element to aggregate.
     */
    where?: meal_elementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meal_elements to fetch.
     */
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meal_elementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meal_elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meal_elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meal_elements
    **/
    _count?: true | Meal_elementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Meal_elementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Meal_elementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Meal_elementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Meal_elementMaxAggregateInputType
  }

  export type GetMeal_elementAggregateType<T extends Meal_elementAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal_element]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal_element[P]>
      : GetScalarType<T[P], AggregateMeal_element[P]>
  }




  export type Meal_elementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: meal_elementWhereInput
    orderBy?: Enumerable<meal_elementOrderByWithAggregationInput>
    by: Meal_elementScalarFieldEnum[]
    having?: meal_elementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Meal_elementCountAggregateInputType | true
    _avg?: Meal_elementAvgAggregateInputType
    _sum?: Meal_elementSumAggregateInputType
    _min?: Meal_elementMinAggregateInputType
    _max?: Meal_elementMaxAggregateInputType
  }


  export type Meal_elementGroupByOutputType = {
    id: number
    created_at: Date | null
    meal_id: number
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
    _count: Meal_elementCountAggregateOutputType | null
    _avg: Meal_elementAvgAggregateOutputType | null
    _sum: Meal_elementSumAggregateOutputType | null
    _min: Meal_elementMinAggregateOutputType | null
    _max: Meal_elementMaxAggregateOutputType | null
  }

  type GetMeal_elementGroupByPayload<T extends Meal_elementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Meal_elementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Meal_elementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Meal_elementGroupByOutputType[P]>
            : GetScalarType<T[P], Meal_elementGroupByOutputType[P]>
        }
      >
    >


  export type meal_elementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    meal_id?: boolean
    food_id?: boolean
    weight?: boolean
    portion_id?: boolean
    portion_cnt?: boolean
    food?: boolean | foodArgs<ExtArgs>
    meal?: boolean | mealArgs<ExtArgs>
    foodPortion?: boolean | food_portionArgs<ExtArgs>
  }, ExtArgs["result"]["meal_element"]>

  export type meal_elementSelectScalar = {
    id?: boolean
    created_at?: boolean
    meal_id?: boolean
    food_id?: boolean
    weight?: boolean
    portion_id?: boolean
    portion_cnt?: boolean
  }

  export type meal_elementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food?: boolean | foodArgs<ExtArgs>
    meal?: boolean | mealArgs<ExtArgs>
    foodPortion?: boolean | food_portionArgs<ExtArgs>
  }


  type meal_elementGetPayload<S extends boolean | null | undefined | meal_elementArgs> = $Types.GetResult<meal_elementPayload, S>

  type meal_elementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<meal_elementFindManyArgs, 'select' | 'include'> & {
      select?: Meal_elementCountAggregateInputType | true
    }

  export interface meal_elementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meal_element'], meta: { name: 'meal_element' } }
    /**
     * Find zero or one Meal_element that matches the filter.
     * @param {meal_elementFindUniqueArgs} args - Arguments to find a Meal_element
     * @example
     * // Get one Meal_element
     * const meal_element = await prisma.meal_element.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends meal_elementFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, meal_elementFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'meal_element'> extends True ? Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Meal_element that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {meal_elementFindUniqueOrThrowArgs} args - Arguments to find a Meal_element
     * @example
     * // Get one Meal_element
     * const meal_element = await prisma.meal_element.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends meal_elementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, meal_elementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Meal_element that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meal_elementFindFirstArgs} args - Arguments to find a Meal_element
     * @example
     * // Get one Meal_element
     * const meal_element = await prisma.meal_element.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends meal_elementFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, meal_elementFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'meal_element'> extends True ? Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Meal_element that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meal_elementFindFirstOrThrowArgs} args - Arguments to find a Meal_element
     * @example
     * // Get one Meal_element
     * const meal_element = await prisma.meal_element.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends meal_elementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, meal_elementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Meal_elements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meal_elementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meal_elements
     * const meal_elements = await prisma.meal_element.findMany()
     * 
     * // Get first 10 Meal_elements
     * const meal_elements = await prisma.meal_element.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meal_elementWithIdOnly = await prisma.meal_element.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends meal_elementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meal_elementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Meal_element.
     * @param {meal_elementCreateArgs} args - Arguments to create a Meal_element.
     * @example
     * // Create one Meal_element
     * const Meal_element = await prisma.meal_element.create({
     *   data: {
     *     // ... data to create a Meal_element
     *   }
     * })
     * 
    **/
    create<T extends meal_elementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, meal_elementCreateArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Meal_elements.
     *     @param {meal_elementCreateManyArgs} args - Arguments to create many Meal_elements.
     *     @example
     *     // Create many Meal_elements
     *     const meal_element = await prisma.meal_element.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends meal_elementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meal_elementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meal_element.
     * @param {meal_elementDeleteArgs} args - Arguments to delete one Meal_element.
     * @example
     * // Delete one Meal_element
     * const Meal_element = await prisma.meal_element.delete({
     *   where: {
     *     // ... filter to delete one Meal_element
     *   }
     * })
     * 
    **/
    delete<T extends meal_elementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, meal_elementDeleteArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Meal_element.
     * @param {meal_elementUpdateArgs} args - Arguments to update one Meal_element.
     * @example
     * // Update one Meal_element
     * const meal_element = await prisma.meal_element.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends meal_elementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, meal_elementUpdateArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Meal_elements.
     * @param {meal_elementDeleteManyArgs} args - Arguments to filter Meal_elements to delete.
     * @example
     * // Delete a few Meal_elements
     * const { count } = await prisma.meal_element.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends meal_elementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, meal_elementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meal_elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meal_elementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meal_elements
     * const meal_element = await prisma.meal_element.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends meal_elementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, meal_elementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meal_element.
     * @param {meal_elementUpsertArgs} args - Arguments to update or create a Meal_element.
     * @example
     * // Update or create a Meal_element
     * const meal_element = await prisma.meal_element.upsert({
     *   create: {
     *     // ... data to create a Meal_element
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal_element we want to update
     *   }
     * })
    **/
    upsert<T extends meal_elementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, meal_elementUpsertArgs<ExtArgs>>
    ): Prisma__meal_elementClient<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Meal_elements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meal_elementCountArgs} args - Arguments to filter Meal_elements to count.
     * @example
     * // Count the number of Meal_elements
     * const count = await prisma.meal_element.count({
     *   where: {
     *     // ... the filter for the Meal_elements we want to count
     *   }
     * })
    **/
    count<T extends meal_elementCountArgs>(
      args?: Subset<T, meal_elementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Meal_elementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal_element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meal_elementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Meal_elementAggregateArgs>(args: Subset<T, Meal_elementAggregateArgs>): Prisma.PrismaPromise<GetMeal_elementAggregateType<T>>

    /**
     * Group by Meal_element.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Meal_elementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Meal_elementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Meal_elementGroupByArgs['orderBy'] }
        : { orderBy?: Meal_elementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Meal_elementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeal_elementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for meal_element.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__meal_elementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food<T extends foodArgs<ExtArgs> = {}>(args?: Subset<T, foodArgs<ExtArgs>>): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    meal<T extends mealArgs<ExtArgs> = {}>(args?: Subset<T, mealArgs<ExtArgs>>): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    foodPortion<T extends food_portionArgs<ExtArgs> = {}>(args?: Subset<T, food_portionArgs<ExtArgs>>): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * meal_element base type for findUnique actions
   */
  export type meal_elementFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter, which meal_element to fetch.
     */
    where: meal_elementWhereUniqueInput
  }

  /**
   * meal_element findUnique
   */
  export interface meal_elementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends meal_elementFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * meal_element findUniqueOrThrow
   */
  export type meal_elementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter, which meal_element to fetch.
     */
    where: meal_elementWhereUniqueInput
  }


  /**
   * meal_element base type for findFirst actions
   */
  export type meal_elementFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter, which meal_element to fetch.
     */
    where?: meal_elementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meal_elements to fetch.
     */
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meal_elements.
     */
    cursor?: meal_elementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meal_elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meal_elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meal_elements.
     */
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }

  /**
   * meal_element findFirst
   */
  export interface meal_elementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends meal_elementFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * meal_element findFirstOrThrow
   */
  export type meal_elementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter, which meal_element to fetch.
     */
    where?: meal_elementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meal_elements to fetch.
     */
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meal_elements.
     */
    cursor?: meal_elementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meal_elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meal_elements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meal_elements.
     */
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }


  /**
   * meal_element findMany
   */
  export type meal_elementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter, which meal_elements to fetch.
     */
    where?: meal_elementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meal_elements to fetch.
     */
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meal_elements.
     */
    cursor?: meal_elementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meal_elements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meal_elements.
     */
    skip?: number
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }


  /**
   * meal_element create
   */
  export type meal_elementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * The data needed to create a meal_element.
     */
    data: XOR<meal_elementCreateInput, meal_elementUncheckedCreateInput>
  }


  /**
   * meal_element createMany
   */
  export type meal_elementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meal_elements.
     */
    data: Enumerable<meal_elementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * meal_element update
   */
  export type meal_elementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * The data needed to update a meal_element.
     */
    data: XOR<meal_elementUpdateInput, meal_elementUncheckedUpdateInput>
    /**
     * Choose, which meal_element to update.
     */
    where: meal_elementWhereUniqueInput
  }


  /**
   * meal_element updateMany
   */
  export type meal_elementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meal_elements.
     */
    data: XOR<meal_elementUpdateManyMutationInput, meal_elementUncheckedUpdateManyInput>
    /**
     * Filter which meal_elements to update
     */
    where?: meal_elementWhereInput
  }


  /**
   * meal_element upsert
   */
  export type meal_elementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * The filter to search for the meal_element to update in case it exists.
     */
    where: meal_elementWhereUniqueInput
    /**
     * In case the meal_element found by the `where` argument doesn't exist, create a new meal_element with this data.
     */
    create: XOR<meal_elementCreateInput, meal_elementUncheckedCreateInput>
    /**
     * In case the meal_element was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meal_elementUpdateInput, meal_elementUncheckedUpdateInput>
  }


  /**
   * meal_element delete
   */
  export type meal_elementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    /**
     * Filter which meal_element to delete.
     */
    where: meal_elementWhereUniqueInput
  }


  /**
   * meal_element deleteMany
   */
  export type meal_elementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which meal_elements to delete
     */
    where?: meal_elementWhereInput
  }


  /**
   * meal_element without action
   */
  export type meal_elementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
  }



  /**
   * Model meal
   */


  export type AggregateMeal = {
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  export type MealAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MealSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type MealMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: string | null
    mealtype: string | null
    really_eaten: boolean | null
  }

  export type MealMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    date: string | null
    mealtype: string | null
    really_eaten: boolean | null
  }

  export type MealCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    date: number
    mealtype: number
    really_eaten: number
    _all: number
  }


  export type MealAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MealSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type MealMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    mealtype?: true
    really_eaten?: true
  }

  export type MealMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    mealtype?: true
    really_eaten?: true
  }

  export type MealCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    date?: true
    mealtype?: true
    really_eaten?: true
    _all?: true
  }

  export type MealAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which meal to aggregate.
     */
    where?: mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meals to fetch.
     */
    orderBy?: Enumerable<mealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meals
    **/
    _count?: true | MealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealMaxAggregateInputType
  }

  export type GetMealAggregateType<T extends MealAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal[P]>
      : GetScalarType<T[P], AggregateMeal[P]>
  }




  export type MealGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: mealWhereInput
    orderBy?: Enumerable<mealOrderByWithAggregationInput>
    by: MealScalarFieldEnum[]
    having?: mealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealCountAggregateInputType | true
    _avg?: MealAvgAggregateInputType
    _sum?: MealSumAggregateInputType
    _min?: MealMinAggregateInputType
    _max?: MealMaxAggregateInputType
  }


  export type MealGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    date: string | null
    mealtype: string | null
    really_eaten: boolean | null
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  type GetMealGroupByPayload<T extends MealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealGroupByOutputType[P]>
            : GetScalarType<T[P], MealGroupByOutputType[P]>
        }
      >
    >


  export type mealSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    mealtype?: boolean
    really_eaten?: boolean
    meal_elements?: boolean | meal$meal_elementsArgs<ExtArgs>
    users?: boolean | userArgs<ExtArgs>
    _count?: boolean | MealCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type mealSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    date?: boolean
    mealtype?: boolean
    really_eaten?: boolean
  }

  export type mealInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meal_elements?: boolean | meal$meal_elementsArgs<ExtArgs>
    users?: boolean | userArgs<ExtArgs>
    _count?: boolean | MealCountOutputTypeArgs<ExtArgs>
  }


  type mealGetPayload<S extends boolean | null | undefined | mealArgs> = $Types.GetResult<mealPayload, S>

  type mealCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<mealFindManyArgs, 'select' | 'include'> & {
      select?: MealCountAggregateInputType | true
    }

  export interface mealDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meal'], meta: { name: 'meal' } }
    /**
     * Find zero or one Meal that matches the filter.
     * @param {mealFindUniqueArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mealFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mealFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'meal'> extends True ? Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Meal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mealFindUniqueOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mealFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mealFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mealFindFirstArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mealFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mealFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'meal'> extends True ? Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Meal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mealFindFirstOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mealFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, mealFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mealFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meals
     * const meals = await prisma.meal.findMany()
     * 
     * // Get first 10 Meals
     * const meals = await prisma.meal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealWithIdOnly = await prisma.meal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mealFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mealFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<mealPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Meal.
     * @param {mealCreateArgs} args - Arguments to create a Meal.
     * @example
     * // Create one Meal
     * const Meal = await prisma.meal.create({
     *   data: {
     *     // ... data to create a Meal
     *   }
     * })
     * 
    **/
    create<T extends mealCreateArgs<ExtArgs>>(
      args: SelectSubset<T, mealCreateArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Meals.
     *     @param {mealCreateManyArgs} args - Arguments to create many Meals.
     *     @example
     *     // Create many Meals
     *     const meal = await prisma.meal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mealCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mealCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meal.
     * @param {mealDeleteArgs} args - Arguments to delete one Meal.
     * @example
     * // Delete one Meal
     * const Meal = await prisma.meal.delete({
     *   where: {
     *     // ... filter to delete one Meal
     *   }
     * })
     * 
    **/
    delete<T extends mealDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, mealDeleteArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Meal.
     * @param {mealUpdateArgs} args - Arguments to update one Meal.
     * @example
     * // Update one Meal
     * const meal = await prisma.meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mealUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, mealUpdateArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Meals.
     * @param {mealDeleteManyArgs} args - Arguments to filter Meals to delete.
     * @example
     * // Delete a few Meals
     * const { count } = await prisma.meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mealDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, mealDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mealUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, mealUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meal.
     * @param {mealUpsertArgs} args - Arguments to update or create a Meal.
     * @example
     * // Update or create a Meal
     * const meal = await prisma.meal.upsert({
     *   create: {
     *     // ... data to create a Meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal we want to update
     *   }
     * })
    **/
    upsert<T extends mealUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, mealUpsertArgs<ExtArgs>>
    ): Prisma__mealClient<$Types.GetResult<mealPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mealCountArgs} args - Arguments to filter Meals to count.
     * @example
     * // Count the number of Meals
     * const count = await prisma.meal.count({
     *   where: {
     *     // ... the filter for the Meals we want to count
     *   }
     * })
    **/
    count<T extends mealCountArgs>(
      args?: Subset<T, mealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealAggregateArgs>(args: Subset<T, MealAggregateArgs>): Prisma.PrismaPromise<GetMealAggregateType<T>>

    /**
     * Group by Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealGroupByArgs['orderBy'] }
        : { orderBy?: MealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mealClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    meal_elements<T extends meal$meal_elementsArgs<ExtArgs> = {}>(args?: Subset<T, meal$meal_elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findMany', never>| Null>;

    users<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * meal base type for findUnique actions
   */
  export type mealFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter, which meal to fetch.
     */
    where: mealWhereUniqueInput
  }

  /**
   * meal findUnique
   */
  export interface mealFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mealFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * meal findUniqueOrThrow
   */
  export type mealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter, which meal to fetch.
     */
    where: mealWhereUniqueInput
  }


  /**
   * meal base type for findFirst actions
   */
  export type mealFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter, which meal to fetch.
     */
    where?: mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meals to fetch.
     */
    orderBy?: Enumerable<mealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meals.
     */
    cursor?: mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meals.
     */
    distinct?: Enumerable<MealScalarFieldEnum>
  }

  /**
   * meal findFirst
   */
  export interface mealFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends mealFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * meal findFirstOrThrow
   */
  export type mealFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter, which meal to fetch.
     */
    where?: mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meals to fetch.
     */
    orderBy?: Enumerable<mealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meals.
     */
    cursor?: mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meals.
     */
    distinct?: Enumerable<MealScalarFieldEnum>
  }


  /**
   * meal findMany
   */
  export type mealFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter, which meals to fetch.
     */
    where?: mealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meals to fetch.
     */
    orderBy?: Enumerable<mealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meals.
     */
    cursor?: mealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meals.
     */
    skip?: number
    distinct?: Enumerable<MealScalarFieldEnum>
  }


  /**
   * meal create
   */
  export type mealCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * The data needed to create a meal.
     */
    data: XOR<mealCreateInput, mealUncheckedCreateInput>
  }


  /**
   * meal createMany
   */
  export type mealCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meals.
     */
    data: Enumerable<mealCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * meal update
   */
  export type mealUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * The data needed to update a meal.
     */
    data: XOR<mealUpdateInput, mealUncheckedUpdateInput>
    /**
     * Choose, which meal to update.
     */
    where: mealWhereUniqueInput
  }


  /**
   * meal updateMany
   */
  export type mealUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meals.
     */
    data: XOR<mealUpdateManyMutationInput, mealUncheckedUpdateManyInput>
    /**
     * Filter which meals to update
     */
    where?: mealWhereInput
  }


  /**
   * meal upsert
   */
  export type mealUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * The filter to search for the meal to update in case it exists.
     */
    where: mealWhereUniqueInput
    /**
     * In case the meal found by the `where` argument doesn't exist, create a new meal with this data.
     */
    create: XOR<mealCreateInput, mealUncheckedCreateInput>
    /**
     * In case the meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mealUpdateInput, mealUncheckedUpdateInput>
  }


  /**
   * meal delete
   */
  export type mealDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
    /**
     * Filter which meal to delete.
     */
    where: mealWhereUniqueInput
  }


  /**
   * meal deleteMany
   */
  export type mealDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which meals to delete
     */
    where?: mealWhereInput
  }


  /**
   * meal.meal_elements
   */
  export type meal$meal_elementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    where?: meal_elementWhereInput
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    cursor?: meal_elementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }


  /**
   * meal without action
   */
  export type mealArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal
     */
    select?: mealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: mealInclude<ExtArgs> | null
  }



  /**
   * Model favorite
   */


  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    count: number | null
    food_id: number | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type FavoriteSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    count: number | null
    food_id: number | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    mealtype: string | null
    count: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    user_id: number | null
    mealtype: string | null
    count: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    created_at: number
    user_id: number
    mealtype: number
    count: number
    food_id: number
    weight: number
    portion_id: number
    portion_cnt: number
    _all: number
  }


  export type FavoriteAvgAggregateInputType = {
    id?: true
    user_id?: true
    count?: true
    food_id?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type FavoriteSumAggregateInputType = {
    id?: true
    user_id?: true
    count?: true
    food_id?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type FavoriteMinAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    mealtype?: true
    count?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    mealtype?: true
    count?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    created_at?: true
    user_id?: true
    mealtype?: true
    count?: true
    food_id?: true
    weight?: true
    portion_id?: true
    portion_cnt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which favorite to aggregate.
     */
    where?: favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of favorites to fetch.
     */
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: favoriteWhereInput
    orderBy?: Enumerable<favoriteOrderByWithAggregationInput>
    by: FavoriteScalarFieldEnum[]
    having?: favoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _avg?: FavoriteAvgAggregateInputType
    _sum?: FavoriteSumAggregateInputType
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }


  export type FavoriteGroupByOutputType = {
    id: number
    created_at: Date | null
    user_id: number
    mealtype: string | null
    count: number | null
    food_id: number | null
    weight: string | null
    portion_id: number | null
    portion_cnt: Decimal | null
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type favoriteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    mealtype?: boolean
    count?: boolean
    food_id?: boolean
    weight?: boolean
    portion_id?: boolean
    portion_cnt?: boolean
    food?: boolean | foodArgs<ExtArgs>
    foodPortion?: boolean | food_portionArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type favoriteSelectScalar = {
    id?: boolean
    created_at?: boolean
    user_id?: boolean
    mealtype?: boolean
    count?: boolean
    food_id?: boolean
    weight?: boolean
    portion_id?: boolean
    portion_cnt?: boolean
  }

  export type favoriteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food?: boolean | foodArgs<ExtArgs>
    foodPortion?: boolean | food_portionArgs<ExtArgs>
    user?: boolean | userArgs<ExtArgs>
  }


  type favoriteGetPayload<S extends boolean | null | undefined | favoriteArgs> = $Types.GetResult<favoritePayload, S>

  type favoriteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<favoriteFindManyArgs, 'select' | 'include'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface favoriteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['favorite'], meta: { name: 'favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {favoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends favoriteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, favoriteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'favorite'> extends True ? Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Favorite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {favoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends favoriteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, favoriteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {favoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends favoriteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, favoriteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'favorite'> extends True ? Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Favorite that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {favoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends favoriteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, favoriteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {favoriteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends favoriteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, favoriteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Favorite.
     * @param {favoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
    **/
    create<T extends favoriteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, favoriteCreateArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Favorites.
     *     @param {favoriteCreateManyArgs} args - Arguments to create many Favorites.
     *     @example
     *     // Create many Favorites
     *     const favorite = await prisma.favorite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends favoriteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, favoriteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Favorite.
     * @param {favoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
    **/
    delete<T extends favoriteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, favoriteDeleteArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Favorite.
     * @param {favoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends favoriteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, favoriteUpdateArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Favorites.
     * @param {favoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends favoriteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, favoriteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {favoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends favoriteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, favoriteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Favorite.
     * @param {favoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
    **/
    upsert<T extends favoriteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, favoriteUpsertArgs<ExtArgs>>
    ): Prisma__favoriteClient<$Types.GetResult<favoritePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {favoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends favoriteCountArgs>(
      args?: Subset<T, favoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__favoriteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food<T extends foodArgs<ExtArgs> = {}>(args?: Subset<T, foodArgs<ExtArgs>>): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    foodPortion<T extends food_portionArgs<ExtArgs> = {}>(args?: Subset<T, food_portionArgs<ExtArgs>>): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * favorite base type for findUnique actions
   */
  export type favoriteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter, which favorite to fetch.
     */
    where: favoriteWhereUniqueInput
  }

  /**
   * favorite findUnique
   */
  export interface favoriteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends favoriteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * favorite findUniqueOrThrow
   */
  export type favoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter, which favorite to fetch.
     */
    where: favoriteWhereUniqueInput
  }


  /**
   * favorite base type for findFirst actions
   */
  export type favoriteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter, which favorite to fetch.
     */
    where?: favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of favorites to fetch.
     */
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for favorites.
     */
    cursor?: favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of favorites.
     */
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }

  /**
   * favorite findFirst
   */
  export interface favoriteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends favoriteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * favorite findFirstOrThrow
   */
  export type favoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter, which favorite to fetch.
     */
    where?: favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of favorites to fetch.
     */
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for favorites.
     */
    cursor?: favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of favorites.
     */
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }


  /**
   * favorite findMany
   */
  export type favoriteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter, which favorites to fetch.
     */
    where?: favoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of favorites to fetch.
     */
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing favorites.
     */
    cursor?: favoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` favorites.
     */
    skip?: number
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }


  /**
   * favorite create
   */
  export type favoriteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a favorite.
     */
    data: XOR<favoriteCreateInput, favoriteUncheckedCreateInput>
  }


  /**
   * favorite createMany
   */
  export type favoriteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many favorites.
     */
    data: Enumerable<favoriteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * favorite update
   */
  export type favoriteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a favorite.
     */
    data: XOR<favoriteUpdateInput, favoriteUncheckedUpdateInput>
    /**
     * Choose, which favorite to update.
     */
    where: favoriteWhereUniqueInput
  }


  /**
   * favorite updateMany
   */
  export type favoriteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update favorites.
     */
    data: XOR<favoriteUpdateManyMutationInput, favoriteUncheckedUpdateManyInput>
    /**
     * Filter which favorites to update
     */
    where?: favoriteWhereInput
  }


  /**
   * favorite upsert
   */
  export type favoriteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the favorite to update in case it exists.
     */
    where: favoriteWhereUniqueInput
    /**
     * In case the favorite found by the `where` argument doesn't exist, create a new favorite with this data.
     */
    create: XOR<favoriteCreateInput, favoriteUncheckedCreateInput>
    /**
     * In case the favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<favoriteUpdateInput, favoriteUncheckedUpdateInput>
  }


  /**
   * favorite delete
   */
  export type favoriteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    /**
     * Filter which favorite to delete.
     */
    where: favoriteWhereUniqueInput
  }


  /**
   * favorite deleteMany
   */
  export type favoriteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which favorites to delete
     */
    where?: favoriteWhereInput
  }


  /**
   * favorite without action
   */
  export type favoriteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
  }



  /**
   * Model category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    member_of_id: number | null
    rank: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    member_of_id: number | null
    rank: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    ciqual_gpcd: string | null
    member_of_id: number | null
    rank: number | null
    tag: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    ciqual_gpcd: string | null
    member_of_id: number | null
    rank: number | null
    tag: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    created_at: number
    shrt_desc: number
    long_desc: number
    ciqual_gpcd: number
    member_of_id: number
    rank: number
    tag: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    member_of_id?: true
    rank?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    member_of_id?: true
    rank?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_gpcd?: true
    member_of_id?: true
    rank?: true
    tag?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_gpcd?: true
    member_of_id?: true
    rank?: true
    tag?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_gpcd?: true
    member_of_id?: true
    rank?: true
    tag?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: Enumerable<categoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    ciqual_gpcd: string | null
    member_of_id: number | null
    rank: number | null
    tag: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    ciqual_gpcd?: boolean
    member_of_id?: boolean
    rank?: boolean
    tag?: boolean
    food_categories?: boolean | category$food_categoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    ciqual_gpcd?: boolean
    member_of_id?: boolean
    rank?: boolean
    tag?: boolean
  }

  export type categoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food_categories?: boolean | category$food_categoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeArgs<ExtArgs>
  }


  type categoryGetPayload<S extends boolean | null | undefined | categoryArgs> = $Types.GetResult<categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<categoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'category'> extends True ? Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'category'> extends True ? Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryCreateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>
    ): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food_categories<T extends category$food_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, category$food_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * category base type for findUnique actions
   */
  export type categoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUnique
   */
  export interface categoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends categoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category base type for findFirst actions
   */
  export type categoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * category findFirst
   */
  export interface categoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends categoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: Enumerable<categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }


  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: Enumerable<categoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
  }


  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }


  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
  }


  /**
   * category.food_categories
   */
  export type category$food_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    where?: food_categoryWhereInput
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    cursor?: food_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Food_categoryScalarFieldEnum>
  }


  /**
   * category without action
   */
  export type categoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
  }



  /**
   * Model food_category
   */


  export type AggregateFood_category = {
    _count: Food_categoryCountAggregateOutputType | null
    _avg: Food_categoryAvgAggregateOutputType | null
    _sum: Food_categorySumAggregateOutputType | null
    _min: Food_categoryMinAggregateOutputType | null
    _max: Food_categoryMaxAggregateOutputType | null
  }

  export type Food_categoryAvgAggregateOutputType = {
    id: number | null
    food_id: number | null
    category_id: number | null
  }

  export type Food_categorySumAggregateOutputType = {
    id: number | null
    food_id: number | null
    category_id: number | null
  }

  export type Food_categoryMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    food_id: number | null
    category_id: number | null
  }

  export type Food_categoryMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    food_id: number | null
    category_id: number | null
  }

  export type Food_categoryCountAggregateOutputType = {
    id: number
    created_at: number
    food_id: number
    category_id: number
    _all: number
  }


  export type Food_categoryAvgAggregateInputType = {
    id?: true
    food_id?: true
    category_id?: true
  }

  export type Food_categorySumAggregateInputType = {
    id?: true
    food_id?: true
    category_id?: true
  }

  export type Food_categoryMinAggregateInputType = {
    id?: true
    created_at?: true
    food_id?: true
    category_id?: true
  }

  export type Food_categoryMaxAggregateInputType = {
    id?: true
    created_at?: true
    food_id?: true
    category_id?: true
  }

  export type Food_categoryCountAggregateInputType = {
    id?: true
    created_at?: true
    food_id?: true
    category_id?: true
    _all?: true
  }

  export type Food_categoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which food_category to aggregate.
     */
    where?: food_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_categories to fetch.
     */
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: food_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned food_categories
    **/
    _count?: true | Food_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Food_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Food_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Food_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Food_categoryMaxAggregateInputType
  }

  export type GetFood_categoryAggregateType<T extends Food_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFood_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood_category[P]>
      : GetScalarType<T[P], AggregateFood_category[P]>
  }




  export type Food_categoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: food_categoryWhereInput
    orderBy?: Enumerable<food_categoryOrderByWithAggregationInput>
    by: Food_categoryScalarFieldEnum[]
    having?: food_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Food_categoryCountAggregateInputType | true
    _avg?: Food_categoryAvgAggregateInputType
    _sum?: Food_categorySumAggregateInputType
    _min?: Food_categoryMinAggregateInputType
    _max?: Food_categoryMaxAggregateInputType
  }


  export type Food_categoryGroupByOutputType = {
    id: number
    created_at: Date | null
    food_id: number
    category_id: number
    _count: Food_categoryCountAggregateOutputType | null
    _avg: Food_categoryAvgAggregateOutputType | null
    _sum: Food_categorySumAggregateOutputType | null
    _min: Food_categoryMinAggregateOutputType | null
    _max: Food_categoryMaxAggregateOutputType | null
  }

  type GetFood_categoryGroupByPayload<T extends Food_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Food_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Food_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Food_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Food_categoryGroupByOutputType[P]>
        }
      >
    >


  export type food_categorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    food_id?: boolean
    category_id?: boolean
    categoriy?: boolean | categoryArgs<ExtArgs>
    food?: boolean | foodArgs<ExtArgs>
  }, ExtArgs["result"]["food_category"]>

  export type food_categorySelectScalar = {
    id?: boolean
    created_at?: boolean
    food_id?: boolean
    category_id?: boolean
  }

  export type food_categoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    categoriy?: boolean | categoryArgs<ExtArgs>
    food?: boolean | foodArgs<ExtArgs>
  }


  type food_categoryGetPayload<S extends boolean | null | undefined | food_categoryArgs> = $Types.GetResult<food_categoryPayload, S>

  type food_categoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<food_categoryFindManyArgs, 'select' | 'include'> & {
      select?: Food_categoryCountAggregateInputType | true
    }

  export interface food_categoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['food_category'], meta: { name: 'food_category' } }
    /**
     * Find zero or one Food_category that matches the filter.
     * @param {food_categoryFindUniqueArgs} args - Arguments to find a Food_category
     * @example
     * // Get one Food_category
     * const food_category = await prisma.food_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends food_categoryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, food_categoryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'food_category'> extends True ? Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Food_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {food_categoryFindUniqueOrThrowArgs} args - Arguments to find a Food_category
     * @example
     * // Get one Food_category
     * const food_category = await prisma.food_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends food_categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, food_categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Food_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_categoryFindFirstArgs} args - Arguments to find a Food_category
     * @example
     * // Get one Food_category
     * const food_category = await prisma.food_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends food_categoryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, food_categoryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'food_category'> extends True ? Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Food_category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_categoryFindFirstOrThrowArgs} args - Arguments to find a Food_category
     * @example
     * // Get one Food_category
     * const food_category = await prisma.food_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends food_categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, food_categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Food_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Food_categories
     * const food_categories = await prisma.food_category.findMany()
     * 
     * // Get first 10 Food_categories
     * const food_categories = await prisma.food_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const food_categoryWithIdOnly = await prisma.food_category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends food_categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Food_category.
     * @param {food_categoryCreateArgs} args - Arguments to create a Food_category.
     * @example
     * // Create one Food_category
     * const Food_category = await prisma.food_category.create({
     *   data: {
     *     // ... data to create a Food_category
     *   }
     * })
     * 
    **/
    create<T extends food_categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, food_categoryCreateArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Food_categories.
     *     @param {food_categoryCreateManyArgs} args - Arguments to create many Food_categories.
     *     @example
     *     // Create many Food_categories
     *     const food_category = await prisma.food_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends food_categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Food_category.
     * @param {food_categoryDeleteArgs} args - Arguments to delete one Food_category.
     * @example
     * // Delete one Food_category
     * const Food_category = await prisma.food_category.delete({
     *   where: {
     *     // ... filter to delete one Food_category
     *   }
     * })
     * 
    **/
    delete<T extends food_categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, food_categoryDeleteArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Food_category.
     * @param {food_categoryUpdateArgs} args - Arguments to update one Food_category.
     * @example
     * // Update one Food_category
     * const food_category = await prisma.food_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends food_categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, food_categoryUpdateArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Food_categories.
     * @param {food_categoryDeleteManyArgs} args - Arguments to filter Food_categories to delete.
     * @example
     * // Delete a few Food_categories
     * const { count } = await prisma.food_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends food_categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Food_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Food_categories
     * const food_category = await prisma.food_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends food_categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, food_categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food_category.
     * @param {food_categoryUpsertArgs} args - Arguments to update or create a Food_category.
     * @example
     * // Update or create a Food_category
     * const food_category = await prisma.food_category.upsert({
     *   create: {
     *     // ... data to create a Food_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food_category we want to update
     *   }
     * })
    **/
    upsert<T extends food_categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, food_categoryUpsertArgs<ExtArgs>>
    ): Prisma__food_categoryClient<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Food_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_categoryCountArgs} args - Arguments to filter Food_categories to count.
     * @example
     * // Count the number of Food_categories
     * const count = await prisma.food_category.count({
     *   where: {
     *     // ... the filter for the Food_categories we want to count
     *   }
     * })
    **/
    count<T extends food_categoryCountArgs>(
      args?: Subset<T, food_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Food_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Food_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Food_categoryAggregateArgs>(args: Subset<T, Food_categoryAggregateArgs>): Prisma.PrismaPromise<GetFood_categoryAggregateType<T>>

    /**
     * Group by Food_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Food_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Food_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Food_categoryGroupByArgs['orderBy'] }
        : { orderBy?: Food_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Food_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFood_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for food_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__food_categoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    categoriy<T extends categoryArgs<ExtArgs> = {}>(args?: Subset<T, categoryArgs<ExtArgs>>): Prisma__categoryClient<$Types.GetResult<categoryPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    food<T extends foodArgs<ExtArgs> = {}>(args?: Subset<T, foodArgs<ExtArgs>>): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * food_category base type for findUnique actions
   */
  export type food_categoryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter, which food_category to fetch.
     */
    where: food_categoryWhereUniqueInput
  }

  /**
   * food_category findUnique
   */
  export interface food_categoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends food_categoryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food_category findUniqueOrThrow
   */
  export type food_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter, which food_category to fetch.
     */
    where: food_categoryWhereUniqueInput
  }


  /**
   * food_category base type for findFirst actions
   */
  export type food_categoryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter, which food_category to fetch.
     */
    where?: food_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_categories to fetch.
     */
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for food_categories.
     */
    cursor?: food_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of food_categories.
     */
    distinct?: Enumerable<Food_categoryScalarFieldEnum>
  }

  /**
   * food_category findFirst
   */
  export interface food_categoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends food_categoryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food_category findFirstOrThrow
   */
  export type food_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter, which food_category to fetch.
     */
    where?: food_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_categories to fetch.
     */
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for food_categories.
     */
    cursor?: food_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of food_categories.
     */
    distinct?: Enumerable<Food_categoryScalarFieldEnum>
  }


  /**
   * food_category findMany
   */
  export type food_categoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter, which food_categories to fetch.
     */
    where?: food_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_categories to fetch.
     */
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing food_categories.
     */
    cursor?: food_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_categories.
     */
    skip?: number
    distinct?: Enumerable<Food_categoryScalarFieldEnum>
  }


  /**
   * food_category create
   */
  export type food_categoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a food_category.
     */
    data: XOR<food_categoryCreateInput, food_categoryUncheckedCreateInput>
  }


  /**
   * food_category createMany
   */
  export type food_categoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many food_categories.
     */
    data: Enumerable<food_categoryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * food_category update
   */
  export type food_categoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a food_category.
     */
    data: XOR<food_categoryUpdateInput, food_categoryUncheckedUpdateInput>
    /**
     * Choose, which food_category to update.
     */
    where: food_categoryWhereUniqueInput
  }


  /**
   * food_category updateMany
   */
  export type food_categoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update food_categories.
     */
    data: XOR<food_categoryUpdateManyMutationInput, food_categoryUncheckedUpdateManyInput>
    /**
     * Filter which food_categories to update
     */
    where?: food_categoryWhereInput
  }


  /**
   * food_category upsert
   */
  export type food_categoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the food_category to update in case it exists.
     */
    where: food_categoryWhereUniqueInput
    /**
     * In case the food_category found by the `where` argument doesn't exist, create a new food_category with this data.
     */
    create: XOR<food_categoryCreateInput, food_categoryUncheckedCreateInput>
    /**
     * In case the food_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<food_categoryUpdateInput, food_categoryUncheckedUpdateInput>
  }


  /**
   * food_category delete
   */
  export type food_categoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    /**
     * Filter which food_category to delete.
     */
    where: food_categoryWhereUniqueInput
  }


  /**
   * food_category deleteMany
   */
  export type food_categoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which food_categories to delete
     */
    where?: food_categoryWhereInput
  }


  /**
   * food_category without action
   */
  export type food_categoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
  }



  /**
   * Model food_portion
   */


  export type AggregateFood_portion = {
    _count: Food_portionCountAggregateOutputType | null
    _avg: Food_portionAvgAggregateOutputType | null
    _sum: Food_portionSumAggregateOutputType | null
    _min: Food_portionMinAggregateOutputType | null
    _max: Food_portionMaxAggregateOutputType | null
  }

  export type Food_portionAvgAggregateOutputType = {
    id: number | null
    food_id: number | null
  }

  export type Food_portionSumAggregateOutputType = {
    id: number | null
    food_id: number | null
  }

  export type Food_portionMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    qty: string | null
    shrt_desc: string | null
    long_desc: string | null
    note: string | null
    pict: string | null
    food_id: number | null
  }

  export type Food_portionMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    qty: string | null
    shrt_desc: string | null
    long_desc: string | null
    note: string | null
    pict: string | null
    food_id: number | null
  }

  export type Food_portionCountAggregateOutputType = {
    id: number
    created_at: number
    qty: number
    shrt_desc: number
    long_desc: number
    note: number
    pict: number
    food_id: number
    _all: number
  }


  export type Food_portionAvgAggregateInputType = {
    id?: true
    food_id?: true
  }

  export type Food_portionSumAggregateInputType = {
    id?: true
    food_id?: true
  }

  export type Food_portionMinAggregateInputType = {
    id?: true
    created_at?: true
    qty?: true
    shrt_desc?: true
    long_desc?: true
    note?: true
    pict?: true
    food_id?: true
  }

  export type Food_portionMaxAggregateInputType = {
    id?: true
    created_at?: true
    qty?: true
    shrt_desc?: true
    long_desc?: true
    note?: true
    pict?: true
    food_id?: true
  }

  export type Food_portionCountAggregateInputType = {
    id?: true
    created_at?: true
    qty?: true
    shrt_desc?: true
    long_desc?: true
    note?: true
    pict?: true
    food_id?: true
    _all?: true
  }

  export type Food_portionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which food_portion to aggregate.
     */
    where?: food_portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_portions to fetch.
     */
    orderBy?: Enumerable<food_portionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: food_portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned food_portions
    **/
    _count?: true | Food_portionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Food_portionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Food_portionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Food_portionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Food_portionMaxAggregateInputType
  }

  export type GetFood_portionAggregateType<T extends Food_portionAggregateArgs> = {
        [P in keyof T & keyof AggregateFood_portion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood_portion[P]>
      : GetScalarType<T[P], AggregateFood_portion[P]>
  }




  export type Food_portionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: food_portionWhereInput
    orderBy?: Enumerable<food_portionOrderByWithAggregationInput>
    by: Food_portionScalarFieldEnum[]
    having?: food_portionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Food_portionCountAggregateInputType | true
    _avg?: Food_portionAvgAggregateInputType
    _sum?: Food_portionSumAggregateInputType
    _min?: Food_portionMinAggregateInputType
    _max?: Food_portionMaxAggregateInputType
  }


  export type Food_portionGroupByOutputType = {
    id: number
    created_at: Date | null
    qty: string
    shrt_desc: string
    long_desc: string | null
    note: string | null
    pict: string | null
    food_id: number
    _count: Food_portionCountAggregateOutputType | null
    _avg: Food_portionAvgAggregateOutputType | null
    _sum: Food_portionSumAggregateOutputType | null
    _min: Food_portionMinAggregateOutputType | null
    _max: Food_portionMaxAggregateOutputType | null
  }

  type GetFood_portionGroupByPayload<T extends Food_portionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Food_portionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Food_portionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Food_portionGroupByOutputType[P]>
            : GetScalarType<T[P], Food_portionGroupByOutputType[P]>
        }
      >
    >


  export type food_portionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    qty?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    note?: boolean
    pict?: boolean
    food_id?: boolean
    food?: boolean | foodArgs<ExtArgs>
    mealElements?: boolean | food_portion$mealElementsArgs<ExtArgs>
    favorites?: boolean | food_portion$favoritesArgs<ExtArgs>
    _count?: boolean | Food_portionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["food_portion"]>

  export type food_portionSelectScalar = {
    id?: boolean
    created_at?: boolean
    qty?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    note?: boolean
    pict?: boolean
    food_id?: boolean
  }

  export type food_portionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food?: boolean | foodArgs<ExtArgs>
    mealElements?: boolean | food_portion$mealElementsArgs<ExtArgs>
    favorites?: boolean | food_portion$favoritesArgs<ExtArgs>
    _count?: boolean | Food_portionCountOutputTypeArgs<ExtArgs>
  }


  type food_portionGetPayload<S extends boolean | null | undefined | food_portionArgs> = $Types.GetResult<food_portionPayload, S>

  type food_portionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<food_portionFindManyArgs, 'select' | 'include'> & {
      select?: Food_portionCountAggregateInputType | true
    }

  export interface food_portionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['food_portion'], meta: { name: 'food_portion' } }
    /**
     * Find zero or one Food_portion that matches the filter.
     * @param {food_portionFindUniqueArgs} args - Arguments to find a Food_portion
     * @example
     * // Get one Food_portion
     * const food_portion = await prisma.food_portion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends food_portionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, food_portionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'food_portion'> extends True ? Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Food_portion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {food_portionFindUniqueOrThrowArgs} args - Arguments to find a Food_portion
     * @example
     * // Get one Food_portion
     * const food_portion = await prisma.food_portion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends food_portionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, food_portionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Food_portion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_portionFindFirstArgs} args - Arguments to find a Food_portion
     * @example
     * // Get one Food_portion
     * const food_portion = await prisma.food_portion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends food_portionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, food_portionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'food_portion'> extends True ? Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Food_portion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_portionFindFirstOrThrowArgs} args - Arguments to find a Food_portion
     * @example
     * // Get one Food_portion
     * const food_portion = await prisma.food_portion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends food_portionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, food_portionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Food_portions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_portionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Food_portions
     * const food_portions = await prisma.food_portion.findMany()
     * 
     * // Get first 10 Food_portions
     * const food_portions = await prisma.food_portion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const food_portionWithIdOnly = await prisma.food_portion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends food_portionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_portionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Food_portion.
     * @param {food_portionCreateArgs} args - Arguments to create a Food_portion.
     * @example
     * // Create one Food_portion
     * const Food_portion = await prisma.food_portion.create({
     *   data: {
     *     // ... data to create a Food_portion
     *   }
     * })
     * 
    **/
    create<T extends food_portionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, food_portionCreateArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Food_portions.
     *     @param {food_portionCreateManyArgs} args - Arguments to create many Food_portions.
     *     @example
     *     // Create many Food_portions
     *     const food_portion = await prisma.food_portion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends food_portionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_portionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Food_portion.
     * @param {food_portionDeleteArgs} args - Arguments to delete one Food_portion.
     * @example
     * // Delete one Food_portion
     * const Food_portion = await prisma.food_portion.delete({
     *   where: {
     *     // ... filter to delete one Food_portion
     *   }
     * })
     * 
    **/
    delete<T extends food_portionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, food_portionDeleteArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Food_portion.
     * @param {food_portionUpdateArgs} args - Arguments to update one Food_portion.
     * @example
     * // Update one Food_portion
     * const food_portion = await prisma.food_portion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends food_portionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, food_portionUpdateArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Food_portions.
     * @param {food_portionDeleteManyArgs} args - Arguments to filter Food_portions to delete.
     * @example
     * // Delete a few Food_portions
     * const { count } = await prisma.food_portion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends food_portionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, food_portionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Food_portions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_portionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Food_portions
     * const food_portion = await prisma.food_portion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends food_portionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, food_portionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food_portion.
     * @param {food_portionUpsertArgs} args - Arguments to update or create a Food_portion.
     * @example
     * // Update or create a Food_portion
     * const food_portion = await prisma.food_portion.upsert({
     *   create: {
     *     // ... data to create a Food_portion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food_portion we want to update
     *   }
     * })
    **/
    upsert<T extends food_portionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, food_portionUpsertArgs<ExtArgs>>
    ): Prisma__food_portionClient<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Food_portions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {food_portionCountArgs} args - Arguments to filter Food_portions to count.
     * @example
     * // Count the number of Food_portions
     * const count = await prisma.food_portion.count({
     *   where: {
     *     // ... the filter for the Food_portions we want to count
     *   }
     * })
    **/
    count<T extends food_portionCountArgs>(
      args?: Subset<T, food_portionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Food_portionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food_portion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Food_portionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Food_portionAggregateArgs>(args: Subset<T, Food_portionAggregateArgs>): Prisma.PrismaPromise<GetFood_portionAggregateType<T>>

    /**
     * Group by Food_portion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Food_portionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Food_portionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Food_portionGroupByArgs['orderBy'] }
        : { orderBy?: Food_portionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Food_portionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFood_portionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for food_portion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__food_portionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food<T extends foodArgs<ExtArgs> = {}>(args?: Subset<T, foodArgs<ExtArgs>>): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    mealElements<T extends food_portion$mealElementsArgs<ExtArgs> = {}>(args?: Subset<T, food_portion$mealElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findMany', never>| Null>;

    favorites<T extends food_portion$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, food_portion$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * food_portion base type for findUnique actions
   */
  export type food_portionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter, which food_portion to fetch.
     */
    where: food_portionWhereUniqueInput
  }

  /**
   * food_portion findUnique
   */
  export interface food_portionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends food_portionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food_portion findUniqueOrThrow
   */
  export type food_portionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter, which food_portion to fetch.
     */
    where: food_portionWhereUniqueInput
  }


  /**
   * food_portion base type for findFirst actions
   */
  export type food_portionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter, which food_portion to fetch.
     */
    where?: food_portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_portions to fetch.
     */
    orderBy?: Enumerable<food_portionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for food_portions.
     */
    cursor?: food_portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of food_portions.
     */
    distinct?: Enumerable<Food_portionScalarFieldEnum>
  }

  /**
   * food_portion findFirst
   */
  export interface food_portionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends food_portionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food_portion findFirstOrThrow
   */
  export type food_portionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter, which food_portion to fetch.
     */
    where?: food_portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_portions to fetch.
     */
    orderBy?: Enumerable<food_portionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for food_portions.
     */
    cursor?: food_portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_portions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of food_portions.
     */
    distinct?: Enumerable<Food_portionScalarFieldEnum>
  }


  /**
   * food_portion findMany
   */
  export type food_portionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter, which food_portions to fetch.
     */
    where?: food_portionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of food_portions to fetch.
     */
    orderBy?: Enumerable<food_portionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing food_portions.
     */
    cursor?: food_portionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` food_portions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` food_portions.
     */
    skip?: number
    distinct?: Enumerable<Food_portionScalarFieldEnum>
  }


  /**
   * food_portion create
   */
  export type food_portionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * The data needed to create a food_portion.
     */
    data: XOR<food_portionCreateInput, food_portionUncheckedCreateInput>
  }


  /**
   * food_portion createMany
   */
  export type food_portionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many food_portions.
     */
    data: Enumerable<food_portionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * food_portion update
   */
  export type food_portionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * The data needed to update a food_portion.
     */
    data: XOR<food_portionUpdateInput, food_portionUncheckedUpdateInput>
    /**
     * Choose, which food_portion to update.
     */
    where: food_portionWhereUniqueInput
  }


  /**
   * food_portion updateMany
   */
  export type food_portionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update food_portions.
     */
    data: XOR<food_portionUpdateManyMutationInput, food_portionUncheckedUpdateManyInput>
    /**
     * Filter which food_portions to update
     */
    where?: food_portionWhereInput
  }


  /**
   * food_portion upsert
   */
  export type food_portionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * The filter to search for the food_portion to update in case it exists.
     */
    where: food_portionWhereUniqueInput
    /**
     * In case the food_portion found by the `where` argument doesn't exist, create a new food_portion with this data.
     */
    create: XOR<food_portionCreateInput, food_portionUncheckedCreateInput>
    /**
     * In case the food_portion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<food_portionUpdateInput, food_portionUncheckedUpdateInput>
  }


  /**
   * food_portion delete
   */
  export type food_portionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    /**
     * Filter which food_portion to delete.
     */
    where: food_portionWhereUniqueInput
  }


  /**
   * food_portion deleteMany
   */
  export type food_portionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which food_portions to delete
     */
    where?: food_portionWhereInput
  }


  /**
   * food_portion.mealElements
   */
  export type food_portion$mealElementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    where?: meal_elementWhereInput
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    cursor?: meal_elementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }


  /**
   * food_portion.favorites
   */
  export type food_portion$favoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    where?: favoriteWhereInput
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    cursor?: favoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }


  /**
   * food_portion without action
   */
  export type food_portionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
  }



  /**
   * Model food
   */


  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodAvgAggregateOutputType = {
    id: number | null
    source_id: number | null
  }

  export type FoodSumAggregateOutputType = {
    id: number | null
    source_id: number | null
  }

  export type FoodMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    ciqual_name: string | null
    ctdit_shrt_desc: string | null
    ctdit_long_desc: string | null
    keywords: string | null
    ciqual_num: string | null
    note: string | null
    max_qty: string | null
    pict: string | null
    source_id: number | null
    is_brand: boolean | null
    is_raw: boolean | null
    is_indivisible: boolean | null
    is_chu: boolean | null
    is_demo: boolean | null
    is_patient_full: boolean | null
    is_patient_simplified: boolean | null
    pack_pict: string | null
    is_validated: boolean | null
  }

  export type FoodMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    ciqual_name: string | null
    ctdit_shrt_desc: string | null
    ctdit_long_desc: string | null
    keywords: string | null
    ciqual_num: string | null
    note: string | null
    max_qty: string | null
    pict: string | null
    source_id: number | null
    is_brand: boolean | null
    is_raw: boolean | null
    is_indivisible: boolean | null
    is_chu: boolean | null
    is_demo: boolean | null
    is_patient_full: boolean | null
    is_patient_simplified: boolean | null
    pack_pict: string | null
    is_validated: boolean | null
  }

  export type FoodCountAggregateOutputType = {
    id: number
    created_at: number
    shrt_desc: number
    long_desc: number
    ciqual_name: number
    ctdit_shrt_desc: number
    ctdit_long_desc: number
    keywords: number
    ciqual_num: number
    note: number
    max_qty: number
    pict: number
    source_id: number
    is_brand: number
    is_raw: number
    is_indivisible: number
    is_chu: number
    is_demo: number
    is_patient_full: number
    is_patient_simplified: number
    pack_pict: number
    is_validated: number
    _all: number
  }


  export type FoodAvgAggregateInputType = {
    id?: true
    source_id?: true
  }

  export type FoodSumAggregateInputType = {
    id?: true
    source_id?: true
  }

  export type FoodMinAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_name?: true
    ctdit_shrt_desc?: true
    ctdit_long_desc?: true
    keywords?: true
    ciqual_num?: true
    note?: true
    max_qty?: true
    pict?: true
    source_id?: true
    is_brand?: true
    is_raw?: true
    is_indivisible?: true
    is_chu?: true
    is_demo?: true
    is_patient_full?: true
    is_patient_simplified?: true
    pack_pict?: true
    is_validated?: true
  }

  export type FoodMaxAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_name?: true
    ctdit_shrt_desc?: true
    ctdit_long_desc?: true
    keywords?: true
    ciqual_num?: true
    note?: true
    max_qty?: true
    pict?: true
    source_id?: true
    is_brand?: true
    is_raw?: true
    is_indivisible?: true
    is_chu?: true
    is_demo?: true
    is_patient_full?: true
    is_patient_simplified?: true
    pack_pict?: true
    is_validated?: true
  }

  export type FoodCountAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    ciqual_name?: true
    ctdit_shrt_desc?: true
    ctdit_long_desc?: true
    keywords?: true
    ciqual_num?: true
    note?: true
    max_qty?: true
    pict?: true
    source_id?: true
    is_brand?: true
    is_raw?: true
    is_indivisible?: true
    is_chu?: true
    is_demo?: true
    is_patient_full?: true
    is_patient_simplified?: true
    pack_pict?: true
    is_validated?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which food to aggregate.
     */
    where?: foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foods to fetch.
     */
    orderBy?: Enumerable<foodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: foodWhereInput
    orderBy?: Enumerable<foodOrderByWithAggregationInput>
    by: FoodScalarFieldEnum[]
    having?: foodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _avg?: FoodAvgAggregateInputType
    _sum?: FoodSumAggregateInputType
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }


  export type FoodGroupByOutputType = {
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    ciqual_name: string | null
    ctdit_shrt_desc: string | null
    ctdit_long_desc: string | null
    keywords: string | null
    ciqual_num: string | null
    note: string | null
    max_qty: string | null
    pict: string | null
    source_id: number
    is_brand: boolean | null
    is_raw: boolean | null
    is_indivisible: boolean | null
    is_chu: boolean | null
    is_demo: boolean | null
    is_patient_full: boolean | null
    is_patient_simplified: boolean | null
    pack_pict: string | null
    is_validated: boolean | null
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type foodSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    ciqual_name?: boolean
    ctdit_shrt_desc?: boolean
    ctdit_long_desc?: boolean
    keywords?: boolean
    ciqual_num?: boolean
    note?: boolean
    max_qty?: boolean
    pict?: boolean
    source_id?: boolean
    is_brand?: boolean
    is_raw?: boolean
    is_indivisible?: boolean
    is_chu?: boolean
    is_demo?: boolean
    is_patient_full?: boolean
    is_patient_simplified?: boolean
    pack_pict?: boolean
    is_validated?: boolean
    food_categories?: boolean | food$food_categoriesArgs<ExtArgs>
    food_portions?: boolean | food$food_portionsArgs<ExtArgs>
    source?: boolean | sourceArgs<ExtArgs>
    nutdata?: boolean | food$nutdataArgs<ExtArgs>
    mealElements?: boolean | food$mealElementsArgs<ExtArgs>
    favorites?: boolean | food$favoritesArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type foodSelectScalar = {
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    ciqual_name?: boolean
    ctdit_shrt_desc?: boolean
    ctdit_long_desc?: boolean
    keywords?: boolean
    ciqual_num?: boolean
    note?: boolean
    max_qty?: boolean
    pict?: boolean
    source_id?: boolean
    is_brand?: boolean
    is_raw?: boolean
    is_indivisible?: boolean
    is_chu?: boolean
    is_demo?: boolean
    is_patient_full?: boolean
    is_patient_simplified?: boolean
    pack_pict?: boolean
    is_validated?: boolean
  }

  export type foodInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food_categories?: boolean | food$food_categoriesArgs<ExtArgs>
    food_portions?: boolean | food$food_portionsArgs<ExtArgs>
    source?: boolean | sourceArgs<ExtArgs>
    nutdata?: boolean | food$nutdataArgs<ExtArgs>
    mealElements?: boolean | food$mealElementsArgs<ExtArgs>
    favorites?: boolean | food$favoritesArgs<ExtArgs>
    _count?: boolean | FoodCountOutputTypeArgs<ExtArgs>
  }


  type foodGetPayload<S extends boolean | null | undefined | foodArgs> = $Types.GetResult<foodPayload, S>

  type foodCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<foodFindManyArgs, 'select' | 'include'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface foodDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['food'], meta: { name: 'food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {foodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends foodFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, foodFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'food'> extends True ? Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Food that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {foodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends foodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, foodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends foodFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, foodFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'food'> extends True ? Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Food that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends foodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, foodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodWithIdOnly = await prisma.food.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends foodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<foodPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Food.
     * @param {foodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
    **/
    create<T extends foodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, foodCreateArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Foods.
     *     @param {foodCreateManyArgs} args - Arguments to create many Foods.
     *     @example
     *     // Create many Foods
     *     const food = await prisma.food.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends foodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Food.
     * @param {foodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
    **/
    delete<T extends foodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, foodDeleteArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Food.
     * @param {foodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends foodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, foodUpdateArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Foods.
     * @param {foodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends foodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, foodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends foodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, foodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food.
     * @param {foodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
    **/
    upsert<T extends foodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, foodUpsertArgs<ExtArgs>>
    ): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends foodCountArgs>(
      args?: Subset<T, foodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__foodClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food_categories<T extends food$food_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, food$food_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<food_categoryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    food_portions<T extends food$food_portionsArgs<ExtArgs> = {}>(args?: Subset<T, food$food_portionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<food_portionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    source<T extends sourceArgs<ExtArgs> = {}>(args?: Subset<T, sourceArgs<ExtArgs>>): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    nutdata<T extends food$nutdataArgs<ExtArgs> = {}>(args?: Subset<T, food$nutdataArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findMany', never>| Null>;

    mealElements<T extends food$mealElementsArgs<ExtArgs> = {}>(args?: Subset<T, food$mealElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<meal_elementPayload<ExtArgs>, T, 'findMany', never>| Null>;

    favorites<T extends food$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, food$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<favoritePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * food base type for findUnique actions
   */
  export type foodFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter, which food to fetch.
     */
    where: foodWhereUniqueInput
  }

  /**
   * food findUnique
   */
  export interface foodFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends foodFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food findUniqueOrThrow
   */
  export type foodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter, which food to fetch.
     */
    where: foodWhereUniqueInput
  }


  /**
   * food base type for findFirst actions
   */
  export type foodFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter, which food to fetch.
     */
    where?: foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foods to fetch.
     */
    orderBy?: Enumerable<foodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foods.
     */
    cursor?: foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foods.
     */
    distinct?: Enumerable<FoodScalarFieldEnum>
  }

  /**
   * food findFirst
   */
  export interface foodFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends foodFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * food findFirstOrThrow
   */
  export type foodFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter, which food to fetch.
     */
    where?: foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foods to fetch.
     */
    orderBy?: Enumerable<foodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for foods.
     */
    cursor?: foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of foods.
     */
    distinct?: Enumerable<FoodScalarFieldEnum>
  }


  /**
   * food findMany
   */
  export type foodFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter, which foods to fetch.
     */
    where?: foodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of foods to fetch.
     */
    orderBy?: Enumerable<foodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing foods.
     */
    cursor?: foodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` foods.
     */
    skip?: number
    distinct?: Enumerable<FoodScalarFieldEnum>
  }


  /**
   * food create
   */
  export type foodCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * The data needed to create a food.
     */
    data: XOR<foodCreateInput, foodUncheckedCreateInput>
  }


  /**
   * food createMany
   */
  export type foodCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many foods.
     */
    data: Enumerable<foodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * food update
   */
  export type foodUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * The data needed to update a food.
     */
    data: XOR<foodUpdateInput, foodUncheckedUpdateInput>
    /**
     * Choose, which food to update.
     */
    where: foodWhereUniqueInput
  }


  /**
   * food updateMany
   */
  export type foodUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update foods.
     */
    data: XOR<foodUpdateManyMutationInput, foodUncheckedUpdateManyInput>
    /**
     * Filter which foods to update
     */
    where?: foodWhereInput
  }


  /**
   * food upsert
   */
  export type foodUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * The filter to search for the food to update in case it exists.
     */
    where: foodWhereUniqueInput
    /**
     * In case the food found by the `where` argument doesn't exist, create a new food with this data.
     */
    create: XOR<foodCreateInput, foodUncheckedCreateInput>
    /**
     * In case the food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<foodUpdateInput, foodUncheckedUpdateInput>
  }


  /**
   * food delete
   */
  export type foodDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    /**
     * Filter which food to delete.
     */
    where: foodWhereUniqueInput
  }


  /**
   * food deleteMany
   */
  export type foodDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which foods to delete
     */
    where?: foodWhereInput
  }


  /**
   * food.food_categories
   */
  export type food$food_categoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_category
     */
    select?: food_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_categoryInclude<ExtArgs> | null
    where?: food_categoryWhereInput
    orderBy?: Enumerable<food_categoryOrderByWithRelationInput>
    cursor?: food_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Food_categoryScalarFieldEnum>
  }


  /**
   * food.food_portions
   */
  export type food$food_portionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food_portion
     */
    select?: food_portionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: food_portionInclude<ExtArgs> | null
    where?: food_portionWhereInput
    orderBy?: Enumerable<food_portionOrderByWithRelationInput>
    cursor?: food_portionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Food_portionScalarFieldEnum>
  }


  /**
   * food.nutdata
   */
  export type food$nutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    where?: nutdataWhereInput
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    cursor?: nutdataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }


  /**
   * food.mealElements
   */
  export type food$mealElementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meal_element
     */
    select?: meal_elementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: meal_elementInclude<ExtArgs> | null
    where?: meal_elementWhereInput
    orderBy?: Enumerable<meal_elementOrderByWithRelationInput>
    cursor?: meal_elementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Meal_elementScalarFieldEnum>
  }


  /**
   * food.favorites
   */
  export type food$favoritesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the favorite
     */
    select?: favoriteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: favoriteInclude<ExtArgs> | null
    where?: favoriteWhereInput
    orderBy?: Enumerable<favoriteOrderByWithRelationInput>
    cursor?: favoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FavoriteScalarFieldEnum>
  }


  /**
   * food without action
   */
  export type foodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
  }



  /**
   * Model nutdata
   */


  export type AggregateNutdata = {
    _count: NutdataCountAggregateOutputType | null
    _avg: NutdataAvgAggregateOutputType | null
    _sum: NutdataSumAggregateOutputType | null
    _min: NutdataMinAggregateOutputType | null
    _max: NutdataMaxAggregateOutputType | null
  }

  export type NutdataAvgAggregateOutputType = {
    id: number | null
    food_id: number | null
    source_id: number | null
  }

  export type NutdataSumAggregateOutputType = {
    id: number | null
    food_id: number | null
    source_id: number | null
  }

  export type NutdataMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    val: string | null
    note: string | null
    food_id: number | null
    nutr_no: string | null
    source_id: number | null
  }

  export type NutdataMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    val: string | null
    note: string | null
    food_id: number | null
    nutr_no: string | null
    source_id: number | null
  }

  export type NutdataCountAggregateOutputType = {
    id: number
    created_at: number
    val: number
    note: number
    food_id: number
    nutr_no: number
    source_id: number
    _all: number
  }


  export type NutdataAvgAggregateInputType = {
    id?: true
    food_id?: true
    source_id?: true
  }

  export type NutdataSumAggregateInputType = {
    id?: true
    food_id?: true
    source_id?: true
  }

  export type NutdataMinAggregateInputType = {
    id?: true
    created_at?: true
    val?: true
    note?: true
    food_id?: true
    nutr_no?: true
    source_id?: true
  }

  export type NutdataMaxAggregateInputType = {
    id?: true
    created_at?: true
    val?: true
    note?: true
    food_id?: true
    nutr_no?: true
    source_id?: true
  }

  export type NutdataCountAggregateInputType = {
    id?: true
    created_at?: true
    val?: true
    note?: true
    food_id?: true
    nutr_no?: true
    source_id?: true
    _all?: true
  }

  export type NutdataAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutdata to aggregate.
     */
    where?: nutdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutdata to fetch.
     */
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nutdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nutdata
    **/
    _count?: true | NutdataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutdataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutdataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutdataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutdataMaxAggregateInputType
  }

  export type GetNutdataAggregateType<T extends NutdataAggregateArgs> = {
        [P in keyof T & keyof AggregateNutdata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutdata[P]>
      : GetScalarType<T[P], AggregateNutdata[P]>
  }




  export type NutdataGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: nutdataWhereInput
    orderBy?: Enumerable<nutdataOrderByWithAggregationInput>
    by: NutdataScalarFieldEnum[]
    having?: nutdataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutdataCountAggregateInputType | true
    _avg?: NutdataAvgAggregateInputType
    _sum?: NutdataSumAggregateInputType
    _min?: NutdataMinAggregateInputType
    _max?: NutdataMaxAggregateInputType
  }


  export type NutdataGroupByOutputType = {
    id: number
    created_at: Date | null
    val: string | null
    note: string | null
    food_id: number
    nutr_no: string
    source_id: number
    _count: NutdataCountAggregateOutputType | null
    _avg: NutdataAvgAggregateOutputType | null
    _sum: NutdataSumAggregateOutputType | null
    _min: NutdataMinAggregateOutputType | null
    _max: NutdataMaxAggregateOutputType | null
  }

  type GetNutdataGroupByPayload<T extends NutdataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NutdataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutdataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutdataGroupByOutputType[P]>
            : GetScalarType<T[P], NutdataGroupByOutputType[P]>
        }
      >
    >


  export type nutdataSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    val?: boolean
    note?: boolean
    food_id?: boolean
    nutr_no?: boolean
    source_id?: boolean
    food?: boolean | foodArgs<ExtArgs>
    nutrient?: boolean | nutrientArgs<ExtArgs>
    source?: boolean | sourceArgs<ExtArgs>
  }, ExtArgs["result"]["nutdata"]>

  export type nutdataSelectScalar = {
    id?: boolean
    created_at?: boolean
    val?: boolean
    note?: boolean
    food_id?: boolean
    nutr_no?: boolean
    source_id?: boolean
  }

  export type nutdataInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    food?: boolean | foodArgs<ExtArgs>
    nutrient?: boolean | nutrientArgs<ExtArgs>
    source?: boolean | sourceArgs<ExtArgs>
  }


  type nutdataGetPayload<S extends boolean | null | undefined | nutdataArgs> = $Types.GetResult<nutdataPayload, S>

  type nutdataCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<nutdataFindManyArgs, 'select' | 'include'> & {
      select?: NutdataCountAggregateInputType | true
    }

  export interface nutdataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nutdata'], meta: { name: 'nutdata' } }
    /**
     * Find zero or one Nutdata that matches the filter.
     * @param {nutdataFindUniqueArgs} args - Arguments to find a Nutdata
     * @example
     * // Get one Nutdata
     * const nutdata = await prisma.nutdata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends nutdataFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, nutdataFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'nutdata'> extends True ? Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Nutdata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {nutdataFindUniqueOrThrowArgs} args - Arguments to find a Nutdata
     * @example
     * // Get one Nutdata
     * const nutdata = await prisma.nutdata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends nutdataFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, nutdataFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Nutdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutdataFindFirstArgs} args - Arguments to find a Nutdata
     * @example
     * // Get one Nutdata
     * const nutdata = await prisma.nutdata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends nutdataFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, nutdataFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'nutdata'> extends True ? Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Nutdata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutdataFindFirstOrThrowArgs} args - Arguments to find a Nutdata
     * @example
     * // Get one Nutdata
     * const nutdata = await prisma.nutdata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends nutdataFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, nutdataFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Nutdata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutdataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nutdata
     * const nutdata = await prisma.nutdata.findMany()
     * 
     * // Get first 10 Nutdata
     * const nutdata = await prisma.nutdata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutdataWithIdOnly = await prisma.nutdata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends nutdataFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutdataFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Nutdata.
     * @param {nutdataCreateArgs} args - Arguments to create a Nutdata.
     * @example
     * // Create one Nutdata
     * const Nutdata = await prisma.nutdata.create({
     *   data: {
     *     // ... data to create a Nutdata
     *   }
     * })
     * 
    **/
    create<T extends nutdataCreateArgs<ExtArgs>>(
      args: SelectSubset<T, nutdataCreateArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Nutdata.
     *     @param {nutdataCreateManyArgs} args - Arguments to create many Nutdata.
     *     @example
     *     // Create many Nutdata
     *     const nutdata = await prisma.nutdata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends nutdataCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutdataCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Nutdata.
     * @param {nutdataDeleteArgs} args - Arguments to delete one Nutdata.
     * @example
     * // Delete one Nutdata
     * const Nutdata = await prisma.nutdata.delete({
     *   where: {
     *     // ... filter to delete one Nutdata
     *   }
     * })
     * 
    **/
    delete<T extends nutdataDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, nutdataDeleteArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Nutdata.
     * @param {nutdataUpdateArgs} args - Arguments to update one Nutdata.
     * @example
     * // Update one Nutdata
     * const nutdata = await prisma.nutdata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends nutdataUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, nutdataUpdateArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Nutdata.
     * @param {nutdataDeleteManyArgs} args - Arguments to filter Nutdata to delete.
     * @example
     * // Delete a few Nutdata
     * const { count } = await prisma.nutdata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends nutdataDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutdataDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nutdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutdataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nutdata
     * const nutdata = await prisma.nutdata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends nutdataUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, nutdataUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nutdata.
     * @param {nutdataUpsertArgs} args - Arguments to update or create a Nutdata.
     * @example
     * // Update or create a Nutdata
     * const nutdata = await prisma.nutdata.upsert({
     *   create: {
     *     // ... data to create a Nutdata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nutdata we want to update
     *   }
     * })
    **/
    upsert<T extends nutdataUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, nutdataUpsertArgs<ExtArgs>>
    ): Prisma__nutdataClient<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Nutdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutdataCountArgs} args - Arguments to filter Nutdata to count.
     * @example
     * // Count the number of Nutdata
     * const count = await prisma.nutdata.count({
     *   where: {
     *     // ... the filter for the Nutdata we want to count
     *   }
     * })
    **/
    count<T extends nutdataCountArgs>(
      args?: Subset<T, nutdataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutdataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nutdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutdataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutdataAggregateArgs>(args: Subset<T, NutdataAggregateArgs>): Prisma.PrismaPromise<GetNutdataAggregateType<T>>

    /**
     * Group by Nutdata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutdataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutdataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutdataGroupByArgs['orderBy'] }
        : { orderBy?: NutdataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutdataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutdataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for nutdata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__nutdataClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    food<T extends foodArgs<ExtArgs> = {}>(args?: Subset<T, foodArgs<ExtArgs>>): Prisma__foodClient<$Types.GetResult<foodPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    nutrient<T extends nutrientArgs<ExtArgs> = {}>(args?: Subset<T, nutrientArgs<ExtArgs>>): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    source<T extends sourceArgs<ExtArgs> = {}>(args?: Subset<T, sourceArgs<ExtArgs>>): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * nutdata base type for findUnique actions
   */
  export type nutdataFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter, which nutdata to fetch.
     */
    where: nutdataWhereUniqueInput
  }

  /**
   * nutdata findUnique
   */
  export interface nutdataFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends nutdataFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nutdata findUniqueOrThrow
   */
  export type nutdataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter, which nutdata to fetch.
     */
    where: nutdataWhereUniqueInput
  }


  /**
   * nutdata base type for findFirst actions
   */
  export type nutdataFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter, which nutdata to fetch.
     */
    where?: nutdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutdata to fetch.
     */
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutdata.
     */
    cursor?: nutdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutdata.
     */
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }

  /**
   * nutdata findFirst
   */
  export interface nutdataFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends nutdataFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nutdata findFirstOrThrow
   */
  export type nutdataFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter, which nutdata to fetch.
     */
    where?: nutdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutdata to fetch.
     */
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutdata.
     */
    cursor?: nutdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutdata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutdata.
     */
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }


  /**
   * nutdata findMany
   */
  export type nutdataFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter, which nutdata to fetch.
     */
    where?: nutdataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutdata to fetch.
     */
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nutdata.
     */
    cursor?: nutdataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutdata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutdata.
     */
    skip?: number
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }


  /**
   * nutdata create
   */
  export type nutdataCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * The data needed to create a nutdata.
     */
    data: XOR<nutdataCreateInput, nutdataUncheckedCreateInput>
  }


  /**
   * nutdata createMany
   */
  export type nutdataCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nutdata.
     */
    data: Enumerable<nutdataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * nutdata update
   */
  export type nutdataUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * The data needed to update a nutdata.
     */
    data: XOR<nutdataUpdateInput, nutdataUncheckedUpdateInput>
    /**
     * Choose, which nutdata to update.
     */
    where: nutdataWhereUniqueInput
  }


  /**
   * nutdata updateMany
   */
  export type nutdataUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nutdata.
     */
    data: XOR<nutdataUpdateManyMutationInput, nutdataUncheckedUpdateManyInput>
    /**
     * Filter which nutdata to update
     */
    where?: nutdataWhereInput
  }


  /**
   * nutdata upsert
   */
  export type nutdataUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * The filter to search for the nutdata to update in case it exists.
     */
    where: nutdataWhereUniqueInput
    /**
     * In case the nutdata found by the `where` argument doesn't exist, create a new nutdata with this data.
     */
    create: XOR<nutdataCreateInput, nutdataUncheckedCreateInput>
    /**
     * In case the nutdata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nutdataUpdateInput, nutdataUncheckedUpdateInput>
  }


  /**
   * nutdata delete
   */
  export type nutdataDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    /**
     * Filter which nutdata to delete.
     */
    where: nutdataWhereUniqueInput
  }


  /**
   * nutdata deleteMany
   */
  export type nutdataDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutdata to delete
     */
    where?: nutdataWhereInput
  }


  /**
   * nutdata without action
   */
  export type nutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
  }



  /**
   * Model nutrient
   */


  export type AggregateNutrient = {
    _count: NutrientCountAggregateOutputType | null
    _avg: NutrientAvgAggregateOutputType | null
    _sum: NutrientSumAggregateOutputType | null
    _min: NutrientMinAggregateOutputType | null
    _max: NutrientMaxAggregateOutputType | null
  }

  export type NutrientAvgAggregateOutputType = {
    energy_density: Decimal | null
  }

  export type NutrientSumAggregateOutputType = {
    energy_density: Decimal | null
  }

  export type NutrientMinAggregateOutputType = {
    nutr_no: string | null
    created_at: Date | null
    ifda_no: string | null
    unit: string | null
    shrt_desc: string | null
    long_desc: string | null
    energy_density: Decimal | null
  }

  export type NutrientMaxAggregateOutputType = {
    nutr_no: string | null
    created_at: Date | null
    ifda_no: string | null
    unit: string | null
    shrt_desc: string | null
    long_desc: string | null
    energy_density: Decimal | null
  }

  export type NutrientCountAggregateOutputType = {
    nutr_no: number
    created_at: number
    ifda_no: number
    unit: number
    shrt_desc: number
    long_desc: number
    energy_density: number
    _all: number
  }


  export type NutrientAvgAggregateInputType = {
    energy_density?: true
  }

  export type NutrientSumAggregateInputType = {
    energy_density?: true
  }

  export type NutrientMinAggregateInputType = {
    nutr_no?: true
    created_at?: true
    ifda_no?: true
    unit?: true
    shrt_desc?: true
    long_desc?: true
    energy_density?: true
  }

  export type NutrientMaxAggregateInputType = {
    nutr_no?: true
    created_at?: true
    ifda_no?: true
    unit?: true
    shrt_desc?: true
    long_desc?: true
    energy_density?: true
  }

  export type NutrientCountAggregateInputType = {
    nutr_no?: true
    created_at?: true
    ifda_no?: true
    unit?: true
    shrt_desc?: true
    long_desc?: true
    energy_density?: true
    _all?: true
  }

  export type NutrientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutrient to aggregate.
     */
    where?: nutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutrients to fetch.
     */
    orderBy?: Enumerable<nutrientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: nutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nutrients
    **/
    _count?: true | NutrientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutrientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutrientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutrientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutrientMaxAggregateInputType
  }

  export type GetNutrientAggregateType<T extends NutrientAggregateArgs> = {
        [P in keyof T & keyof AggregateNutrient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutrient[P]>
      : GetScalarType<T[P], AggregateNutrient[P]>
  }




  export type NutrientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: nutrientWhereInput
    orderBy?: Enumerable<nutrientOrderByWithAggregationInput>
    by: NutrientScalarFieldEnum[]
    having?: nutrientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutrientCountAggregateInputType | true
    _avg?: NutrientAvgAggregateInputType
    _sum?: NutrientSumAggregateInputType
    _min?: NutrientMinAggregateInputType
    _max?: NutrientMaxAggregateInputType
  }


  export type NutrientGroupByOutputType = {
    nutr_no: string
    created_at: Date | null
    ifda_no: string | null
    unit: string | null
    shrt_desc: string | null
    long_desc: string | null
    energy_density: Decimal | null
    _count: NutrientCountAggregateOutputType | null
    _avg: NutrientAvgAggregateOutputType | null
    _sum: NutrientSumAggregateOutputType | null
    _min: NutrientMinAggregateOutputType | null
    _max: NutrientMaxAggregateOutputType | null
  }

  type GetNutrientGroupByPayload<T extends NutrientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NutrientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutrientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutrientGroupByOutputType[P]>
            : GetScalarType<T[P], NutrientGroupByOutputType[P]>
        }
      >
    >


  export type nutrientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nutr_no?: boolean
    created_at?: boolean
    ifda_no?: boolean
    unit?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    energy_density?: boolean
    nutdata?: boolean | nutrient$nutdataArgs<ExtArgs>
    _count?: boolean | NutrientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["nutrient"]>

  export type nutrientSelectScalar = {
    nutr_no?: boolean
    created_at?: boolean
    ifda_no?: boolean
    unit?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    energy_density?: boolean
  }

  export type nutrientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    nutdata?: boolean | nutrient$nutdataArgs<ExtArgs>
    _count?: boolean | NutrientCountOutputTypeArgs<ExtArgs>
  }


  type nutrientGetPayload<S extends boolean | null | undefined | nutrientArgs> = $Types.GetResult<nutrientPayload, S>

  type nutrientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<nutrientFindManyArgs, 'select' | 'include'> & {
      select?: NutrientCountAggregateInputType | true
    }

  export interface nutrientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['nutrient'], meta: { name: 'nutrient' } }
    /**
     * Find zero or one Nutrient that matches the filter.
     * @param {nutrientFindUniqueArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends nutrientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, nutrientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'nutrient'> extends True ? Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Nutrient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {nutrientFindUniqueOrThrowArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends nutrientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, nutrientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Nutrient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutrientFindFirstArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends nutrientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, nutrientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'nutrient'> extends True ? Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Nutrient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutrientFindFirstOrThrowArgs} args - Arguments to find a Nutrient
     * @example
     * // Get one Nutrient
     * const nutrient = await prisma.nutrient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends nutrientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, nutrientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Nutrients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutrientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nutrients
     * const nutrients = await prisma.nutrient.findMany()
     * 
     * // Get first 10 Nutrients
     * const nutrients = await prisma.nutrient.findMany({ take: 10 })
     * 
     * // Only select the `nutr_no`
     * const nutrientWithNutr_noOnly = await prisma.nutrient.findMany({ select: { nutr_no: true } })
     * 
    **/
    findMany<T extends nutrientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutrientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Nutrient.
     * @param {nutrientCreateArgs} args - Arguments to create a Nutrient.
     * @example
     * // Create one Nutrient
     * const Nutrient = await prisma.nutrient.create({
     *   data: {
     *     // ... data to create a Nutrient
     *   }
     * })
     * 
    **/
    create<T extends nutrientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, nutrientCreateArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Nutrients.
     *     @param {nutrientCreateManyArgs} args - Arguments to create many Nutrients.
     *     @example
     *     // Create many Nutrients
     *     const nutrient = await prisma.nutrient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends nutrientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutrientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Nutrient.
     * @param {nutrientDeleteArgs} args - Arguments to delete one Nutrient.
     * @example
     * // Delete one Nutrient
     * const Nutrient = await prisma.nutrient.delete({
     *   where: {
     *     // ... filter to delete one Nutrient
     *   }
     * })
     * 
    **/
    delete<T extends nutrientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, nutrientDeleteArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Nutrient.
     * @param {nutrientUpdateArgs} args - Arguments to update one Nutrient.
     * @example
     * // Update one Nutrient
     * const nutrient = await prisma.nutrient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends nutrientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, nutrientUpdateArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Nutrients.
     * @param {nutrientDeleteManyArgs} args - Arguments to filter Nutrients to delete.
     * @example
     * // Delete a few Nutrients
     * const { count } = await prisma.nutrient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends nutrientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, nutrientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutrientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nutrients
     * const nutrient = await prisma.nutrient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends nutrientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, nutrientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nutrient.
     * @param {nutrientUpsertArgs} args - Arguments to update or create a Nutrient.
     * @example
     * // Update or create a Nutrient
     * const nutrient = await prisma.nutrient.upsert({
     *   create: {
     *     // ... data to create a Nutrient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nutrient we want to update
     *   }
     * })
    **/
    upsert<T extends nutrientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, nutrientUpsertArgs<ExtArgs>>
    ): Prisma__nutrientClient<$Types.GetResult<nutrientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Nutrients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nutrientCountArgs} args - Arguments to filter Nutrients to count.
     * @example
     * // Count the number of Nutrients
     * const count = await prisma.nutrient.count({
     *   where: {
     *     // ... the filter for the Nutrients we want to count
     *   }
     * })
    **/
    count<T extends nutrientCountArgs>(
      args?: Subset<T, nutrientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutrientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutrientAggregateArgs>(args: Subset<T, NutrientAggregateArgs>): Prisma.PrismaPromise<GetNutrientAggregateType<T>>

    /**
     * Group by Nutrient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutrientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutrientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutrientGroupByArgs['orderBy'] }
        : { orderBy?: NutrientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutrientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutrientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for nutrient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__nutrientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    nutdata<T extends nutrient$nutdataArgs<ExtArgs> = {}>(args?: Subset<T, nutrient$nutdataArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * nutrient base type for findUnique actions
   */
  export type nutrientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter, which nutrient to fetch.
     */
    where: nutrientWhereUniqueInput
  }

  /**
   * nutrient findUnique
   */
  export interface nutrientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends nutrientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nutrient findUniqueOrThrow
   */
  export type nutrientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter, which nutrient to fetch.
     */
    where: nutrientWhereUniqueInput
  }


  /**
   * nutrient base type for findFirst actions
   */
  export type nutrientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter, which nutrient to fetch.
     */
    where?: nutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutrients to fetch.
     */
    orderBy?: Enumerable<nutrientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutrients.
     */
    cursor?: nutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutrients.
     */
    distinct?: Enumerable<NutrientScalarFieldEnum>
  }

  /**
   * nutrient findFirst
   */
  export interface nutrientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends nutrientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nutrient findFirstOrThrow
   */
  export type nutrientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter, which nutrient to fetch.
     */
    where?: nutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutrients to fetch.
     */
    orderBy?: Enumerable<nutrientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nutrients.
     */
    cursor?: nutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutrients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nutrients.
     */
    distinct?: Enumerable<NutrientScalarFieldEnum>
  }


  /**
   * nutrient findMany
   */
  export type nutrientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter, which nutrients to fetch.
     */
    where?: nutrientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nutrients to fetch.
     */
    orderBy?: Enumerable<nutrientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nutrients.
     */
    cursor?: nutrientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nutrients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nutrients.
     */
    skip?: number
    distinct?: Enumerable<NutrientScalarFieldEnum>
  }


  /**
   * nutrient create
   */
  export type nutrientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * The data needed to create a nutrient.
     */
    data: XOR<nutrientCreateInput, nutrientUncheckedCreateInput>
  }


  /**
   * nutrient createMany
   */
  export type nutrientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many nutrients.
     */
    data: Enumerable<nutrientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * nutrient update
   */
  export type nutrientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * The data needed to update a nutrient.
     */
    data: XOR<nutrientUpdateInput, nutrientUncheckedUpdateInput>
    /**
     * Choose, which nutrient to update.
     */
    where: nutrientWhereUniqueInput
  }


  /**
   * nutrient updateMany
   */
  export type nutrientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update nutrients.
     */
    data: XOR<nutrientUpdateManyMutationInput, nutrientUncheckedUpdateManyInput>
    /**
     * Filter which nutrients to update
     */
    where?: nutrientWhereInput
  }


  /**
   * nutrient upsert
   */
  export type nutrientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * The filter to search for the nutrient to update in case it exists.
     */
    where: nutrientWhereUniqueInput
    /**
     * In case the nutrient found by the `where` argument doesn't exist, create a new nutrient with this data.
     */
    create: XOR<nutrientCreateInput, nutrientUncheckedCreateInput>
    /**
     * In case the nutrient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<nutrientUpdateInput, nutrientUncheckedUpdateInput>
  }


  /**
   * nutrient delete
   */
  export type nutrientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
    /**
     * Filter which nutrient to delete.
     */
    where: nutrientWhereUniqueInput
  }


  /**
   * nutrient deleteMany
   */
  export type nutrientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which nutrients to delete
     */
    where?: nutrientWhereInput
  }


  /**
   * nutrient.nutdata
   */
  export type nutrient$nutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    where?: nutdataWhereInput
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    cursor?: nutdataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }


  /**
   * nutrient without action
   */
  export type nutrientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutrient
     */
    select?: nutrientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutrientInclude<ExtArgs> | null
  }



  /**
   * Model source
   */


  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceAvgAggregateOutputType = {
    id: number | null
  }

  export type SourceSumAggregateOutputType = {
    id: number | null
  }

  export type SourceMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    created_at: number
    shrt_desc: number
    long_desc: number
    _all: number
  }


  export type SourceAvgAggregateInputType = {
    id?: true
  }

  export type SourceSumAggregateInputType = {
    id?: true
  }

  export type SourceMinAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which source to aggregate.
     */
    where?: sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sources to fetch.
     */
    orderBy?: Enumerable<sourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: sourceWhereInput
    orderBy?: Enumerable<sourceOrderByWithAggregationInput>
    by: SourceScalarFieldEnum[]
    having?: sourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _avg?: SourceAvgAggregateInputType
    _sum?: SourceSumAggregateInputType
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }


  export type SourceGroupByOutputType = {
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type sourceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    foods?: boolean | source$foodsArgs<ExtArgs>
    nutdata?: boolean | source$nutdataArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type sourceSelectScalar = {
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
  }

  export type sourceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    foods?: boolean | source$foodsArgs<ExtArgs>
    nutdata?: boolean | source$nutdataArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeArgs<ExtArgs>
  }


  type sourceGetPayload<S extends boolean | null | undefined | sourceArgs> = $Types.GetResult<sourcePayload, S>

  type sourceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<sourceFindManyArgs, 'select' | 'include'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface sourceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['source'], meta: { name: 'source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {sourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sourceFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sourceFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'source'> extends True ? Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Source that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sourceFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sourceFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'source'> extends True ? Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Source that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<sourcePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Source.
     * @param {sourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
    **/
    create<T extends sourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sourceCreateArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Sources.
     *     @param {sourceCreateManyArgs} args - Arguments to create many Sources.
     *     @example
     *     // Create many Sources
     *     const source = await prisma.source.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Source.
     * @param {sourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
    **/
    delete<T extends sourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sourceDeleteArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Source.
     * @param {sourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sourceUpdateArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Sources.
     * @param {sourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Source.
     * @param {sourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
    **/
    upsert<T extends sourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sourceUpsertArgs<ExtArgs>>
    ): Prisma__sourceClient<$Types.GetResult<sourcePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends sourceCountArgs>(
      args?: Subset<T, sourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sourceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    foods<T extends source$foodsArgs<ExtArgs> = {}>(args?: Subset<T, source$foodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<foodPayload<ExtArgs>, T, 'findMany', never>| Null>;

    nutdata<T extends source$nutdataArgs<ExtArgs> = {}>(args?: Subset<T, source$nutdataArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<nutdataPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * source base type for findUnique actions
   */
  export type sourceFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter, which source to fetch.
     */
    where: sourceWhereUniqueInput
  }

  /**
   * source findUnique
   */
  export interface sourceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sourceFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * source findUniqueOrThrow
   */
  export type sourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter, which source to fetch.
     */
    where: sourceWhereUniqueInput
  }


  /**
   * source base type for findFirst actions
   */
  export type sourceFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter, which source to fetch.
     */
    where?: sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sources to fetch.
     */
    orderBy?: Enumerable<sourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sources.
     */
    cursor?: sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sources.
     */
    distinct?: Enumerable<SourceScalarFieldEnum>
  }

  /**
   * source findFirst
   */
  export interface sourceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends sourceFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * source findFirstOrThrow
   */
  export type sourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter, which source to fetch.
     */
    where?: sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sources to fetch.
     */
    orderBy?: Enumerable<sourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sources.
     */
    cursor?: sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sources.
     */
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * source findMany
   */
  export type sourceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter, which sources to fetch.
     */
    where?: sourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sources to fetch.
     */
    orderBy?: Enumerable<sourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sources.
     */
    cursor?: sourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sources.
     */
    skip?: number
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * source create
   */
  export type sourceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * The data needed to create a source.
     */
    data: XOR<sourceCreateInput, sourceUncheckedCreateInput>
  }


  /**
   * source createMany
   */
  export type sourceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sources.
     */
    data: Enumerable<sourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * source update
   */
  export type sourceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * The data needed to update a source.
     */
    data: XOR<sourceUpdateInput, sourceUncheckedUpdateInput>
    /**
     * Choose, which source to update.
     */
    where: sourceWhereUniqueInput
  }


  /**
   * source updateMany
   */
  export type sourceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sources.
     */
    data: XOR<sourceUpdateManyMutationInput, sourceUncheckedUpdateManyInput>
    /**
     * Filter which sources to update
     */
    where?: sourceWhereInput
  }


  /**
   * source upsert
   */
  export type sourceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * The filter to search for the source to update in case it exists.
     */
    where: sourceWhereUniqueInput
    /**
     * In case the source found by the `where` argument doesn't exist, create a new source with this data.
     */
    create: XOR<sourceCreateInput, sourceUncheckedCreateInput>
    /**
     * In case the source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sourceUpdateInput, sourceUncheckedUpdateInput>
  }


  /**
   * source delete
   */
  export type sourceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
    /**
     * Filter which source to delete.
     */
    where: sourceWhereUniqueInput
  }


  /**
   * source deleteMany
   */
  export type sourceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which sources to delete
     */
    where?: sourceWhereInput
  }


  /**
   * source.foods
   */
  export type source$foodsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the food
     */
    select?: foodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foodInclude<ExtArgs> | null
    where?: foodWhereInput
    orderBy?: Enumerable<foodOrderByWithRelationInput>
    cursor?: foodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FoodScalarFieldEnum>
  }


  /**
   * source.nutdata
   */
  export type source$nutdataArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the nutdata
     */
    select?: nutdataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: nutdataInclude<ExtArgs> | null
    where?: nutdataWhereInput
    orderBy?: Enumerable<nutdataOrderByWithRelationInput>
    cursor?: nutdataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NutdataScalarFieldEnum>
  }


  /**
   * source without action
   */
  export type sourceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the source
     */
    select?: sourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sourceInclude<ExtArgs> | null
  }



  /**
   * Model dish
   */


  export type AggregateDish = {
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  export type DishAvgAggregateOutputType = {
    id: number | null
    nbpersonnes: number | null
    maxqty: number | null
  }

  export type DishSumAggregateOutputType = {
    id: number | null
    nbpersonnes: number | null
    maxqty: number | null
  }

  export type DishMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    pict: string | null
    note: string | null
    shrt_source: string | null
    long_source: string | null
    qty_max: string | null
    resume: string | null
    recette: string | null
    nbpersonnes: number | null
    qte: string | null
    diabete: string | null
    cardiaque: string | null
    obese: string | null
    ssel: string | null
    chol: string | null
    trigly: string | null
    maxqty: number | null
  }

  export type DishMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    shrt_desc: string | null
    long_desc: string | null
    pict: string | null
    note: string | null
    shrt_source: string | null
    long_source: string | null
    qty_max: string | null
    resume: string | null
    recette: string | null
    nbpersonnes: number | null
    qte: string | null
    diabete: string | null
    cardiaque: string | null
    obese: string | null
    ssel: string | null
    chol: string | null
    trigly: string | null
    maxqty: number | null
  }

  export type DishCountAggregateOutputType = {
    id: number
    created_at: number
    shrt_desc: number
    long_desc: number
    pict: number
    note: number
    shrt_source: number
    long_source: number
    qty_max: number
    resume: number
    recette: number
    nbpersonnes: number
    qte: number
    diabete: number
    cardiaque: number
    obese: number
    ssel: number
    chol: number
    trigly: number
    maxqty: number
    _all: number
  }


  export type DishAvgAggregateInputType = {
    id?: true
    nbpersonnes?: true
    maxqty?: true
  }

  export type DishSumAggregateInputType = {
    id?: true
    nbpersonnes?: true
    maxqty?: true
  }

  export type DishMinAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    pict?: true
    note?: true
    shrt_source?: true
    long_source?: true
    qty_max?: true
    resume?: true
    recette?: true
    nbpersonnes?: true
    qte?: true
    diabete?: true
    cardiaque?: true
    obese?: true
    ssel?: true
    chol?: true
    trigly?: true
    maxqty?: true
  }

  export type DishMaxAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    pict?: true
    note?: true
    shrt_source?: true
    long_source?: true
    qty_max?: true
    resume?: true
    recette?: true
    nbpersonnes?: true
    qte?: true
    diabete?: true
    cardiaque?: true
    obese?: true
    ssel?: true
    chol?: true
    trigly?: true
    maxqty?: true
  }

  export type DishCountAggregateInputType = {
    id?: true
    created_at?: true
    shrt_desc?: true
    long_desc?: true
    pict?: true
    note?: true
    shrt_source?: true
    long_source?: true
    qty_max?: true
    resume?: true
    recette?: true
    nbpersonnes?: true
    qte?: true
    diabete?: true
    cardiaque?: true
    obese?: true
    ssel?: true
    chol?: true
    trigly?: true
    maxqty?: true
    _all?: true
  }

  export type DishAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dish to aggregate.
     */
    where?: dishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dishes to fetch.
     */
    orderBy?: Enumerable<dishOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dishes
    **/
    _count?: true | DishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishMaxAggregateInputType
  }

  export type GetDishAggregateType<T extends DishAggregateArgs> = {
        [P in keyof T & keyof AggregateDish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDish[P]>
      : GetScalarType<T[P], AggregateDish[P]>
  }




  export type DishGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: dishWhereInput
    orderBy?: Enumerable<dishOrderByWithAggregationInput>
    by: DishScalarFieldEnum[]
    having?: dishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishCountAggregateInputType | true
    _avg?: DishAvgAggregateInputType
    _sum?: DishSumAggregateInputType
    _min?: DishMinAggregateInputType
    _max?: DishMaxAggregateInputType
  }


  export type DishGroupByOutputType = {
    id: number
    created_at: Date | null
    shrt_desc: string
    long_desc: string | null
    pict: string | null
    note: string | null
    shrt_source: string
    long_source: string | null
    qty_max: string | null
    resume: string | null
    recette: string | null
    nbpersonnes: number
    qte: string
    diabete: string
    cardiaque: string
    obese: string
    ssel: string
    chol: string
    trigly: string
    maxqty: number
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  type GetDishGroupByPayload<T extends DishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishGroupByOutputType[P]>
            : GetScalarType<T[P], DishGroupByOutputType[P]>
        }
      >
    >


  export type dishSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    pict?: boolean
    note?: boolean
    shrt_source?: boolean
    long_source?: boolean
    qty_max?: boolean
    resume?: boolean
    recette?: boolean
    nbpersonnes?: boolean
    qte?: boolean
    diabete?: boolean
    cardiaque?: boolean
    obese?: boolean
    ssel?: boolean
    chol?: boolean
    trigly?: boolean
    maxqty?: boolean
  }, ExtArgs["result"]["dish"]>

  export type dishSelectScalar = {
    id?: boolean
    created_at?: boolean
    shrt_desc?: boolean
    long_desc?: boolean
    pict?: boolean
    note?: boolean
    shrt_source?: boolean
    long_source?: boolean
    qty_max?: boolean
    resume?: boolean
    recette?: boolean
    nbpersonnes?: boolean
    qte?: boolean
    diabete?: boolean
    cardiaque?: boolean
    obese?: boolean
    ssel?: boolean
    chol?: boolean
    trigly?: boolean
    maxqty?: boolean
  }


  type dishGetPayload<S extends boolean | null | undefined | dishArgs> = $Types.GetResult<dishPayload, S>

  type dishCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<dishFindManyArgs, 'select' | 'include'> & {
      select?: DishCountAggregateInputType | true
    }

  export interface dishDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dish'], meta: { name: 'dish' } }
    /**
     * Find zero or one Dish that matches the filter.
     * @param {dishFindUniqueArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends dishFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, dishFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'dish'> extends True ? Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Dish that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {dishFindUniqueOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends dishFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dishFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Dish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dishFindFirstArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends dishFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, dishFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'dish'> extends True ? Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Dish that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dishFindFirstOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends dishFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, dishFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Dishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dishFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dishes
     * const dishes = await prisma.dish.findMany()
     * 
     * // Get first 10 Dishes
     * const dishes = await prisma.dish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dishWithIdOnly = await prisma.dish.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends dishFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dishFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<dishPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Dish.
     * @param {dishCreateArgs} args - Arguments to create a Dish.
     * @example
     * // Create one Dish
     * const Dish = await prisma.dish.create({
     *   data: {
     *     // ... data to create a Dish
     *   }
     * })
     * 
    **/
    create<T extends dishCreateArgs<ExtArgs>>(
      args: SelectSubset<T, dishCreateArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Dishes.
     *     @param {dishCreateManyArgs} args - Arguments to create many Dishes.
     *     @example
     *     // Create many Dishes
     *     const dish = await prisma.dish.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends dishCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dishCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dish.
     * @param {dishDeleteArgs} args - Arguments to delete one Dish.
     * @example
     * // Delete one Dish
     * const Dish = await prisma.dish.delete({
     *   where: {
     *     // ... filter to delete one Dish
     *   }
     * })
     * 
    **/
    delete<T extends dishDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, dishDeleteArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Dish.
     * @param {dishUpdateArgs} args - Arguments to update one Dish.
     * @example
     * // Update one Dish
     * const dish = await prisma.dish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends dishUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, dishUpdateArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Dishes.
     * @param {dishDeleteManyArgs} args - Arguments to filter Dishes to delete.
     * @example
     * // Delete a few Dishes
     * const { count } = await prisma.dish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends dishDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, dishDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends dishUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, dishUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dish.
     * @param {dishUpsertArgs} args - Arguments to update or create a Dish.
     * @example
     * // Update or create a Dish
     * const dish = await prisma.dish.upsert({
     *   create: {
     *     // ... data to create a Dish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dish we want to update
     *   }
     * })
    **/
    upsert<T extends dishUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, dishUpsertArgs<ExtArgs>>
    ): Prisma__dishClient<$Types.GetResult<dishPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dishCountArgs} args - Arguments to filter Dishes to count.
     * @example
     * // Count the number of Dishes
     * const count = await prisma.dish.count({
     *   where: {
     *     // ... the filter for the Dishes we want to count
     *   }
     * })
    **/
    count<T extends dishCountArgs>(
      args?: Subset<T, dishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishAggregateArgs>(args: Subset<T, DishAggregateArgs>): Prisma.PrismaPromise<GetDishAggregateType<T>>

    /**
     * Group by Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishGroupByArgs['orderBy'] }
        : { orderBy?: DishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for dish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__dishClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * dish base type for findUnique actions
   */
  export type dishFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter, which dish to fetch.
     */
    where: dishWhereUniqueInput
  }

  /**
   * dish findUnique
   */
  export interface dishFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends dishFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dish findUniqueOrThrow
   */
  export type dishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter, which dish to fetch.
     */
    where: dishWhereUniqueInput
  }


  /**
   * dish base type for findFirst actions
   */
  export type dishFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter, which dish to fetch.
     */
    where?: dishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dishes to fetch.
     */
    orderBy?: Enumerable<dishOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dishes.
     */
    cursor?: dishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dishes.
     */
    distinct?: Enumerable<DishScalarFieldEnum>
  }

  /**
   * dish findFirst
   */
  export interface dishFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends dishFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * dish findFirstOrThrow
   */
  export type dishFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter, which dish to fetch.
     */
    where?: dishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dishes to fetch.
     */
    orderBy?: Enumerable<dishOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dishes.
     */
    cursor?: dishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dishes.
     */
    distinct?: Enumerable<DishScalarFieldEnum>
  }


  /**
   * dish findMany
   */
  export type dishFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter, which dishes to fetch.
     */
    where?: dishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dishes to fetch.
     */
    orderBy?: Enumerable<dishOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dishes.
     */
    cursor?: dishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dishes.
     */
    skip?: number
    distinct?: Enumerable<DishScalarFieldEnum>
  }


  /**
   * dish create
   */
  export type dishCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * The data needed to create a dish.
     */
    data: XOR<dishCreateInput, dishUncheckedCreateInput>
  }


  /**
   * dish createMany
   */
  export type dishCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dishes.
     */
    data: Enumerable<dishCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * dish update
   */
  export type dishUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * The data needed to update a dish.
     */
    data: XOR<dishUpdateInput, dishUncheckedUpdateInput>
    /**
     * Choose, which dish to update.
     */
    where: dishWhereUniqueInput
  }


  /**
   * dish updateMany
   */
  export type dishUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dishes.
     */
    data: XOR<dishUpdateManyMutationInput, dishUncheckedUpdateManyInput>
    /**
     * Filter which dishes to update
     */
    where?: dishWhereInput
  }


  /**
   * dish upsert
   */
  export type dishUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * The filter to search for the dish to update in case it exists.
     */
    where: dishWhereUniqueInput
    /**
     * In case the dish found by the `where` argument doesn't exist, create a new dish with this data.
     */
    create: XOR<dishCreateInput, dishUncheckedCreateInput>
    /**
     * In case the dish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dishUpdateInput, dishUncheckedUpdateInput>
  }


  /**
   * dish delete
   */
  export type dishDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
    /**
     * Filter which dish to delete.
     */
    where: dishWhereUniqueInput
  }


  /**
   * dish deleteMany
   */
  export type dishDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which dishes to delete
     */
    where?: dishWhereInput
  }


  /**
   * dish without action
   */
  export type dishArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dish
     */
    select?: dishSelect<ExtArgs> | null
  }



  /**
   * Model lexicon
   */


  export type AggregateLexicon = {
    _count: LexiconCountAggregateOutputType | null
    _avg: LexiconAvgAggregateOutputType | null
    _sum: LexiconSumAggregateOutputType | null
    _min: LexiconMinAggregateOutputType | null
    _max: LexiconMaxAggregateOutputType | null
  }

  export type LexiconAvgAggregateOutputType = {
    id: number | null
  }

  export type LexiconSumAggregateOutputType = {
    id: number | null
  }

  export type LexiconMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    code: string | null
    title: string | null
    text: string | null
  }

  export type LexiconMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    code: string | null
    title: string | null
    text: string | null
  }

  export type LexiconCountAggregateOutputType = {
    id: number
    created_at: number
    code: number
    title: number
    text: number
    _all: number
  }


  export type LexiconAvgAggregateInputType = {
    id?: true
  }

  export type LexiconSumAggregateInputType = {
    id?: true
  }

  export type LexiconMinAggregateInputType = {
    id?: true
    created_at?: true
    code?: true
    title?: true
    text?: true
  }

  export type LexiconMaxAggregateInputType = {
    id?: true
    created_at?: true
    code?: true
    title?: true
    text?: true
  }

  export type LexiconCountAggregateInputType = {
    id?: true
    created_at?: true
    code?: true
    title?: true
    text?: true
    _all?: true
  }

  export type LexiconAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which lexicon to aggregate.
     */
    where?: lexiconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lexicons to fetch.
     */
    orderBy?: Enumerable<lexiconOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lexiconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lexicons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lexicons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lexicons
    **/
    _count?: true | LexiconCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LexiconAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LexiconSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LexiconMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LexiconMaxAggregateInputType
  }

  export type GetLexiconAggregateType<T extends LexiconAggregateArgs> = {
        [P in keyof T & keyof AggregateLexicon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLexicon[P]>
      : GetScalarType<T[P], AggregateLexicon[P]>
  }




  export type LexiconGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: lexiconWhereInput
    orderBy?: Enumerable<lexiconOrderByWithAggregationInput>
    by: LexiconScalarFieldEnum[]
    having?: lexiconScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LexiconCountAggregateInputType | true
    _avg?: LexiconAvgAggregateInputType
    _sum?: LexiconSumAggregateInputType
    _min?: LexiconMinAggregateInputType
    _max?: LexiconMaxAggregateInputType
  }


  export type LexiconGroupByOutputType = {
    id: number
    created_at: Date | null
    code: string
    title: string
    text: string
    _count: LexiconCountAggregateOutputType | null
    _avg: LexiconAvgAggregateOutputType | null
    _sum: LexiconSumAggregateOutputType | null
    _min: LexiconMinAggregateOutputType | null
    _max: LexiconMaxAggregateOutputType | null
  }

  type GetLexiconGroupByPayload<T extends LexiconGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LexiconGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LexiconGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LexiconGroupByOutputType[P]>
            : GetScalarType<T[P], LexiconGroupByOutputType[P]>
        }
      >
    >


  export type lexiconSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    code?: boolean
    title?: boolean
    text?: boolean
  }, ExtArgs["result"]["lexicon"]>

  export type lexiconSelectScalar = {
    id?: boolean
    created_at?: boolean
    code?: boolean
    title?: boolean
    text?: boolean
  }


  type lexiconGetPayload<S extends boolean | null | undefined | lexiconArgs> = $Types.GetResult<lexiconPayload, S>

  type lexiconCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<lexiconFindManyArgs, 'select' | 'include'> & {
      select?: LexiconCountAggregateInputType | true
    }

  export interface lexiconDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lexicon'], meta: { name: 'lexicon' } }
    /**
     * Find zero or one Lexicon that matches the filter.
     * @param {lexiconFindUniqueArgs} args - Arguments to find a Lexicon
     * @example
     * // Get one Lexicon
     * const lexicon = await prisma.lexicon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends lexiconFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, lexiconFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'lexicon'> extends True ? Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Lexicon that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {lexiconFindUniqueOrThrowArgs} args - Arguments to find a Lexicon
     * @example
     * // Get one Lexicon
     * const lexicon = await prisma.lexicon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends lexiconFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lexiconFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Lexicon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lexiconFindFirstArgs} args - Arguments to find a Lexicon
     * @example
     * // Get one Lexicon
     * const lexicon = await prisma.lexicon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends lexiconFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, lexiconFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'lexicon'> extends True ? Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Lexicon that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lexiconFindFirstOrThrowArgs} args - Arguments to find a Lexicon
     * @example
     * // Get one Lexicon
     * const lexicon = await prisma.lexicon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends lexiconFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, lexiconFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Lexicons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lexiconFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lexicons
     * const lexicons = await prisma.lexicon.findMany()
     * 
     * // Get first 10 Lexicons
     * const lexicons = await prisma.lexicon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lexiconWithIdOnly = await prisma.lexicon.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends lexiconFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lexiconFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Lexicon.
     * @param {lexiconCreateArgs} args - Arguments to create a Lexicon.
     * @example
     * // Create one Lexicon
     * const Lexicon = await prisma.lexicon.create({
     *   data: {
     *     // ... data to create a Lexicon
     *   }
     * })
     * 
    **/
    create<T extends lexiconCreateArgs<ExtArgs>>(
      args: SelectSubset<T, lexiconCreateArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Lexicons.
     *     @param {lexiconCreateManyArgs} args - Arguments to create many Lexicons.
     *     @example
     *     // Create many Lexicons
     *     const lexicon = await prisma.lexicon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends lexiconCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lexiconCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lexicon.
     * @param {lexiconDeleteArgs} args - Arguments to delete one Lexicon.
     * @example
     * // Delete one Lexicon
     * const Lexicon = await prisma.lexicon.delete({
     *   where: {
     *     // ... filter to delete one Lexicon
     *   }
     * })
     * 
    **/
    delete<T extends lexiconDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, lexiconDeleteArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Lexicon.
     * @param {lexiconUpdateArgs} args - Arguments to update one Lexicon.
     * @example
     * // Update one Lexicon
     * const lexicon = await prisma.lexicon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends lexiconUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, lexiconUpdateArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Lexicons.
     * @param {lexiconDeleteManyArgs} args - Arguments to filter Lexicons to delete.
     * @example
     * // Delete a few Lexicons
     * const { count } = await prisma.lexicon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends lexiconDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, lexiconDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lexicons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lexiconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lexicons
     * const lexicon = await prisma.lexicon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends lexiconUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, lexiconUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lexicon.
     * @param {lexiconUpsertArgs} args - Arguments to update or create a Lexicon.
     * @example
     * // Update or create a Lexicon
     * const lexicon = await prisma.lexicon.upsert({
     *   create: {
     *     // ... data to create a Lexicon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lexicon we want to update
     *   }
     * })
    **/
    upsert<T extends lexiconUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, lexiconUpsertArgs<ExtArgs>>
    ): Prisma__lexiconClient<$Types.GetResult<lexiconPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Lexicons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lexiconCountArgs} args - Arguments to filter Lexicons to count.
     * @example
     * // Count the number of Lexicons
     * const count = await prisma.lexicon.count({
     *   where: {
     *     // ... the filter for the Lexicons we want to count
     *   }
     * })
    **/
    count<T extends lexiconCountArgs>(
      args?: Subset<T, lexiconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LexiconCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lexicon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LexiconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LexiconAggregateArgs>(args: Subset<T, LexiconAggregateArgs>): Prisma.PrismaPromise<GetLexiconAggregateType<T>>

    /**
     * Group by Lexicon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LexiconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LexiconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LexiconGroupByArgs['orderBy'] }
        : { orderBy?: LexiconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LexiconGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLexiconGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for lexicon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__lexiconClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * lexicon base type for findUnique actions
   */
  export type lexiconFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter, which lexicon to fetch.
     */
    where: lexiconWhereUniqueInput
  }

  /**
   * lexicon findUnique
   */
  export interface lexiconFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends lexiconFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lexicon findUniqueOrThrow
   */
  export type lexiconFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter, which lexicon to fetch.
     */
    where: lexiconWhereUniqueInput
  }


  /**
   * lexicon base type for findFirst actions
   */
  export type lexiconFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter, which lexicon to fetch.
     */
    where?: lexiconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lexicons to fetch.
     */
    orderBy?: Enumerable<lexiconOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lexicons.
     */
    cursor?: lexiconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lexicons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lexicons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lexicons.
     */
    distinct?: Enumerable<LexiconScalarFieldEnum>
  }

  /**
   * lexicon findFirst
   */
  export interface lexiconFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends lexiconFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * lexicon findFirstOrThrow
   */
  export type lexiconFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter, which lexicon to fetch.
     */
    where?: lexiconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lexicons to fetch.
     */
    orderBy?: Enumerable<lexiconOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lexicons.
     */
    cursor?: lexiconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lexicons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lexicons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lexicons.
     */
    distinct?: Enumerable<LexiconScalarFieldEnum>
  }


  /**
   * lexicon findMany
   */
  export type lexiconFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter, which lexicons to fetch.
     */
    where?: lexiconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lexicons to fetch.
     */
    orderBy?: Enumerable<lexiconOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lexicons.
     */
    cursor?: lexiconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lexicons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lexicons.
     */
    skip?: number
    distinct?: Enumerable<LexiconScalarFieldEnum>
  }


  /**
   * lexicon create
   */
  export type lexiconCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * The data needed to create a lexicon.
     */
    data: XOR<lexiconCreateInput, lexiconUncheckedCreateInput>
  }


  /**
   * lexicon createMany
   */
  export type lexiconCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lexicons.
     */
    data: Enumerable<lexiconCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * lexicon update
   */
  export type lexiconUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * The data needed to update a lexicon.
     */
    data: XOR<lexiconUpdateInput, lexiconUncheckedUpdateInput>
    /**
     * Choose, which lexicon to update.
     */
    where: lexiconWhereUniqueInput
  }


  /**
   * lexicon updateMany
   */
  export type lexiconUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lexicons.
     */
    data: XOR<lexiconUpdateManyMutationInput, lexiconUncheckedUpdateManyInput>
    /**
     * Filter which lexicons to update
     */
    where?: lexiconWhereInput
  }


  /**
   * lexicon upsert
   */
  export type lexiconUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * The filter to search for the lexicon to update in case it exists.
     */
    where: lexiconWhereUniqueInput
    /**
     * In case the lexicon found by the `where` argument doesn't exist, create a new lexicon with this data.
     */
    create: XOR<lexiconCreateInput, lexiconUncheckedCreateInput>
    /**
     * In case the lexicon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lexiconUpdateInput, lexiconUncheckedUpdateInput>
  }


  /**
   * lexicon delete
   */
  export type lexiconDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
    /**
     * Filter which lexicon to delete.
     */
    where: lexiconWhereUniqueInput
  }


  /**
   * lexicon deleteMany
   */
  export type lexiconDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which lexicons to delete
     */
    where?: lexiconWhereInput
  }


  /**
   * lexicon without action
   */
  export type lexiconArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lexicon
     */
    select?: lexiconSelect<ExtArgs> | null
  }



  /**
   * Model qcu_image
   */


  export type AggregateQcu_image = {
    _count: Qcu_imageCountAggregateOutputType | null
    _avg: Qcu_imageAvgAggregateOutputType | null
    _sum: Qcu_imageSumAggregateOutputType | null
    _min: Qcu_imageMinAggregateOutputType | null
    _max: Qcu_imageMaxAggregateOutputType | null
  }

  export type Qcu_imageAvgAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type Qcu_imageSumAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type Qcu_imageMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    pict: string | null
    question_id: number | null
  }

  export type Qcu_imageMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    pict: string | null
    question_id: number | null
  }

  export type Qcu_imageCountAggregateOutputType = {
    id: number
    created_at: number
    pict: number
    question_id: number
    _all: number
  }


  export type Qcu_imageAvgAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type Qcu_imageSumAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type Qcu_imageMinAggregateInputType = {
    id?: true
    created_at?: true
    pict?: true
    question_id?: true
  }

  export type Qcu_imageMaxAggregateInputType = {
    id?: true
    created_at?: true
    pict?: true
    question_id?: true
  }

  export type Qcu_imageCountAggregateInputType = {
    id?: true
    created_at?: true
    pict?: true
    question_id?: true
    _all?: true
  }

  export type Qcu_imageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_image to aggregate.
     */
    where?: qcu_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_images to fetch.
     */
    orderBy?: Enumerable<qcu_imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qcu_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qcu_images
    **/
    _count?: true | Qcu_imageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qcu_imageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qcu_imageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qcu_imageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qcu_imageMaxAggregateInputType
  }

  export type GetQcu_imageAggregateType<T extends Qcu_imageAggregateArgs> = {
        [P in keyof T & keyof AggregateQcu_image]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcu_image[P]>
      : GetScalarType<T[P], AggregateQcu_image[P]>
  }




  export type Qcu_imageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: qcu_imageWhereInput
    orderBy?: Enumerable<qcu_imageOrderByWithAggregationInput>
    by: Qcu_imageScalarFieldEnum[]
    having?: qcu_imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qcu_imageCountAggregateInputType | true
    _avg?: Qcu_imageAvgAggregateInputType
    _sum?: Qcu_imageSumAggregateInputType
    _min?: Qcu_imageMinAggregateInputType
    _max?: Qcu_imageMaxAggregateInputType
  }


  export type Qcu_imageGroupByOutputType = {
    id: number
    created_at: Date | null
    pict: string
    question_id: number
    _count: Qcu_imageCountAggregateOutputType | null
    _avg: Qcu_imageAvgAggregateOutputType | null
    _sum: Qcu_imageSumAggregateOutputType | null
    _min: Qcu_imageMinAggregateOutputType | null
    _max: Qcu_imageMaxAggregateOutputType | null
  }

  type GetQcu_imageGroupByPayload<T extends Qcu_imageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Qcu_imageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qcu_imageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qcu_imageGroupByOutputType[P]>
            : GetScalarType<T[P], Qcu_imageGroupByOutputType[P]>
        }
      >
    >


  export type qcu_imageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    pict?: boolean
    question_id?: boolean
    question?: boolean | qcu_questionArgs<ExtArgs>
  }, ExtArgs["result"]["qcu_image"]>

  export type qcu_imageSelectScalar = {
    id?: boolean
    created_at?: boolean
    pict?: boolean
    question_id?: boolean
  }

  export type qcu_imageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    question?: boolean | qcu_questionArgs<ExtArgs>
  }


  type qcu_imageGetPayload<S extends boolean | null | undefined | qcu_imageArgs> = $Types.GetResult<qcu_imagePayload, S>

  type qcu_imageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<qcu_imageFindManyArgs, 'select' | 'include'> & {
      select?: Qcu_imageCountAggregateInputType | true
    }

  export interface qcu_imageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qcu_image'], meta: { name: 'qcu_image' } }
    /**
     * Find zero or one Qcu_image that matches the filter.
     * @param {qcu_imageFindUniqueArgs} args - Arguments to find a Qcu_image
     * @example
     * // Get one Qcu_image
     * const qcu_image = await prisma.qcu_image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qcu_imageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, qcu_imageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'qcu_image'> extends True ? Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Qcu_image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {qcu_imageFindUniqueOrThrowArgs} args - Arguments to find a Qcu_image
     * @example
     * // Get one Qcu_image
     * const qcu_image = await prisma.qcu_image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends qcu_imageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_imageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Qcu_image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_imageFindFirstArgs} args - Arguments to find a Qcu_image
     * @example
     * // Get one Qcu_image
     * const qcu_image = await prisma.qcu_image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qcu_imageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, qcu_imageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'qcu_image'> extends True ? Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Qcu_image that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_imageFindFirstOrThrowArgs} args - Arguments to find a Qcu_image
     * @example
     * // Get one Qcu_image
     * const qcu_image = await prisma.qcu_image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends qcu_imageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_imageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Qcu_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_imageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qcu_images
     * const qcu_images = await prisma.qcu_image.findMany()
     * 
     * // Get first 10 Qcu_images
     * const qcu_images = await prisma.qcu_image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcu_imageWithIdOnly = await prisma.qcu_image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends qcu_imageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_imageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Qcu_image.
     * @param {qcu_imageCreateArgs} args - Arguments to create a Qcu_image.
     * @example
     * // Create one Qcu_image
     * const Qcu_image = await prisma.qcu_image.create({
     *   data: {
     *     // ... data to create a Qcu_image
     *   }
     * })
     * 
    **/
    create<T extends qcu_imageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_imageCreateArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Qcu_images.
     *     @param {qcu_imageCreateManyArgs} args - Arguments to create many Qcu_images.
     *     @example
     *     // Create many Qcu_images
     *     const qcu_image = await prisma.qcu_image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qcu_imageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_imageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qcu_image.
     * @param {qcu_imageDeleteArgs} args - Arguments to delete one Qcu_image.
     * @example
     * // Delete one Qcu_image
     * const Qcu_image = await prisma.qcu_image.delete({
     *   where: {
     *     // ... filter to delete one Qcu_image
     *   }
     * })
     * 
    **/
    delete<T extends qcu_imageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_imageDeleteArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Qcu_image.
     * @param {qcu_imageUpdateArgs} args - Arguments to update one Qcu_image.
     * @example
     * // Update one Qcu_image
     * const qcu_image = await prisma.qcu_image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qcu_imageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_imageUpdateArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Qcu_images.
     * @param {qcu_imageDeleteManyArgs} args - Arguments to filter Qcu_images to delete.
     * @example
     * // Delete a few Qcu_images
     * const { count } = await prisma.qcu_image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qcu_imageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_imageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qcu_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qcu_images
     * const qcu_image = await prisma.qcu_image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qcu_imageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_imageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qcu_image.
     * @param {qcu_imageUpsertArgs} args - Arguments to update or create a Qcu_image.
     * @example
     * // Update or create a Qcu_image
     * const qcu_image = await prisma.qcu_image.upsert({
     *   create: {
     *     // ... data to create a Qcu_image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qcu_image we want to update
     *   }
     * })
    **/
    upsert<T extends qcu_imageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_imageUpsertArgs<ExtArgs>>
    ): Prisma__qcu_imageClient<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Qcu_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_imageCountArgs} args - Arguments to filter Qcu_images to count.
     * @example
     * // Count the number of Qcu_images
     * const count = await prisma.qcu_image.count({
     *   where: {
     *     // ... the filter for the Qcu_images we want to count
     *   }
     * })
    **/
    count<T extends qcu_imageCountArgs>(
      args?: Subset<T, qcu_imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qcu_imageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qcu_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_imageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qcu_imageAggregateArgs>(args: Subset<T, Qcu_imageAggregateArgs>): Prisma.PrismaPromise<GetQcu_imageAggregateType<T>>

    /**
     * Group by Qcu_image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Qcu_imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Qcu_imageGroupByArgs['orderBy'] }
        : { orderBy?: Qcu_imageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Qcu_imageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcu_imageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for qcu_image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__qcu_imageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends qcu_questionArgs<ExtArgs> = {}>(args?: Subset<T, qcu_questionArgs<ExtArgs>>): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * qcu_image base type for findUnique actions
   */
  export type qcu_imageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter, which qcu_image to fetch.
     */
    where: qcu_imageWhereUniqueInput
  }

  /**
   * qcu_image findUnique
   */
  export interface qcu_imageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_imageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_image findUniqueOrThrow
   */
  export type qcu_imageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter, which qcu_image to fetch.
     */
    where: qcu_imageWhereUniqueInput
  }


  /**
   * qcu_image base type for findFirst actions
   */
  export type qcu_imageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter, which qcu_image to fetch.
     */
    where?: qcu_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_images to fetch.
     */
    orderBy?: Enumerable<qcu_imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_images.
     */
    cursor?: qcu_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_images.
     */
    distinct?: Enumerable<Qcu_imageScalarFieldEnum>
  }

  /**
   * qcu_image findFirst
   */
  export interface qcu_imageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_imageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_image findFirstOrThrow
   */
  export type qcu_imageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter, which qcu_image to fetch.
     */
    where?: qcu_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_images to fetch.
     */
    orderBy?: Enumerable<qcu_imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_images.
     */
    cursor?: qcu_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_images.
     */
    distinct?: Enumerable<Qcu_imageScalarFieldEnum>
  }


  /**
   * qcu_image findMany
   */
  export type qcu_imageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter, which qcu_images to fetch.
     */
    where?: qcu_imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_images to fetch.
     */
    orderBy?: Enumerable<qcu_imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qcu_images.
     */
    cursor?: qcu_imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_images.
     */
    skip?: number
    distinct?: Enumerable<Qcu_imageScalarFieldEnum>
  }


  /**
   * qcu_image create
   */
  export type qcu_imageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * The data needed to create a qcu_image.
     */
    data: XOR<qcu_imageCreateInput, qcu_imageUncheckedCreateInput>
  }


  /**
   * qcu_image createMany
   */
  export type qcu_imageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qcu_images.
     */
    data: Enumerable<qcu_imageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * qcu_image update
   */
  export type qcu_imageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * The data needed to update a qcu_image.
     */
    data: XOR<qcu_imageUpdateInput, qcu_imageUncheckedUpdateInput>
    /**
     * Choose, which qcu_image to update.
     */
    where: qcu_imageWhereUniqueInput
  }


  /**
   * qcu_image updateMany
   */
  export type qcu_imageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qcu_images.
     */
    data: XOR<qcu_imageUpdateManyMutationInput, qcu_imageUncheckedUpdateManyInput>
    /**
     * Filter which qcu_images to update
     */
    where?: qcu_imageWhereInput
  }


  /**
   * qcu_image upsert
   */
  export type qcu_imageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * The filter to search for the qcu_image to update in case it exists.
     */
    where: qcu_imageWhereUniqueInput
    /**
     * In case the qcu_image found by the `where` argument doesn't exist, create a new qcu_image with this data.
     */
    create: XOR<qcu_imageCreateInput, qcu_imageUncheckedCreateInput>
    /**
     * In case the qcu_image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qcu_imageUpdateInput, qcu_imageUncheckedUpdateInput>
  }


  /**
   * qcu_image delete
   */
  export type qcu_imageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    /**
     * Filter which qcu_image to delete.
     */
    where: qcu_imageWhereUniqueInput
  }


  /**
   * qcu_image deleteMany
   */
  export type qcu_imageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_images to delete
     */
    where?: qcu_imageWhereInput
  }


  /**
   * qcu_image without action
   */
  export type qcu_imageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
  }



  /**
   * Model qcu_question
   */


  export type AggregateQcu_question = {
    _count: Qcu_questionCountAggregateOutputType | null
    _avg: Qcu_questionAvgAggregateOutputType | null
    _sum: Qcu_questionSumAggregateOutputType | null
    _min: Qcu_questionMinAggregateOutputType | null
    _max: Qcu_questionMaxAggregateOutputType | null
  }

  export type Qcu_questionAvgAggregateOutputType = {
    id: number | null
  }

  export type Qcu_questionSumAggregateOutputType = {
    id: number | null
  }

  export type Qcu_questionMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    note: string | null
    type: string | null
    level: string | null
    question: string | null
    diabete: string | null
    sssel: string | null
    chol: string | null
    trigly: string | null
  }

  export type Qcu_questionMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    note: string | null
    type: string | null
    level: string | null
    question: string | null
    diabete: string | null
    sssel: string | null
    chol: string | null
    trigly: string | null
  }

  export type Qcu_questionCountAggregateOutputType = {
    id: number
    created_at: number
    note: number
    type: number
    level: number
    question: number
    diabete: number
    sssel: number
    chol: number
    trigly: number
    _all: number
  }


  export type Qcu_questionAvgAggregateInputType = {
    id?: true
  }

  export type Qcu_questionSumAggregateInputType = {
    id?: true
  }

  export type Qcu_questionMinAggregateInputType = {
    id?: true
    created_at?: true
    note?: true
    type?: true
    level?: true
    question?: true
    diabete?: true
    sssel?: true
    chol?: true
    trigly?: true
  }

  export type Qcu_questionMaxAggregateInputType = {
    id?: true
    created_at?: true
    note?: true
    type?: true
    level?: true
    question?: true
    diabete?: true
    sssel?: true
    chol?: true
    trigly?: true
  }

  export type Qcu_questionCountAggregateInputType = {
    id?: true
    created_at?: true
    note?: true
    type?: true
    level?: true
    question?: true
    diabete?: true
    sssel?: true
    chol?: true
    trigly?: true
    _all?: true
  }

  export type Qcu_questionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_question to aggregate.
     */
    where?: qcu_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_questions to fetch.
     */
    orderBy?: Enumerable<qcu_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qcu_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qcu_questions
    **/
    _count?: true | Qcu_questionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qcu_questionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qcu_questionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qcu_questionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qcu_questionMaxAggregateInputType
  }

  export type GetQcu_questionAggregateType<T extends Qcu_questionAggregateArgs> = {
        [P in keyof T & keyof AggregateQcu_question]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcu_question[P]>
      : GetScalarType<T[P], AggregateQcu_question[P]>
  }




  export type Qcu_questionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: qcu_questionWhereInput
    orderBy?: Enumerable<qcu_questionOrderByWithAggregationInput>
    by: Qcu_questionScalarFieldEnum[]
    having?: qcu_questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qcu_questionCountAggregateInputType | true
    _avg?: Qcu_questionAvgAggregateInputType
    _sum?: Qcu_questionSumAggregateInputType
    _min?: Qcu_questionMinAggregateInputType
    _max?: Qcu_questionMaxAggregateInputType
  }


  export type Qcu_questionGroupByOutputType = {
    id: number
    created_at: Date | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    _count: Qcu_questionCountAggregateOutputType | null
    _avg: Qcu_questionAvgAggregateOutputType | null
    _sum: Qcu_questionSumAggregateOutputType | null
    _min: Qcu_questionMinAggregateOutputType | null
    _max: Qcu_questionMaxAggregateOutputType | null
  }

  type GetQcu_questionGroupByPayload<T extends Qcu_questionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Qcu_questionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qcu_questionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qcu_questionGroupByOutputType[P]>
            : GetScalarType<T[P], Qcu_questionGroupByOutputType[P]>
        }
      >
    >


  export type qcu_questionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    note?: boolean
    type?: boolean
    level?: boolean
    question?: boolean
    diabete?: boolean
    sssel?: boolean
    chol?: boolean
    trigly?: boolean
    items?: boolean | qcu_question$itemsArgs<ExtArgs>
    images?: boolean | qcu_question$imagesArgs<ExtArgs>
    answers?: boolean | qcu_question$answersArgs<ExtArgs>
    _count?: boolean | Qcu_questionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["qcu_question"]>

  export type qcu_questionSelectScalar = {
    id?: boolean
    created_at?: boolean
    note?: boolean
    type?: boolean
    level?: boolean
    question?: boolean
    diabete?: boolean
    sssel?: boolean
    chol?: boolean
    trigly?: boolean
  }

  export type qcu_questionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    items?: boolean | qcu_question$itemsArgs<ExtArgs>
    images?: boolean | qcu_question$imagesArgs<ExtArgs>
    answers?: boolean | qcu_question$answersArgs<ExtArgs>
    _count?: boolean | Qcu_questionCountOutputTypeArgs<ExtArgs>
  }


  type qcu_questionGetPayload<S extends boolean | null | undefined | qcu_questionArgs> = $Types.GetResult<qcu_questionPayload, S>

  type qcu_questionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<qcu_questionFindManyArgs, 'select' | 'include'> & {
      select?: Qcu_questionCountAggregateInputType | true
    }

  export interface qcu_questionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qcu_question'], meta: { name: 'qcu_question' } }
    /**
     * Find zero or one Qcu_question that matches the filter.
     * @param {qcu_questionFindUniqueArgs} args - Arguments to find a Qcu_question
     * @example
     * // Get one Qcu_question
     * const qcu_question = await prisma.qcu_question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qcu_questionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, qcu_questionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'qcu_question'> extends True ? Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Qcu_question that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {qcu_questionFindUniqueOrThrowArgs} args - Arguments to find a Qcu_question
     * @example
     * // Get one Qcu_question
     * const qcu_question = await prisma.qcu_question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends qcu_questionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_questionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Qcu_question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_questionFindFirstArgs} args - Arguments to find a Qcu_question
     * @example
     * // Get one Qcu_question
     * const qcu_question = await prisma.qcu_question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qcu_questionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, qcu_questionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'qcu_question'> extends True ? Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Qcu_question that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_questionFindFirstOrThrowArgs} args - Arguments to find a Qcu_question
     * @example
     * // Get one Qcu_question
     * const qcu_question = await prisma.qcu_question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends qcu_questionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_questionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Qcu_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_questionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qcu_questions
     * const qcu_questions = await prisma.qcu_question.findMany()
     * 
     * // Get first 10 Qcu_questions
     * const qcu_questions = await prisma.qcu_question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcu_questionWithIdOnly = await prisma.qcu_question.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends qcu_questionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_questionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Qcu_question.
     * @param {qcu_questionCreateArgs} args - Arguments to create a Qcu_question.
     * @example
     * // Create one Qcu_question
     * const Qcu_question = await prisma.qcu_question.create({
     *   data: {
     *     // ... data to create a Qcu_question
     *   }
     * })
     * 
    **/
    create<T extends qcu_questionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_questionCreateArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Qcu_questions.
     *     @param {qcu_questionCreateManyArgs} args - Arguments to create many Qcu_questions.
     *     @example
     *     // Create many Qcu_questions
     *     const qcu_question = await prisma.qcu_question.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qcu_questionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_questionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qcu_question.
     * @param {qcu_questionDeleteArgs} args - Arguments to delete one Qcu_question.
     * @example
     * // Delete one Qcu_question
     * const Qcu_question = await prisma.qcu_question.delete({
     *   where: {
     *     // ... filter to delete one Qcu_question
     *   }
     * })
     * 
    **/
    delete<T extends qcu_questionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_questionDeleteArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Qcu_question.
     * @param {qcu_questionUpdateArgs} args - Arguments to update one Qcu_question.
     * @example
     * // Update one Qcu_question
     * const qcu_question = await prisma.qcu_question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qcu_questionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_questionUpdateArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Qcu_questions.
     * @param {qcu_questionDeleteManyArgs} args - Arguments to filter Qcu_questions to delete.
     * @example
     * // Delete a few Qcu_questions
     * const { count } = await prisma.qcu_question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qcu_questionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_questionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qcu_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qcu_questions
     * const qcu_question = await prisma.qcu_question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qcu_questionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_questionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qcu_question.
     * @param {qcu_questionUpsertArgs} args - Arguments to update or create a Qcu_question.
     * @example
     * // Update or create a Qcu_question
     * const qcu_question = await prisma.qcu_question.upsert({
     *   create: {
     *     // ... data to create a Qcu_question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qcu_question we want to update
     *   }
     * })
    **/
    upsert<T extends qcu_questionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_questionUpsertArgs<ExtArgs>>
    ): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Qcu_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_questionCountArgs} args - Arguments to filter Qcu_questions to count.
     * @example
     * // Count the number of Qcu_questions
     * const count = await prisma.qcu_question.count({
     *   where: {
     *     // ... the filter for the Qcu_questions we want to count
     *   }
     * })
    **/
    count<T extends qcu_questionCountArgs>(
      args?: Subset<T, qcu_questionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qcu_questionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qcu_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_questionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qcu_questionAggregateArgs>(args: Subset<T, Qcu_questionAggregateArgs>): Prisma.PrismaPromise<GetQcu_questionAggregateType<T>>

    /**
     * Group by Qcu_question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Qcu_questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Qcu_questionGroupByArgs['orderBy'] }
        : { orderBy?: Qcu_questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Qcu_questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcu_questionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for qcu_question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__qcu_questionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends qcu_question$itemsArgs<ExtArgs> = {}>(args?: Subset<T, qcu_question$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findMany', never>| Null>;

    images<T extends qcu_question$imagesArgs<ExtArgs> = {}>(args?: Subset<T, qcu_question$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<qcu_imagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    answers<T extends qcu_question$answersArgs<ExtArgs> = {}>(args?: Subset<T, qcu_question$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * qcu_question base type for findUnique actions
   */
  export type qcu_questionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter, which qcu_question to fetch.
     */
    where: qcu_questionWhereUniqueInput
  }

  /**
   * qcu_question findUnique
   */
  export interface qcu_questionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_questionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_question findUniqueOrThrow
   */
  export type qcu_questionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter, which qcu_question to fetch.
     */
    where: qcu_questionWhereUniqueInput
  }


  /**
   * qcu_question base type for findFirst actions
   */
  export type qcu_questionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter, which qcu_question to fetch.
     */
    where?: qcu_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_questions to fetch.
     */
    orderBy?: Enumerable<qcu_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_questions.
     */
    cursor?: qcu_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_questions.
     */
    distinct?: Enumerable<Qcu_questionScalarFieldEnum>
  }

  /**
   * qcu_question findFirst
   */
  export interface qcu_questionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_questionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_question findFirstOrThrow
   */
  export type qcu_questionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter, which qcu_question to fetch.
     */
    where?: qcu_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_questions to fetch.
     */
    orderBy?: Enumerable<qcu_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_questions.
     */
    cursor?: qcu_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_questions.
     */
    distinct?: Enumerable<Qcu_questionScalarFieldEnum>
  }


  /**
   * qcu_question findMany
   */
  export type qcu_questionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter, which qcu_questions to fetch.
     */
    where?: qcu_questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_questions to fetch.
     */
    orderBy?: Enumerable<qcu_questionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qcu_questions.
     */
    cursor?: qcu_questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_questions.
     */
    skip?: number
    distinct?: Enumerable<Qcu_questionScalarFieldEnum>
  }


  /**
   * qcu_question create
   */
  export type qcu_questionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * The data needed to create a qcu_question.
     */
    data: XOR<qcu_questionCreateInput, qcu_questionUncheckedCreateInput>
  }


  /**
   * qcu_question createMany
   */
  export type qcu_questionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qcu_questions.
     */
    data: Enumerable<qcu_questionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * qcu_question update
   */
  export type qcu_questionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * The data needed to update a qcu_question.
     */
    data: XOR<qcu_questionUpdateInput, qcu_questionUncheckedUpdateInput>
    /**
     * Choose, which qcu_question to update.
     */
    where: qcu_questionWhereUniqueInput
  }


  /**
   * qcu_question updateMany
   */
  export type qcu_questionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qcu_questions.
     */
    data: XOR<qcu_questionUpdateManyMutationInput, qcu_questionUncheckedUpdateManyInput>
    /**
     * Filter which qcu_questions to update
     */
    where?: qcu_questionWhereInput
  }


  /**
   * qcu_question upsert
   */
  export type qcu_questionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * The filter to search for the qcu_question to update in case it exists.
     */
    where: qcu_questionWhereUniqueInput
    /**
     * In case the qcu_question found by the `where` argument doesn't exist, create a new qcu_question with this data.
     */
    create: XOR<qcu_questionCreateInput, qcu_questionUncheckedCreateInput>
    /**
     * In case the qcu_question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qcu_questionUpdateInput, qcu_questionUncheckedUpdateInput>
  }


  /**
   * qcu_question delete
   */
  export type qcu_questionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
    /**
     * Filter which qcu_question to delete.
     */
    where: qcu_questionWhereUniqueInput
  }


  /**
   * qcu_question deleteMany
   */
  export type qcu_questionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_questions to delete
     */
    where?: qcu_questionWhereInput
  }


  /**
   * qcu_question.items
   */
  export type qcu_question$itemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    where?: qcu_itemWhereInput
    orderBy?: Enumerable<qcu_itemOrderByWithRelationInput>
    cursor?: qcu_itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Qcu_itemScalarFieldEnum>
  }


  /**
   * qcu_question.images
   */
  export type qcu_question$imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_image
     */
    select?: qcu_imageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_imageInclude<ExtArgs> | null
    where?: qcu_imageWhereInput
    orderBy?: Enumerable<qcu_imageOrderByWithRelationInput>
    cursor?: qcu_imageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Qcu_imageScalarFieldEnum>
  }


  /**
   * qcu_question.answers
   */
  export type qcu_question$answersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    where?: user_qcuanswerWhereInput
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    cursor?: user_qcuanswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_qcuanswerScalarFieldEnum>
  }


  /**
   * qcu_question without action
   */
  export type qcu_questionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_question
     */
    select?: qcu_questionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_questionInclude<ExtArgs> | null
  }



  /**
   * Model qcu_item
   */


  export type AggregateQcu_item = {
    _count: Qcu_itemCountAggregateOutputType | null
    _avg: Qcu_itemAvgAggregateOutputType | null
    _sum: Qcu_itemSumAggregateOutputType | null
    _min: Qcu_itemMinAggregateOutputType | null
    _max: Qcu_itemMaxAggregateOutputType | null
  }

  export type Qcu_itemAvgAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type Qcu_itemSumAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type Qcu_itemMinAggregateOutputType = {
    id: number | null
    created_at: Date | null
    proposition: string | null
    pict: string | null
    answer: string | null
    success: boolean | null
    question_id: number | null
  }

  export type Qcu_itemMaxAggregateOutputType = {
    id: number | null
    created_at: Date | null
    proposition: string | null
    pict: string | null
    answer: string | null
    success: boolean | null
    question_id: number | null
  }

  export type Qcu_itemCountAggregateOutputType = {
    id: number
    created_at: number
    proposition: number
    pict: number
    answer: number
    success: number
    question_id: number
    _all: number
  }


  export type Qcu_itemAvgAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type Qcu_itemSumAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type Qcu_itemMinAggregateInputType = {
    id?: true
    created_at?: true
    proposition?: true
    pict?: true
    answer?: true
    success?: true
    question_id?: true
  }

  export type Qcu_itemMaxAggregateInputType = {
    id?: true
    created_at?: true
    proposition?: true
    pict?: true
    answer?: true
    success?: true
    question_id?: true
  }

  export type Qcu_itemCountAggregateInputType = {
    id?: true
    created_at?: true
    proposition?: true
    pict?: true
    answer?: true
    success?: true
    question_id?: true
    _all?: true
  }

  export type Qcu_itemAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_item to aggregate.
     */
    where?: qcu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_items to fetch.
     */
    orderBy?: Enumerable<qcu_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qcu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qcu_items
    **/
    _count?: true | Qcu_itemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qcu_itemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qcu_itemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qcu_itemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qcu_itemMaxAggregateInputType
  }

  export type GetQcu_itemAggregateType<T extends Qcu_itemAggregateArgs> = {
        [P in keyof T & keyof AggregateQcu_item]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQcu_item[P]>
      : GetScalarType<T[P], AggregateQcu_item[P]>
  }




  export type Qcu_itemGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: qcu_itemWhereInput
    orderBy?: Enumerable<qcu_itemOrderByWithAggregationInput>
    by: Qcu_itemScalarFieldEnum[]
    having?: qcu_itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qcu_itemCountAggregateInputType | true
    _avg?: Qcu_itemAvgAggregateInputType
    _sum?: Qcu_itemSumAggregateInputType
    _min?: Qcu_itemMinAggregateInputType
    _max?: Qcu_itemMaxAggregateInputType
  }


  export type Qcu_itemGroupByOutputType = {
    id: number
    created_at: Date | null
    proposition: string
    pict: string
    answer: string
    success: boolean
    question_id: number
    _count: Qcu_itemCountAggregateOutputType | null
    _avg: Qcu_itemAvgAggregateOutputType | null
    _sum: Qcu_itemSumAggregateOutputType | null
    _min: Qcu_itemMinAggregateOutputType | null
    _max: Qcu_itemMaxAggregateOutputType | null
  }

  type GetQcu_itemGroupByPayload<T extends Qcu_itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Qcu_itemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qcu_itemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qcu_itemGroupByOutputType[P]>
            : GetScalarType<T[P], Qcu_itemGroupByOutputType[P]>
        }
      >
    >


  export type qcu_itemSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    proposition?: boolean
    pict?: boolean
    answer?: boolean
    success?: boolean
    question_id?: boolean
    question?: boolean | qcu_questionArgs<ExtArgs>
  }, ExtArgs["result"]["qcu_item"]>

  export type qcu_itemSelectScalar = {
    id?: boolean
    created_at?: boolean
    proposition?: boolean
    pict?: boolean
    answer?: boolean
    success?: boolean
    question_id?: boolean
  }

  export type qcu_itemInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    question?: boolean | qcu_questionArgs<ExtArgs>
  }


  type qcu_itemGetPayload<S extends boolean | null | undefined | qcu_itemArgs> = $Types.GetResult<qcu_itemPayload, S>

  type qcu_itemCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<qcu_itemFindManyArgs, 'select' | 'include'> & {
      select?: Qcu_itemCountAggregateInputType | true
    }

  export interface qcu_itemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qcu_item'], meta: { name: 'qcu_item' } }
    /**
     * Find zero or one Qcu_item that matches the filter.
     * @param {qcu_itemFindUniqueArgs} args - Arguments to find a Qcu_item
     * @example
     * // Get one Qcu_item
     * const qcu_item = await prisma.qcu_item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends qcu_itemFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, qcu_itemFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'qcu_item'> extends True ? Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Qcu_item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {qcu_itemFindUniqueOrThrowArgs} args - Arguments to find a Qcu_item
     * @example
     * // Get one Qcu_item
     * const qcu_item = await prisma.qcu_item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends qcu_itemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_itemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Qcu_item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_itemFindFirstArgs} args - Arguments to find a Qcu_item
     * @example
     * // Get one Qcu_item
     * const qcu_item = await prisma.qcu_item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends qcu_itemFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, qcu_itemFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'qcu_item'> extends True ? Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Qcu_item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_itemFindFirstOrThrowArgs} args - Arguments to find a Qcu_item
     * @example
     * // Get one Qcu_item
     * const qcu_item = await prisma.qcu_item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends qcu_itemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_itemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Qcu_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_itemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qcu_items
     * const qcu_items = await prisma.qcu_item.findMany()
     * 
     * // Get first 10 Qcu_items
     * const qcu_items = await prisma.qcu_item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qcu_itemWithIdOnly = await prisma.qcu_item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends qcu_itemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_itemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Qcu_item.
     * @param {qcu_itemCreateArgs} args - Arguments to create a Qcu_item.
     * @example
     * // Create one Qcu_item
     * const Qcu_item = await prisma.qcu_item.create({
     *   data: {
     *     // ... data to create a Qcu_item
     *   }
     * })
     * 
    **/
    create<T extends qcu_itemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_itemCreateArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Qcu_items.
     *     @param {qcu_itemCreateManyArgs} args - Arguments to create many Qcu_items.
     *     @example
     *     // Create many Qcu_items
     *     const qcu_item = await prisma.qcu_item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends qcu_itemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_itemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Qcu_item.
     * @param {qcu_itemDeleteArgs} args - Arguments to delete one Qcu_item.
     * @example
     * // Delete one Qcu_item
     * const Qcu_item = await prisma.qcu_item.delete({
     *   where: {
     *     // ... filter to delete one Qcu_item
     *   }
     * })
     * 
    **/
    delete<T extends qcu_itemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_itemDeleteArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Qcu_item.
     * @param {qcu_itemUpdateArgs} args - Arguments to update one Qcu_item.
     * @example
     * // Update one Qcu_item
     * const qcu_item = await prisma.qcu_item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends qcu_itemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_itemUpdateArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Qcu_items.
     * @param {qcu_itemDeleteManyArgs} args - Arguments to filter Qcu_items to delete.
     * @example
     * // Delete a few Qcu_items
     * const { count } = await prisma.qcu_item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends qcu_itemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, qcu_itemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qcu_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qcu_items
     * const qcu_item = await prisma.qcu_item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends qcu_itemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_itemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Qcu_item.
     * @param {qcu_itemUpsertArgs} args - Arguments to update or create a Qcu_item.
     * @example
     * // Update or create a Qcu_item
     * const qcu_item = await prisma.qcu_item.upsert({
     *   create: {
     *     // ... data to create a Qcu_item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qcu_item we want to update
     *   }
     * })
    **/
    upsert<T extends qcu_itemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, qcu_itemUpsertArgs<ExtArgs>>
    ): Prisma__qcu_itemClient<$Types.GetResult<qcu_itemPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Qcu_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qcu_itemCountArgs} args - Arguments to filter Qcu_items to count.
     * @example
     * // Count the number of Qcu_items
     * const count = await prisma.qcu_item.count({
     *   where: {
     *     // ... the filter for the Qcu_items we want to count
     *   }
     * })
    **/
    count<T extends qcu_itemCountArgs>(
      args?: Subset<T, qcu_itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qcu_itemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qcu_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_itemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qcu_itemAggregateArgs>(args: Subset<T, Qcu_itemAggregateArgs>): Prisma.PrismaPromise<GetQcu_itemAggregateType<T>>

    /**
     * Group by Qcu_item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qcu_itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Qcu_itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Qcu_itemGroupByArgs['orderBy'] }
        : { orderBy?: Qcu_itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Qcu_itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQcu_itemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for qcu_item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__qcu_itemClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    question<T extends qcu_questionArgs<ExtArgs> = {}>(args?: Subset<T, qcu_questionArgs<ExtArgs>>): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * qcu_item base type for findUnique actions
   */
  export type qcu_itemFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter, which qcu_item to fetch.
     */
    where: qcu_itemWhereUniqueInput
  }

  /**
   * qcu_item findUnique
   */
  export interface qcu_itemFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_itemFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_item findUniqueOrThrow
   */
  export type qcu_itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter, which qcu_item to fetch.
     */
    where: qcu_itemWhereUniqueInput
  }


  /**
   * qcu_item base type for findFirst actions
   */
  export type qcu_itemFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter, which qcu_item to fetch.
     */
    where?: qcu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_items to fetch.
     */
    orderBy?: Enumerable<qcu_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_items.
     */
    cursor?: qcu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_items.
     */
    distinct?: Enumerable<Qcu_itemScalarFieldEnum>
  }

  /**
   * qcu_item findFirst
   */
  export interface qcu_itemFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends qcu_itemFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * qcu_item findFirstOrThrow
   */
  export type qcu_itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter, which qcu_item to fetch.
     */
    where?: qcu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_items to fetch.
     */
    orderBy?: Enumerable<qcu_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qcu_items.
     */
    cursor?: qcu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qcu_items.
     */
    distinct?: Enumerable<Qcu_itemScalarFieldEnum>
  }


  /**
   * qcu_item findMany
   */
  export type qcu_itemFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter, which qcu_items to fetch.
     */
    where?: qcu_itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qcu_items to fetch.
     */
    orderBy?: Enumerable<qcu_itemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qcu_items.
     */
    cursor?: qcu_itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qcu_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qcu_items.
     */
    skip?: number
    distinct?: Enumerable<Qcu_itemScalarFieldEnum>
  }


  /**
   * qcu_item create
   */
  export type qcu_itemCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * The data needed to create a qcu_item.
     */
    data: XOR<qcu_itemCreateInput, qcu_itemUncheckedCreateInput>
  }


  /**
   * qcu_item createMany
   */
  export type qcu_itemCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qcu_items.
     */
    data: Enumerable<qcu_itemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * qcu_item update
   */
  export type qcu_itemUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * The data needed to update a qcu_item.
     */
    data: XOR<qcu_itemUpdateInput, qcu_itemUncheckedUpdateInput>
    /**
     * Choose, which qcu_item to update.
     */
    where: qcu_itemWhereUniqueInput
  }


  /**
   * qcu_item updateMany
   */
  export type qcu_itemUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qcu_items.
     */
    data: XOR<qcu_itemUpdateManyMutationInput, qcu_itemUncheckedUpdateManyInput>
    /**
     * Filter which qcu_items to update
     */
    where?: qcu_itemWhereInput
  }


  /**
   * qcu_item upsert
   */
  export type qcu_itemUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * The filter to search for the qcu_item to update in case it exists.
     */
    where: qcu_itemWhereUniqueInput
    /**
     * In case the qcu_item found by the `where` argument doesn't exist, create a new qcu_item with this data.
     */
    create: XOR<qcu_itemCreateInput, qcu_itemUncheckedCreateInput>
    /**
     * In case the qcu_item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qcu_itemUpdateInput, qcu_itemUncheckedUpdateInput>
  }


  /**
   * qcu_item delete
   */
  export type qcu_itemDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
    /**
     * Filter which qcu_item to delete.
     */
    where: qcu_itemWhereUniqueInput
  }


  /**
   * qcu_item deleteMany
   */
  export type qcu_itemDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which qcu_items to delete
     */
    where?: qcu_itemWhereInput
  }


  /**
   * qcu_item without action
   */
  export type qcu_itemArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qcu_item
     */
    select?: qcu_itemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: qcu_itemInclude<ExtArgs> | null
  }



  /**
   * Model user_qcuanswer
   */


  export type AggregateUser_qcuanswer = {
    _count: User_qcuanswerCountAggregateOutputType | null
    _avg: User_qcuanswerAvgAggregateOutputType | null
    _sum: User_qcuanswerSumAggregateOutputType | null
    _min: User_qcuanswerMinAggregateOutputType | null
    _max: User_qcuanswerMaxAggregateOutputType | null
  }

  export type User_qcuanswerAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    qcuquestion_id: number | null
  }

  export type User_qcuanswerSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    qcuquestion_id: number | null
  }

  export type User_qcuanswerMinAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    user_id: number | null
    qcuquestion_id: number | null
    success: boolean | null
  }

  export type User_qcuanswerMaxAggregateOutputType = {
    id: number | null
    timestamp: Date | null
    user_id: number | null
    qcuquestion_id: number | null
    success: boolean | null
  }

  export type User_qcuanswerCountAggregateOutputType = {
    id: number
    timestamp: number
    user_id: number
    qcuquestion_id: number
    success: number
    _all: number
  }


  export type User_qcuanswerAvgAggregateInputType = {
    id?: true
    user_id?: true
    qcuquestion_id?: true
  }

  export type User_qcuanswerSumAggregateInputType = {
    id?: true
    user_id?: true
    qcuquestion_id?: true
  }

  export type User_qcuanswerMinAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    qcuquestion_id?: true
    success?: true
  }

  export type User_qcuanswerMaxAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    qcuquestion_id?: true
    success?: true
  }

  export type User_qcuanswerCountAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    qcuquestion_id?: true
    success?: true
    _all?: true
  }

  export type User_qcuanswerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_qcuanswer to aggregate.
     */
    where?: user_qcuanswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_qcuanswers to fetch.
     */
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_qcuanswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_qcuanswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_qcuanswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_qcuanswers
    **/
    _count?: true | User_qcuanswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_qcuanswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_qcuanswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_qcuanswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_qcuanswerMaxAggregateInputType
  }

  export type GetUser_qcuanswerAggregateType<T extends User_qcuanswerAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_qcuanswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_qcuanswer[P]>
      : GetScalarType<T[P], AggregateUser_qcuanswer[P]>
  }




  export type User_qcuanswerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: user_qcuanswerWhereInput
    orderBy?: Enumerable<user_qcuanswerOrderByWithAggregationInput>
    by: User_qcuanswerScalarFieldEnum[]
    having?: user_qcuanswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_qcuanswerCountAggregateInputType | true
    _avg?: User_qcuanswerAvgAggregateInputType
    _sum?: User_qcuanswerSumAggregateInputType
    _min?: User_qcuanswerMinAggregateInputType
    _max?: User_qcuanswerMaxAggregateInputType
  }


  export type User_qcuanswerGroupByOutputType = {
    id: number
    timestamp: Date | null
    user_id: number
    qcuquestion_id: number
    success: boolean
    _count: User_qcuanswerCountAggregateOutputType | null
    _avg: User_qcuanswerAvgAggregateOutputType | null
    _sum: User_qcuanswerSumAggregateOutputType | null
    _min: User_qcuanswerMinAggregateOutputType | null
    _max: User_qcuanswerMaxAggregateOutputType | null
  }

  type GetUser_qcuanswerGroupByPayload<T extends User_qcuanswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<User_qcuanswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_qcuanswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_qcuanswerGroupByOutputType[P]>
            : GetScalarType<T[P], User_qcuanswerGroupByOutputType[P]>
        }
      >
    >


  export type user_qcuanswerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    user_id?: boolean
    qcuquestion_id?: boolean
    success?: boolean
    user?: boolean | userArgs<ExtArgs>
    question?: boolean | qcu_questionArgs<ExtArgs>
  }, ExtArgs["result"]["user_qcuanswer"]>

  export type user_qcuanswerSelectScalar = {
    id?: boolean
    timestamp?: boolean
    user_id?: boolean
    qcuquestion_id?: boolean
    success?: boolean
  }

  export type user_qcuanswerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    question?: boolean | qcu_questionArgs<ExtArgs>
  }


  type user_qcuanswerGetPayload<S extends boolean | null | undefined | user_qcuanswerArgs> = $Types.GetResult<user_qcuanswerPayload, S>

  type user_qcuanswerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<user_qcuanswerFindManyArgs, 'select' | 'include'> & {
      select?: User_qcuanswerCountAggregateInputType | true
    }

  export interface user_qcuanswerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_qcuanswer'], meta: { name: 'user_qcuanswer' } }
    /**
     * Find zero or one User_qcuanswer that matches the filter.
     * @param {user_qcuanswerFindUniqueArgs} args - Arguments to find a User_qcuanswer
     * @example
     * // Get one User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_qcuanswerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_qcuanswerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_qcuanswer'> extends True ? Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User_qcuanswer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_qcuanswerFindUniqueOrThrowArgs} args - Arguments to find a User_qcuanswer
     * @example
     * // Get one User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_qcuanswerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_qcuanswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User_qcuanswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_qcuanswerFindFirstArgs} args - Arguments to find a User_qcuanswer
     * @example
     * // Get one User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_qcuanswerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_qcuanswerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_qcuanswer'> extends True ? Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User_qcuanswer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_qcuanswerFindFirstOrThrowArgs} args - Arguments to find a User_qcuanswer
     * @example
     * // Get one User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_qcuanswerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_qcuanswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more User_qcuanswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_qcuanswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_qcuanswers
     * const user_qcuanswers = await prisma.user_qcuanswer.findMany()
     * 
     * // Get first 10 User_qcuanswers
     * const user_qcuanswers = await prisma.user_qcuanswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_qcuanswerWithIdOnly = await prisma.user_qcuanswer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_qcuanswerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_qcuanswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User_qcuanswer.
     * @param {user_qcuanswerCreateArgs} args - Arguments to create a User_qcuanswer.
     * @example
     * // Create one User_qcuanswer
     * const User_qcuanswer = await prisma.user_qcuanswer.create({
     *   data: {
     *     // ... data to create a User_qcuanswer
     *   }
     * })
     * 
    **/
    create<T extends user_qcuanswerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_qcuanswerCreateArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many User_qcuanswers.
     *     @param {user_qcuanswerCreateManyArgs} args - Arguments to create many User_qcuanswers.
     *     @example
     *     // Create many User_qcuanswers
     *     const user_qcuanswer = await prisma.user_qcuanswer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_qcuanswerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_qcuanswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_qcuanswer.
     * @param {user_qcuanswerDeleteArgs} args - Arguments to delete one User_qcuanswer.
     * @example
     * // Delete one User_qcuanswer
     * const User_qcuanswer = await prisma.user_qcuanswer.delete({
     *   where: {
     *     // ... filter to delete one User_qcuanswer
     *   }
     * })
     * 
    **/
    delete<T extends user_qcuanswerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_qcuanswerDeleteArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User_qcuanswer.
     * @param {user_qcuanswerUpdateArgs} args - Arguments to update one User_qcuanswer.
     * @example
     * // Update one User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_qcuanswerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_qcuanswerUpdateArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more User_qcuanswers.
     * @param {user_qcuanswerDeleteManyArgs} args - Arguments to filter User_qcuanswers to delete.
     * @example
     * // Delete a few User_qcuanswers
     * const { count } = await prisma.user_qcuanswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_qcuanswerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_qcuanswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_qcuanswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_qcuanswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_qcuanswers
     * const user_qcuanswer = await prisma.user_qcuanswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_qcuanswerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_qcuanswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_qcuanswer.
     * @param {user_qcuanswerUpsertArgs} args - Arguments to update or create a User_qcuanswer.
     * @example
     * // Update or create a User_qcuanswer
     * const user_qcuanswer = await prisma.user_qcuanswer.upsert({
     *   create: {
     *     // ... data to create a User_qcuanswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_qcuanswer we want to update
     *   }
     * })
    **/
    upsert<T extends user_qcuanswerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_qcuanswerUpsertArgs<ExtArgs>>
    ): Prisma__user_qcuanswerClient<$Types.GetResult<user_qcuanswerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of User_qcuanswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_qcuanswerCountArgs} args - Arguments to filter User_qcuanswers to count.
     * @example
     * // Count the number of User_qcuanswers
     * const count = await prisma.user_qcuanswer.count({
     *   where: {
     *     // ... the filter for the User_qcuanswers we want to count
     *   }
     * })
    **/
    count<T extends user_qcuanswerCountArgs>(
      args?: Subset<T, user_qcuanswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_qcuanswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_qcuanswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_qcuanswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_qcuanswerAggregateArgs>(args: Subset<T, User_qcuanswerAggregateArgs>): Prisma.PrismaPromise<GetUser_qcuanswerAggregateType<T>>

    /**
     * Group by User_qcuanswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_qcuanswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_qcuanswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_qcuanswerGroupByArgs['orderBy'] }
        : { orderBy?: User_qcuanswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_qcuanswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_qcuanswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user_qcuanswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_qcuanswerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    question<T extends qcu_questionArgs<ExtArgs> = {}>(args?: Subset<T, qcu_questionArgs<ExtArgs>>): Prisma__qcu_questionClient<$Types.GetResult<qcu_questionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user_qcuanswer base type for findUnique actions
   */
  export type user_qcuanswerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter, which user_qcuanswer to fetch.
     */
    where: user_qcuanswerWhereUniqueInput
  }

  /**
   * user_qcuanswer findUnique
   */
  export interface user_qcuanswerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_qcuanswerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_qcuanswer findUniqueOrThrow
   */
  export type user_qcuanswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter, which user_qcuanswer to fetch.
     */
    where: user_qcuanswerWhereUniqueInput
  }


  /**
   * user_qcuanswer base type for findFirst actions
   */
  export type user_qcuanswerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter, which user_qcuanswer to fetch.
     */
    where?: user_qcuanswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_qcuanswers to fetch.
     */
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_qcuanswers.
     */
    cursor?: user_qcuanswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_qcuanswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_qcuanswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_qcuanswers.
     */
    distinct?: Enumerable<User_qcuanswerScalarFieldEnum>
  }

  /**
   * user_qcuanswer findFirst
   */
  export interface user_qcuanswerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends user_qcuanswerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_qcuanswer findFirstOrThrow
   */
  export type user_qcuanswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter, which user_qcuanswer to fetch.
     */
    where?: user_qcuanswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_qcuanswers to fetch.
     */
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_qcuanswers.
     */
    cursor?: user_qcuanswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_qcuanswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_qcuanswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_qcuanswers.
     */
    distinct?: Enumerable<User_qcuanswerScalarFieldEnum>
  }


  /**
   * user_qcuanswer findMany
   */
  export type user_qcuanswerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter, which user_qcuanswers to fetch.
     */
    where?: user_qcuanswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_qcuanswers to fetch.
     */
    orderBy?: Enumerable<user_qcuanswerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_qcuanswers.
     */
    cursor?: user_qcuanswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_qcuanswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_qcuanswers.
     */
    skip?: number
    distinct?: Enumerable<User_qcuanswerScalarFieldEnum>
  }


  /**
   * user_qcuanswer create
   */
  export type user_qcuanswerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * The data needed to create a user_qcuanswer.
     */
    data: XOR<user_qcuanswerCreateInput, user_qcuanswerUncheckedCreateInput>
  }


  /**
   * user_qcuanswer createMany
   */
  export type user_qcuanswerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_qcuanswers.
     */
    data: Enumerable<user_qcuanswerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_qcuanswer update
   */
  export type user_qcuanswerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * The data needed to update a user_qcuanswer.
     */
    data: XOR<user_qcuanswerUpdateInput, user_qcuanswerUncheckedUpdateInput>
    /**
     * Choose, which user_qcuanswer to update.
     */
    where: user_qcuanswerWhereUniqueInput
  }


  /**
   * user_qcuanswer updateMany
   */
  export type user_qcuanswerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_qcuanswers.
     */
    data: XOR<user_qcuanswerUpdateManyMutationInput, user_qcuanswerUncheckedUpdateManyInput>
    /**
     * Filter which user_qcuanswers to update
     */
    where?: user_qcuanswerWhereInput
  }


  /**
   * user_qcuanswer upsert
   */
  export type user_qcuanswerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * The filter to search for the user_qcuanswer to update in case it exists.
     */
    where: user_qcuanswerWhereUniqueInput
    /**
     * In case the user_qcuanswer found by the `where` argument doesn't exist, create a new user_qcuanswer with this data.
     */
    create: XOR<user_qcuanswerCreateInput, user_qcuanswerUncheckedCreateInput>
    /**
     * In case the user_qcuanswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_qcuanswerUpdateInput, user_qcuanswerUncheckedUpdateInput>
  }


  /**
   * user_qcuanswer delete
   */
  export type user_qcuanswerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
    /**
     * Filter which user_qcuanswer to delete.
     */
    where: user_qcuanswerWhereUniqueInput
  }


  /**
   * user_qcuanswer deleteMany
   */
  export type user_qcuanswerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_qcuanswers to delete
     */
    where?: user_qcuanswerWhereInput
  }


  /**
   * user_qcuanswer without action
   */
  export type user_qcuanswerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_qcuanswer
     */
    select?: user_qcuanswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_qcuanswerInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SessionScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const User_actionScalarFieldEnum: {
    id: 'id',
    session_id: 'session_id',
    time: 'time',
    user_id: 'user_id',
    action: 'action'
  };

  export type User_actionScalarFieldEnum = (typeof User_actionScalarFieldEnum)[keyof typeof User_actionScalarFieldEnum]


  export const CenterScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    type: 'type',
    name: 'name'
  };

  export type CenterScalarFieldEnum = (typeof CenterScalarFieldEnum)[keyof typeof CenterScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    from_id: 'from_id',
    to_id: 'to_id',
    read_on: 'read_on',
    content: 'content'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const Patient_caregiverScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    confirmed: 'confirmed',
    patient_id: 'patient_id',
    caregiver_id: 'caregiver_id',
    role: 'role'
  };

  export type Patient_caregiverScalarFieldEnum = (typeof Patient_caregiverScalarFieldEnum)[keyof typeof Patient_caregiverScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    sub: 'sub',
    password: 'password',
    type: 'type',
    birthdate: 'birthdate',
    title: 'title',
    email: 'email',
    phone: 'phone',
    firstname: 'firstname',
    lastname: 'lastname',
    alias: 'alias',
    notes: 'notes',
    avatarUrl: 'avatarUrl',
    install_token: 'install_token',
    subscription: 'subscription',
    gender: 'gender',
    height_cm: 'height_cm',
    weight: 'weight',
    actsport: 'actsport',
    actprof: 'actprof',
    diabetes_type: 'diabetes_type',
    hypertriglyceridemia: 'hypertriglyceridemia',
    hypercholesterolemia: 'hypercholesterolemia',
    salt_diet: 'salt_diet',
    energy_goal: 'energy_goal'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_centerScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    center_id: 'center_id',
    role: 'role'
  };

  export type User_centerScalarFieldEnum = (typeof User_centerScalarFieldEnum)[keyof typeof User_centerScalarFieldEnum]


  export const User_goalScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    date: 'date',
    type: 'type',
    value: 'value'
  };

  export type User_goalScalarFieldEnum = (typeof User_goalScalarFieldEnum)[keyof typeof User_goalScalarFieldEnum]


  export const User_measurementScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    date: 'date',
    type: 'type',
    value: 'value'
  };

  export type User_measurementScalarFieldEnum = (typeof User_measurementScalarFieldEnum)[keyof typeof User_measurementScalarFieldEnum]


  export const User_withingsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    withings_userid: 'withings_userid',
    access_token: 'access_token',
    refresh_token: 'refresh_token'
  };

  export type User_withingsScalarFieldEnum = (typeof User_withingsScalarFieldEnum)[keyof typeof User_withingsScalarFieldEnum]


  export const User_patientScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    protocol_code: 'protocol_code',
    protocol_inclusion_date: 'protocol_inclusion_date'
  };

  export type User_patientScalarFieldEnum = (typeof User_patientScalarFieldEnum)[keyof typeof User_patientScalarFieldEnum]


  export const FractioningScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    date: 'date',
    meal_types: 'meal_types'
  };

  export type FractioningScalarFieldEnum = (typeof FractioningScalarFieldEnum)[keyof typeof FractioningScalarFieldEnum]


  export const Meal_elementScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    meal_id: 'meal_id',
    food_id: 'food_id',
    weight: 'weight',
    portion_id: 'portion_id',
    portion_cnt: 'portion_cnt'
  };

  export type Meal_elementScalarFieldEnum = (typeof Meal_elementScalarFieldEnum)[keyof typeof Meal_elementScalarFieldEnum]


  export const MealScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    date: 'date',
    mealtype: 'mealtype',
    really_eaten: 'really_eaten'
  };

  export type MealScalarFieldEnum = (typeof MealScalarFieldEnum)[keyof typeof MealScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    user_id: 'user_id',
    mealtype: 'mealtype',
    count: 'count',
    food_id: 'food_id',
    weight: 'weight',
    portion_id: 'portion_id',
    portion_cnt: 'portion_cnt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc',
    ciqual_gpcd: 'ciqual_gpcd',
    member_of_id: 'member_of_id',
    rank: 'rank',
    tag: 'tag'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const Food_categoryScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    food_id: 'food_id',
    category_id: 'category_id'
  };

  export type Food_categoryScalarFieldEnum = (typeof Food_categoryScalarFieldEnum)[keyof typeof Food_categoryScalarFieldEnum]


  export const Food_portionScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    qty: 'qty',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc',
    note: 'note',
    pict: 'pict',
    food_id: 'food_id'
  };

  export type Food_portionScalarFieldEnum = (typeof Food_portionScalarFieldEnum)[keyof typeof Food_portionScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc',
    ciqual_name: 'ciqual_name',
    ctdit_shrt_desc: 'ctdit_shrt_desc',
    ctdit_long_desc: 'ctdit_long_desc',
    keywords: 'keywords',
    ciqual_num: 'ciqual_num',
    note: 'note',
    max_qty: 'max_qty',
    pict: 'pict',
    source_id: 'source_id',
    is_brand: 'is_brand',
    is_raw: 'is_raw',
    is_indivisible: 'is_indivisible',
    is_chu: 'is_chu',
    is_demo: 'is_demo',
    is_patient_full: 'is_patient_full',
    is_patient_simplified: 'is_patient_simplified',
    pack_pict: 'pack_pict',
    is_validated: 'is_validated'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const NutdataScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    val: 'val',
    note: 'note',
    food_id: 'food_id',
    nutr_no: 'nutr_no',
    source_id: 'source_id'
  };

  export type NutdataScalarFieldEnum = (typeof NutdataScalarFieldEnum)[keyof typeof NutdataScalarFieldEnum]


  export const NutrientScalarFieldEnum: {
    nutr_no: 'nutr_no',
    created_at: 'created_at',
    ifda_no: 'ifda_no',
    unit: 'unit',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc',
    energy_density: 'energy_density'
  };

  export type NutrientScalarFieldEnum = (typeof NutrientScalarFieldEnum)[keyof typeof NutrientScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const DishScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    shrt_desc: 'shrt_desc',
    long_desc: 'long_desc',
    pict: 'pict',
    note: 'note',
    shrt_source: 'shrt_source',
    long_source: 'long_source',
    qty_max: 'qty_max',
    resume: 'resume',
    recette: 'recette',
    nbpersonnes: 'nbpersonnes',
    qte: 'qte',
    diabete: 'diabete',
    cardiaque: 'cardiaque',
    obese: 'obese',
    ssel: 'ssel',
    chol: 'chol',
    trigly: 'trigly',
    maxqty: 'maxqty'
  };

  export type DishScalarFieldEnum = (typeof DishScalarFieldEnum)[keyof typeof DishScalarFieldEnum]


  export const LexiconScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    code: 'code',
    title: 'title',
    text: 'text'
  };

  export type LexiconScalarFieldEnum = (typeof LexiconScalarFieldEnum)[keyof typeof LexiconScalarFieldEnum]


  export const Qcu_imageScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    pict: 'pict',
    question_id: 'question_id'
  };

  export type Qcu_imageScalarFieldEnum = (typeof Qcu_imageScalarFieldEnum)[keyof typeof Qcu_imageScalarFieldEnum]


  export const Qcu_questionScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    note: 'note',
    type: 'type',
    level: 'level',
    question: 'question',
    diabete: 'diabete',
    sssel: 'sssel',
    chol: 'chol',
    trigly: 'trigly'
  };

  export type Qcu_questionScalarFieldEnum = (typeof Qcu_questionScalarFieldEnum)[keyof typeof Qcu_questionScalarFieldEnum]


  export const Qcu_itemScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    proposition: 'proposition',
    pict: 'pict',
    answer: 'answer',
    success: 'success',
    question_id: 'question_id'
  };

  export type Qcu_itemScalarFieldEnum = (typeof Qcu_itemScalarFieldEnum)[keyof typeof Qcu_itemScalarFieldEnum]


  export const User_qcuanswerScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    user_id: 'user_id',
    qcuquestion_id: 'qcuquestion_id',
    success: 'success'
  };

  export type User_qcuanswerScalarFieldEnum = (typeof User_qcuanswerScalarFieldEnum)[keyof typeof User_qcuanswerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type sessionWhereInput = {
    AND?: Enumerable<sessionWhereInput>
    OR?: Enumerable<sessionWhereInput>
    NOT?: Enumerable<sessionWhereInput>
    id?: IntFilter | number
    startTime?: DateTimeFilter | Date | string
    endTime?: DateTimeNullableFilter | Date | string | null
    user_actions?: User_actionListRelationFilter
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    user_actions?: user_actionOrderByRelationAggregateInput
  }

  export type sessionWhereUniqueInput = {
    id?: number
  }

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    _count?: sessionCountOrderByAggregateInput
    _avg?: sessionAvgOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
    _sum?: sessionSumOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<sessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    startTime?: DateTimeWithAggregatesFilter | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type user_actionWhereInput = {
    AND?: Enumerable<user_actionWhereInput>
    OR?: Enumerable<user_actionWhereInput>
    NOT?: Enumerable<user_actionWhereInput>
    id?: IntFilter | number
    session_id?: IntFilter | number
    time?: DateTimeFilter | Date | string
    user_id?: IntFilter | number
    action?: StringFilter | string
    session?: XOR<SessionRelationFilter, sessionWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_actionOrderByWithRelationInput = {
    id?: SortOrder
    session_id?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    session?: sessionOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type user_actionWhereUniqueInput = {
    id?: number
  }

  export type user_actionOrderByWithAggregationInput = {
    id?: SortOrder
    session_id?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
    _count?: user_actionCountOrderByAggregateInput
    _avg?: user_actionAvgOrderByAggregateInput
    _max?: user_actionMaxOrderByAggregateInput
    _min?: user_actionMinOrderByAggregateInput
    _sum?: user_actionSumOrderByAggregateInput
  }

  export type user_actionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_actionScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_actionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_actionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    session_id?: IntWithAggregatesFilter | number
    time?: DateTimeWithAggregatesFilter | Date | string
    user_id?: IntWithAggregatesFilter | number
    action?: StringWithAggregatesFilter | string
  }

  export type centerWhereInput = {
    AND?: Enumerable<centerWhereInput>
    OR?: Enumerable<centerWhereInput>
    NOT?: Enumerable<centerWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    type?: EnumCenterTypeFilter | CenterType
    name?: StringFilter | string
    user_centers?: User_centerListRelationFilter
  }

  export type centerOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrder
    user_centers?: user_centerOrderByRelationAggregateInput
  }

  export type centerWhereUniqueInput = {
    id?: number
  }

  export type centerOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    type?: SortOrder
    name?: SortOrder
    _count?: centerCountOrderByAggregateInput
    _avg?: centerAvgOrderByAggregateInput
    _max?: centerMaxOrderByAggregateInput
    _min?: centerMinOrderByAggregateInput
    _sum?: centerSumOrderByAggregateInput
  }

  export type centerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<centerScalarWhereWithAggregatesInput>
    OR?: Enumerable<centerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<centerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    type?: EnumCenterTypeWithAggregatesFilter | CenterType
    name?: StringWithAggregatesFilter | string
  }

  export type messageWhereInput = {
    AND?: Enumerable<messageWhereInput>
    OR?: Enumerable<messageWhereInput>
    NOT?: Enumerable<messageWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    from_id?: IntFilter | number
    to_id?: IntFilter | number
    read_on?: DateTimeNullableFilter | Date | string | null
    content?: StringFilter | string
    from?: XOR<UserRelationFilter, userWhereInput>
    to?: XOR<UserRelationFilter, userWhereInput>
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
    read_on?: SortOrderInput | SortOrder
    content?: SortOrder
    from?: userOrderByWithRelationInput
    to?: userOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = {
    id?: number
  }

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
    read_on?: SortOrderInput | SortOrder
    content?: SortOrder
    _count?: messageCountOrderByAggregateInput
    _avg?: messageAvgOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
    _sum?: messageSumOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<messageScalarWhereWithAggregatesInput>
    OR?: Enumerable<messageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<messageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    from_id?: IntWithAggregatesFilter | number
    to_id?: IntWithAggregatesFilter | number
    read_on?: DateTimeNullableWithAggregatesFilter | Date | string | null
    content?: StringWithAggregatesFilter | string
  }

  export type patient_caregiverWhereInput = {
    AND?: Enumerable<patient_caregiverWhereInput>
    OR?: Enumerable<patient_caregiverWhereInput>
    NOT?: Enumerable<patient_caregiverWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    confirmed?: BoolFilter | boolean
    patient_id?: IntFilter | number
    caregiver_id?: IntFilter | number
    role?: EnumPatientCaregiverTypeFilter | PatientCaregiverType
    patient?: XOR<UserRelationFilter, userWhereInput>
    caregiver?: XOR<UserRelationFilter, userWhereInput>
  }

  export type patient_caregiverOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    confirmed?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    patient?: userOrderByWithRelationInput
    caregiver?: userOrderByWithRelationInput
  }

  export type patient_caregiverWhereUniqueInput = {
    id?: number
  }

  export type patient_caregiverOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    confirmed?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    _count?: patient_caregiverCountOrderByAggregateInput
    _avg?: patient_caregiverAvgOrderByAggregateInput
    _max?: patient_caregiverMaxOrderByAggregateInput
    _min?: patient_caregiverMinOrderByAggregateInput
    _sum?: patient_caregiverSumOrderByAggregateInput
  }

  export type patient_caregiverScalarWhereWithAggregatesInput = {
    AND?: Enumerable<patient_caregiverScalarWhereWithAggregatesInput>
    OR?: Enumerable<patient_caregiverScalarWhereWithAggregatesInput>
    NOT?: Enumerable<patient_caregiverScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    confirmed?: BoolWithAggregatesFilter | boolean
    patient_id?: IntWithAggregatesFilter | number
    caregiver_id?: IntWithAggregatesFilter | number
    role?: EnumPatientCaregiverTypeWithAggregatesFilter | PatientCaregiverType
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    sub?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    type?: EnumUserTypeFilter | UserType
    birthdate?: DateTimeNullableFilter | Date | string | null
    title?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    firstname?: StringNullableFilter | string | null
    lastname?: StringNullableFilter | string | null
    alias?: StringNullableFilter | string | null
    notes?: StringNullableFilter | string | null
    avatarUrl?: StringNullableFilter | string | null
    install_token?: StringNullableFilter | string | null
    subscription?: StringNullableFilter | string | null
    gender?: IntNullableFilter | number | null
    height_cm?: IntNullableFilter | number | null
    weight?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    actsport?: IntNullableFilter | number | null
    actprof?: IntNullableFilter | number | null
    diabetes_type?: IntNullableFilter | number | null
    hypertriglyceridemia?: BoolNullableFilter | boolean | null
    hypercholesterolemia?: BoolNullableFilter | boolean | null
    salt_diet?: IntNullableFilter | number | null
    energy_goal?: IntNullableFilter | number | null
    user_actions?: User_actionListRelationFilter
    favorites?: FavoriteListRelationFilter
    fractionings?: FractioningListRelationFilter
    meals?: MealListRelationFilter
    messages_from?: MessageListRelationFilter
    messages_to?: MessageListRelationFilter
    patients?: Patient_caregiverListRelationFilter
    caregivers?: Patient_caregiverListRelationFilter
    user_centers?: User_centerListRelationFilter
    user_goals?: User_goalListRelationFilter
    user_measurements?: User_measurementListRelationFilter
    user_withings?: User_withingsListRelationFilter
    user_patients?: User_patientListRelationFilter
    user_qcuanswers?: User_qcuanswerListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    sub?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    type?: SortOrder
    birthdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    install_token?: SortOrderInput | SortOrder
    subscription?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    height_cm?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    actsport?: SortOrderInput | SortOrder
    actprof?: SortOrderInput | SortOrder
    diabetes_type?: SortOrderInput | SortOrder
    hypertriglyceridemia?: SortOrderInput | SortOrder
    hypercholesterolemia?: SortOrderInput | SortOrder
    salt_diet?: SortOrderInput | SortOrder
    energy_goal?: SortOrderInput | SortOrder
    user_actions?: user_actionOrderByRelationAggregateInput
    favorites?: favoriteOrderByRelationAggregateInput
    fractionings?: fractioningOrderByRelationAggregateInput
    meals?: mealOrderByRelationAggregateInput
    messages_from?: messageOrderByRelationAggregateInput
    messages_to?: messageOrderByRelationAggregateInput
    patients?: patient_caregiverOrderByRelationAggregateInput
    caregivers?: patient_caregiverOrderByRelationAggregateInput
    user_centers?: user_centerOrderByRelationAggregateInput
    user_goals?: user_goalOrderByRelationAggregateInput
    user_measurements?: user_measurementOrderByRelationAggregateInput
    user_withings?: user_withingsOrderByRelationAggregateInput
    user_patients?: user_patientOrderByRelationAggregateInput
    user_qcuanswers?: user_qcuanswerOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = {
    id?: number
    sub?: string
  }

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    sub?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    type?: SortOrder
    birthdate?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrderInput | SortOrder
    alias?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    install_token?: SortOrderInput | SortOrder
    subscription?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    height_cm?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    actsport?: SortOrderInput | SortOrder
    actprof?: SortOrderInput | SortOrder
    diabetes_type?: SortOrderInput | SortOrder
    hypertriglyceridemia?: SortOrderInput | SortOrder
    hypercholesterolemia?: SortOrderInput | SortOrder
    salt_diet?: SortOrderInput | SortOrder
    energy_goal?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    sub?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    type?: EnumUserTypeWithAggregatesFilter | UserType
    birthdate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    firstname?: StringNullableWithAggregatesFilter | string | null
    lastname?: StringNullableWithAggregatesFilter | string | null
    alias?: StringNullableWithAggregatesFilter | string | null
    notes?: StringNullableWithAggregatesFilter | string | null
    avatarUrl?: StringNullableWithAggregatesFilter | string | null
    install_token?: StringNullableWithAggregatesFilter | string | null
    subscription?: StringNullableWithAggregatesFilter | string | null
    gender?: IntNullableWithAggregatesFilter | number | null
    height_cm?: IntNullableWithAggregatesFilter | number | null
    weight?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    actsport?: IntNullableWithAggregatesFilter | number | null
    actprof?: IntNullableWithAggregatesFilter | number | null
    diabetes_type?: IntNullableWithAggregatesFilter | number | null
    hypertriglyceridemia?: BoolNullableWithAggregatesFilter | boolean | null
    hypercholesterolemia?: BoolNullableWithAggregatesFilter | boolean | null
    salt_diet?: IntNullableWithAggregatesFilter | number | null
    energy_goal?: IntNullableWithAggregatesFilter | number | null
  }

  export type user_centerWhereInput = {
    AND?: Enumerable<user_centerWhereInput>
    OR?: Enumerable<user_centerWhereInput>
    NOT?: Enumerable<user_centerWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    center_id?: IntFilter | number
    role?: EnumCenterRoleFilter | CenterRole
    user?: XOR<UserRelationFilter, userWhereInput>
    center?: XOR<CenterRelationFilter, centerWhereInput>
  }

  export type user_centerOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
    role?: SortOrder
    user?: userOrderByWithRelationInput
    center?: centerOrderByWithRelationInput
  }

  export type user_centerWhereUniqueInput = {
    id?: number
  }

  export type user_centerOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
    role?: SortOrder
    _count?: user_centerCountOrderByAggregateInput
    _avg?: user_centerAvgOrderByAggregateInput
    _max?: user_centerMaxOrderByAggregateInput
    _min?: user_centerMinOrderByAggregateInput
    _sum?: user_centerSumOrderByAggregateInput
  }

  export type user_centerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_centerScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_centerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_centerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    center_id?: IntWithAggregatesFilter | number
    role?: EnumCenterRoleWithAggregatesFilter | CenterRole
  }

  export type user_goalWhereInput = {
    AND?: Enumerable<user_goalWhereInput>
    OR?: Enumerable<user_goalWhereInput>
    NOT?: Enumerable<user_goalWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumGoalTypeFilter | GoalType
    value?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_goalOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type user_goalWhereUniqueInput = {
    id?: number
  }

  export type user_goalOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    _count?: user_goalCountOrderByAggregateInput
    _avg?: user_goalAvgOrderByAggregateInput
    _max?: user_goalMaxOrderByAggregateInput
    _min?: user_goalMinOrderByAggregateInput
    _sum?: user_goalSumOrderByAggregateInput
  }

  export type user_goalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_goalScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_goalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_goalScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumGoalTypeWithAggregatesFilter | GoalType
    value?: StringWithAggregatesFilter | string
  }

  export type user_measurementWhereInput = {
    AND?: Enumerable<user_measurementWhereInput>
    OR?: Enumerable<user_measurementWhereInput>
    NOT?: Enumerable<user_measurementWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumMeasurementTypeFilter | MeasurementType
    value?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_measurementOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type user_measurementWhereUniqueInput = {
    id?: number
    user_id_date_type?: user_measurementUser_idDateTypeCompoundUniqueInput
  }

  export type user_measurementOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrderInput | SortOrder
    _count?: user_measurementCountOrderByAggregateInput
    _avg?: user_measurementAvgOrderByAggregateInput
    _max?: user_measurementMaxOrderByAggregateInput
    _min?: user_measurementMinOrderByAggregateInput
    _sum?: user_measurementSumOrderByAggregateInput
  }

  export type user_measurementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_measurementScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_measurementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_measurementScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    type?: EnumMeasurementTypeWithAggregatesFilter | MeasurementType
    value?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type user_withingsWhereInput = {
    AND?: Enumerable<user_withingsWhereInput>
    OR?: Enumerable<user_withingsWhereInput>
    NOT?: Enumerable<user_withingsWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    withings_userid?: StringFilter | string
    access_token?: StringFilter | string
    refresh_token?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_withingsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    withings_userid?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type user_withingsWhereUniqueInput = {
    id?: number
    user_id_withings_userid?: user_withingsUser_idWithings_useridCompoundUniqueInput
  }

  export type user_withingsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    withings_userid?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    _count?: user_withingsCountOrderByAggregateInput
    _avg?: user_withingsAvgOrderByAggregateInput
    _max?: user_withingsMaxOrderByAggregateInput
    _min?: user_withingsMinOrderByAggregateInput
    _sum?: user_withingsSumOrderByAggregateInput
  }

  export type user_withingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_withingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_withingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_withingsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    withings_userid?: StringWithAggregatesFilter | string
    access_token?: StringWithAggregatesFilter | string
    refresh_token?: StringWithAggregatesFilter | string
  }

  export type user_patientWhereInput = {
    AND?: Enumerable<user_patientWhereInput>
    OR?: Enumerable<user_patientWhereInput>
    NOT?: Enumerable<user_patientWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    protocol_code?: StringNullableFilter | string | null
    protocol_inclusion_date?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type user_patientOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    protocol_code?: SortOrderInput | SortOrder
    protocol_inclusion_date?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type user_patientWhereUniqueInput = {
    id?: number
    user_id_protocol_code?: user_patientUser_idProtocol_codeCompoundUniqueInput
  }

  export type user_patientOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    protocol_code?: SortOrderInput | SortOrder
    protocol_inclusion_date?: SortOrderInput | SortOrder
    _count?: user_patientCountOrderByAggregateInput
    _avg?: user_patientAvgOrderByAggregateInput
    _max?: user_patientMaxOrderByAggregateInput
    _min?: user_patientMinOrderByAggregateInput
    _sum?: user_patientSumOrderByAggregateInput
  }

  export type user_patientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_patientScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_patientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_patientScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    protocol_code?: StringNullableWithAggregatesFilter | string | null
    protocol_inclusion_date?: StringNullableWithAggregatesFilter | string | null
  }

  export type fractioningWhereInput = {
    AND?: Enumerable<fractioningWhereInput>
    OR?: Enumerable<fractioningWhereInput>
    NOT?: Enumerable<fractioningWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: StringNullableFilter | string | null
    meal_types?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type fractioningOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrderInput | SortOrder
    meal_types?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type fractioningWhereUniqueInput = {
    id?: number
    user_id_date?: fractioningUser_idDateCompoundUniqueInput
  }

  export type fractioningOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrderInput | SortOrder
    meal_types?: SortOrderInput | SortOrder
    _count?: fractioningCountOrderByAggregateInput
    _avg?: fractioningAvgOrderByAggregateInput
    _max?: fractioningMaxOrderByAggregateInput
    _min?: fractioningMinOrderByAggregateInput
    _sum?: fractioningSumOrderByAggregateInput
  }

  export type fractioningScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fractioningScalarWhereWithAggregatesInput>
    OR?: Enumerable<fractioningScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fractioningScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    date?: StringNullableWithAggregatesFilter | string | null
    meal_types?: StringNullableWithAggregatesFilter | string | null
  }

  export type meal_elementWhereInput = {
    AND?: Enumerable<meal_elementWhereInput>
    OR?: Enumerable<meal_elementWhereInput>
    NOT?: Enumerable<meal_elementWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    meal_id?: IntFilter | number
    food_id?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    portion_id?: IntNullableFilter | number | null
    portion_cnt?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    food?: XOR<FoodRelationFilter, foodWhereInput> | null
    meal?: XOR<MealRelationFilter, mealWhereInput>
    foodPortion?: XOR<Food_portionRelationFilter, food_portionWhereInput> | null
  }

  export type meal_elementOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    meal_id?: SortOrder
    food_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    portion_id?: SortOrderInput | SortOrder
    portion_cnt?: SortOrderInput | SortOrder
    food?: foodOrderByWithRelationInput
    meal?: mealOrderByWithRelationInput
    foodPortion?: food_portionOrderByWithRelationInput
  }

  export type meal_elementWhereUniqueInput = {
    id?: number
  }

  export type meal_elementOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    meal_id?: SortOrder
    food_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    portion_id?: SortOrderInput | SortOrder
    portion_cnt?: SortOrderInput | SortOrder
    _count?: meal_elementCountOrderByAggregateInput
    _avg?: meal_elementAvgOrderByAggregateInput
    _max?: meal_elementMaxOrderByAggregateInput
    _min?: meal_elementMinOrderByAggregateInput
    _sum?: meal_elementSumOrderByAggregateInput
  }

  export type meal_elementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<meal_elementScalarWhereWithAggregatesInput>
    OR?: Enumerable<meal_elementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<meal_elementScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    meal_id?: IntWithAggregatesFilter | number
    food_id?: IntNullableWithAggregatesFilter | number | null
    weight?: StringNullableWithAggregatesFilter | string | null
    portion_id?: IntNullableWithAggregatesFilter | number | null
    portion_cnt?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type mealWhereInput = {
    AND?: Enumerable<mealWhereInput>
    OR?: Enumerable<mealWhereInput>
    NOT?: Enumerable<mealWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: StringNullableFilter | string | null
    mealtype?: StringNullableFilter | string | null
    really_eaten?: BoolNullableFilter | boolean | null
    meal_elements?: Meal_elementListRelationFilter
    users?: XOR<UserRelationFilter, userWhereInput>
  }

  export type mealOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrderInput | SortOrder
    mealtype?: SortOrderInput | SortOrder
    really_eaten?: SortOrderInput | SortOrder
    meal_elements?: meal_elementOrderByRelationAggregateInput
    users?: userOrderByWithRelationInput
  }

  export type mealWhereUniqueInput = {
    id?: number
    user_id_date_mealtype?: mealUser_idDateMealtypeCompoundUniqueInput
  }

  export type mealOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    date?: SortOrderInput | SortOrder
    mealtype?: SortOrderInput | SortOrder
    really_eaten?: SortOrderInput | SortOrder
    _count?: mealCountOrderByAggregateInput
    _avg?: mealAvgOrderByAggregateInput
    _max?: mealMaxOrderByAggregateInput
    _min?: mealMinOrderByAggregateInput
    _sum?: mealSumOrderByAggregateInput
  }

  export type mealScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mealScalarWhereWithAggregatesInput>
    OR?: Enumerable<mealScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mealScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    date?: StringNullableWithAggregatesFilter | string | null
    mealtype?: StringNullableWithAggregatesFilter | string | null
    really_eaten?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type favoriteWhereInput = {
    AND?: Enumerable<favoriteWhereInput>
    OR?: Enumerable<favoriteWhereInput>
    NOT?: Enumerable<favoriteWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    mealtype?: StringNullableFilter | string | null
    count?: IntNullableFilter | number | null
    food_id?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    portion_id?: IntNullableFilter | number | null
    portion_cnt?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    food?: XOR<FoodRelationFilter, foodWhereInput> | null
    foodPortion?: XOR<Food_portionRelationFilter, food_portionWhereInput> | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type favoriteOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    mealtype?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    food_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    portion_id?: SortOrderInput | SortOrder
    portion_cnt?: SortOrderInput | SortOrder
    food?: foodOrderByWithRelationInput
    foodPortion?: food_portionOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type favoriteWhereUniqueInput = {
    id?: number
    user_id_food_id_mealtype?: favoriteUser_idFood_idMealtypeCompoundUniqueInput
  }

  export type favoriteOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    user_id?: SortOrder
    mealtype?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    food_id?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    portion_id?: SortOrderInput | SortOrder
    portion_cnt?: SortOrderInput | SortOrder
    _count?: favoriteCountOrderByAggregateInput
    _avg?: favoriteAvgOrderByAggregateInput
    _max?: favoriteMaxOrderByAggregateInput
    _min?: favoriteMinOrderByAggregateInput
    _sum?: favoriteSumOrderByAggregateInput
  }

  export type favoriteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<favoriteScalarWhereWithAggregatesInput>
    OR?: Enumerable<favoriteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<favoriteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    mealtype?: StringNullableWithAggregatesFilter | string | null
    count?: IntNullableWithAggregatesFilter | number | null
    food_id?: IntNullableWithAggregatesFilter | number | null
    weight?: StringNullableWithAggregatesFilter | string | null
    portion_id?: IntNullableWithAggregatesFilter | number | null
    portion_cnt?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type categoryWhereInput = {
    AND?: Enumerable<categoryWhereInput>
    OR?: Enumerable<categoryWhereInput>
    NOT?: Enumerable<categoryWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    ciqual_gpcd?: StringNullableFilter | string | null
    member_of_id?: IntNullableFilter | number | null
    rank?: IntNullableFilter | number | null
    tag?: StringNullableFilter | string | null
    food_categories?: Food_categoryListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    ciqual_gpcd?: SortOrderInput | SortOrder
    member_of_id?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    food_categories?: food_categoryOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = {
    id?: number
    tag?: string
  }

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    ciqual_gpcd?: SortOrderInput | SortOrder
    member_of_id?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<categoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<categoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<categoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    shrt_desc?: StringWithAggregatesFilter | string
    long_desc?: StringNullableWithAggregatesFilter | string | null
    ciqual_gpcd?: StringNullableWithAggregatesFilter | string | null
    member_of_id?: IntNullableWithAggregatesFilter | number | null
    rank?: IntNullableWithAggregatesFilter | number | null
    tag?: StringNullableWithAggregatesFilter | string | null
  }

  export type food_categoryWhereInput = {
    AND?: Enumerable<food_categoryWhereInput>
    OR?: Enumerable<food_categoryWhereInput>
    NOT?: Enumerable<food_categoryWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    food_id?: IntFilter | number
    category_id?: IntFilter | number
    categoriy?: XOR<CategoryRelationFilter, categoryWhereInput>
    food?: XOR<FoodRelationFilter, foodWhereInput>
  }

  export type food_categoryOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
    categoriy?: categoryOrderByWithRelationInput
    food?: foodOrderByWithRelationInput
  }

  export type food_categoryWhereUniqueInput = {
    id?: number
  }

  export type food_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
    _count?: food_categoryCountOrderByAggregateInput
    _avg?: food_categoryAvgOrderByAggregateInput
    _max?: food_categoryMaxOrderByAggregateInput
    _min?: food_categoryMinOrderByAggregateInput
    _sum?: food_categorySumOrderByAggregateInput
  }

  export type food_categoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<food_categoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<food_categoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<food_categoryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    food_id?: IntWithAggregatesFilter | number
    category_id?: IntWithAggregatesFilter | number
  }

  export type food_portionWhereInput = {
    AND?: Enumerable<food_portionWhereInput>
    OR?: Enumerable<food_portionWhereInput>
    NOT?: Enumerable<food_portionWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    qty?: StringFilter | string
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    pict?: StringNullableFilter | string | null
    food_id?: IntFilter | number
    food?: XOR<FoodRelationFilter, foodWhereInput>
    mealElements?: Meal_elementListRelationFilter
    favorites?: FavoriteListRelationFilter
  }

  export type food_portionOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    qty?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    food_id?: SortOrder
    food?: foodOrderByWithRelationInput
    mealElements?: meal_elementOrderByRelationAggregateInput
    favorites?: favoriteOrderByRelationAggregateInput
  }

  export type food_portionWhereUniqueInput = {
    id?: number
  }

  export type food_portionOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    qty?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    food_id?: SortOrder
    _count?: food_portionCountOrderByAggregateInput
    _avg?: food_portionAvgOrderByAggregateInput
    _max?: food_portionMaxOrderByAggregateInput
    _min?: food_portionMinOrderByAggregateInput
    _sum?: food_portionSumOrderByAggregateInput
  }

  export type food_portionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<food_portionScalarWhereWithAggregatesInput>
    OR?: Enumerable<food_portionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<food_portionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    qty?: StringWithAggregatesFilter | string
    shrt_desc?: StringWithAggregatesFilter | string
    long_desc?: StringNullableWithAggregatesFilter | string | null
    note?: StringNullableWithAggregatesFilter | string | null
    pict?: StringNullableWithAggregatesFilter | string | null
    food_id?: IntWithAggregatesFilter | number
  }

  export type foodWhereInput = {
    AND?: Enumerable<foodWhereInput>
    OR?: Enumerable<foodWhereInput>
    NOT?: Enumerable<foodWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    ciqual_name?: StringNullableFilter | string | null
    ctdit_shrt_desc?: StringNullableFilter | string | null
    ctdit_long_desc?: StringNullableFilter | string | null
    keywords?: StringNullableFilter | string | null
    ciqual_num?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    max_qty?: StringNullableFilter | string | null
    pict?: StringNullableFilter | string | null
    source_id?: IntFilter | number
    is_brand?: BoolNullableFilter | boolean | null
    is_raw?: BoolNullableFilter | boolean | null
    is_indivisible?: BoolNullableFilter | boolean | null
    is_chu?: BoolNullableFilter | boolean | null
    is_demo?: BoolNullableFilter | boolean | null
    is_patient_full?: BoolNullableFilter | boolean | null
    is_patient_simplified?: BoolNullableFilter | boolean | null
    pack_pict?: StringNullableFilter | string | null
    is_validated?: BoolNullableFilter | boolean | null
    food_categories?: Food_categoryListRelationFilter
    food_portions?: Food_portionListRelationFilter
    source?: XOR<SourceRelationFilter, sourceWhereInput>
    nutdata?: NutdataListRelationFilter
    mealElements?: Meal_elementListRelationFilter
    favorites?: FavoriteListRelationFilter
  }

  export type foodOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    ciqual_name?: SortOrderInput | SortOrder
    ctdit_shrt_desc?: SortOrderInput | SortOrder
    ctdit_long_desc?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    ciqual_num?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    max_qty?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    source_id?: SortOrder
    is_brand?: SortOrderInput | SortOrder
    is_raw?: SortOrderInput | SortOrder
    is_indivisible?: SortOrderInput | SortOrder
    is_chu?: SortOrderInput | SortOrder
    is_demo?: SortOrderInput | SortOrder
    is_patient_full?: SortOrderInput | SortOrder
    is_patient_simplified?: SortOrderInput | SortOrder
    pack_pict?: SortOrderInput | SortOrder
    is_validated?: SortOrderInput | SortOrder
    food_categories?: food_categoryOrderByRelationAggregateInput
    food_portions?: food_portionOrderByRelationAggregateInput
    source?: sourceOrderByWithRelationInput
    nutdata?: nutdataOrderByRelationAggregateInput
    mealElements?: meal_elementOrderByRelationAggregateInput
    favorites?: favoriteOrderByRelationAggregateInput
  }

  export type foodWhereUniqueInput = {
    id?: number
  }

  export type foodOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    ciqual_name?: SortOrderInput | SortOrder
    ctdit_shrt_desc?: SortOrderInput | SortOrder
    ctdit_long_desc?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    ciqual_num?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    max_qty?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    source_id?: SortOrder
    is_brand?: SortOrderInput | SortOrder
    is_raw?: SortOrderInput | SortOrder
    is_indivisible?: SortOrderInput | SortOrder
    is_chu?: SortOrderInput | SortOrder
    is_demo?: SortOrderInput | SortOrder
    is_patient_full?: SortOrderInput | SortOrder
    is_patient_simplified?: SortOrderInput | SortOrder
    pack_pict?: SortOrderInput | SortOrder
    is_validated?: SortOrderInput | SortOrder
    _count?: foodCountOrderByAggregateInput
    _avg?: foodAvgOrderByAggregateInput
    _max?: foodMaxOrderByAggregateInput
    _min?: foodMinOrderByAggregateInput
    _sum?: foodSumOrderByAggregateInput
  }

  export type foodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<foodScalarWhereWithAggregatesInput>
    OR?: Enumerable<foodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<foodScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    shrt_desc?: StringWithAggregatesFilter | string
    long_desc?: StringNullableWithAggregatesFilter | string | null
    ciqual_name?: StringNullableWithAggregatesFilter | string | null
    ctdit_shrt_desc?: StringNullableWithAggregatesFilter | string | null
    ctdit_long_desc?: StringNullableWithAggregatesFilter | string | null
    keywords?: StringNullableWithAggregatesFilter | string | null
    ciqual_num?: StringNullableWithAggregatesFilter | string | null
    note?: StringNullableWithAggregatesFilter | string | null
    max_qty?: StringNullableWithAggregatesFilter | string | null
    pict?: StringNullableWithAggregatesFilter | string | null
    source_id?: IntWithAggregatesFilter | number
    is_brand?: BoolNullableWithAggregatesFilter | boolean | null
    is_raw?: BoolNullableWithAggregatesFilter | boolean | null
    is_indivisible?: BoolNullableWithAggregatesFilter | boolean | null
    is_chu?: BoolNullableWithAggregatesFilter | boolean | null
    is_demo?: BoolNullableWithAggregatesFilter | boolean | null
    is_patient_full?: BoolNullableWithAggregatesFilter | boolean | null
    is_patient_simplified?: BoolNullableWithAggregatesFilter | boolean | null
    pack_pict?: StringNullableWithAggregatesFilter | string | null
    is_validated?: BoolNullableWithAggregatesFilter | boolean | null
  }

  export type nutdataWhereInput = {
    AND?: Enumerable<nutdataWhereInput>
    OR?: Enumerable<nutdataWhereInput>
    NOT?: Enumerable<nutdataWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    val?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    food_id?: IntFilter | number
    nutr_no?: StringFilter | string
    source_id?: IntFilter | number
    food?: XOR<FoodRelationFilter, foodWhereInput>
    nutrient?: XOR<NutrientRelationFilter, nutrientWhereInput>
    source?: XOR<SourceRelationFilter, sourceWhereInput>
  }

  export type nutdataOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    val?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    food_id?: SortOrder
    nutr_no?: SortOrder
    source_id?: SortOrder
    food?: foodOrderByWithRelationInput
    nutrient?: nutrientOrderByWithRelationInput
    source?: sourceOrderByWithRelationInput
  }

  export type nutdataWhereUniqueInput = {
    id?: number
  }

  export type nutdataOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    val?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    food_id?: SortOrder
    nutr_no?: SortOrder
    source_id?: SortOrder
    _count?: nutdataCountOrderByAggregateInput
    _avg?: nutdataAvgOrderByAggregateInput
    _max?: nutdataMaxOrderByAggregateInput
    _min?: nutdataMinOrderByAggregateInput
    _sum?: nutdataSumOrderByAggregateInput
  }

  export type nutdataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<nutdataScalarWhereWithAggregatesInput>
    OR?: Enumerable<nutdataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<nutdataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    val?: StringNullableWithAggregatesFilter | string | null
    note?: StringNullableWithAggregatesFilter | string | null
    food_id?: IntWithAggregatesFilter | number
    nutr_no?: StringWithAggregatesFilter | string
    source_id?: IntWithAggregatesFilter | number
  }

  export type nutrientWhereInput = {
    AND?: Enumerable<nutrientWhereInput>
    OR?: Enumerable<nutrientWhereInput>
    NOT?: Enumerable<nutrientWhereInput>
    nutr_no?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    ifda_no?: StringNullableFilter | string | null
    unit?: StringNullableFilter | string | null
    shrt_desc?: StringNullableFilter | string | null
    long_desc?: StringNullableFilter | string | null
    energy_density?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    nutdata?: NutdataListRelationFilter
  }

  export type nutrientOrderByWithRelationInput = {
    nutr_no?: SortOrder
    created_at?: SortOrderInput | SortOrder
    ifda_no?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    shrt_desc?: SortOrderInput | SortOrder
    long_desc?: SortOrderInput | SortOrder
    energy_density?: SortOrderInput | SortOrder
    nutdata?: nutdataOrderByRelationAggregateInput
  }

  export type nutrientWhereUniqueInput = {
    nutr_no?: string
  }

  export type nutrientOrderByWithAggregationInput = {
    nutr_no?: SortOrder
    created_at?: SortOrderInput | SortOrder
    ifda_no?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    shrt_desc?: SortOrderInput | SortOrder
    long_desc?: SortOrderInput | SortOrder
    energy_density?: SortOrderInput | SortOrder
    _count?: nutrientCountOrderByAggregateInput
    _avg?: nutrientAvgOrderByAggregateInput
    _max?: nutrientMaxOrderByAggregateInput
    _min?: nutrientMinOrderByAggregateInput
    _sum?: nutrientSumOrderByAggregateInput
  }

  export type nutrientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<nutrientScalarWhereWithAggregatesInput>
    OR?: Enumerable<nutrientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<nutrientScalarWhereWithAggregatesInput>
    nutr_no?: StringWithAggregatesFilter | string
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ifda_no?: StringNullableWithAggregatesFilter | string | null
    unit?: StringNullableWithAggregatesFilter | string | null
    shrt_desc?: StringNullableWithAggregatesFilter | string | null
    long_desc?: StringNullableWithAggregatesFilter | string | null
    energy_density?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type sourceWhereInput = {
    AND?: Enumerable<sourceWhereInput>
    OR?: Enumerable<sourceWhereInput>
    NOT?: Enumerable<sourceWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    foods?: FoodListRelationFilter
    nutdata?: NutdataListRelationFilter
  }

  export type sourceOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    foods?: foodOrderByRelationAggregateInput
    nutdata?: nutdataOrderByRelationAggregateInput
  }

  export type sourceWhereUniqueInput = {
    id?: number
  }

  export type sourceOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    _count?: sourceCountOrderByAggregateInput
    _avg?: sourceAvgOrderByAggregateInput
    _max?: sourceMaxOrderByAggregateInput
    _min?: sourceMinOrderByAggregateInput
    _sum?: sourceSumOrderByAggregateInput
  }

  export type sourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<sourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sourceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    shrt_desc?: StringWithAggregatesFilter | string
    long_desc?: StringNullableWithAggregatesFilter | string | null
  }

  export type dishWhereInput = {
    AND?: Enumerable<dishWhereInput>
    OR?: Enumerable<dishWhereInput>
    NOT?: Enumerable<dishWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    pict?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    shrt_source?: StringFilter | string
    long_source?: StringNullableFilter | string | null
    qty_max?: StringNullableFilter | string | null
    resume?: StringNullableFilter | string | null
    recette?: StringNullableFilter | string | null
    nbpersonnes?: IntFilter | number
    qte?: StringFilter | string
    diabete?: StringFilter | string
    cardiaque?: StringFilter | string
    obese?: StringFilter | string
    ssel?: StringFilter | string
    chol?: StringFilter | string
    trigly?: StringFilter | string
    maxqty?: FloatFilter | number
  }

  export type dishOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    shrt_source?: SortOrder
    long_source?: SortOrderInput | SortOrder
    qty_max?: SortOrderInput | SortOrder
    resume?: SortOrderInput | SortOrder
    recette?: SortOrderInput | SortOrder
    nbpersonnes?: SortOrder
    qte?: SortOrder
    diabete?: SortOrder
    cardiaque?: SortOrder
    obese?: SortOrder
    ssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    maxqty?: SortOrder
  }

  export type dishWhereUniqueInput = {
    id?: number
  }

  export type dishOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrderInput | SortOrder
    pict?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    shrt_source?: SortOrder
    long_source?: SortOrderInput | SortOrder
    qty_max?: SortOrderInput | SortOrder
    resume?: SortOrderInput | SortOrder
    recette?: SortOrderInput | SortOrder
    nbpersonnes?: SortOrder
    qte?: SortOrder
    diabete?: SortOrder
    cardiaque?: SortOrder
    obese?: SortOrder
    ssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    maxqty?: SortOrder
    _count?: dishCountOrderByAggregateInput
    _avg?: dishAvgOrderByAggregateInput
    _max?: dishMaxOrderByAggregateInput
    _min?: dishMinOrderByAggregateInput
    _sum?: dishSumOrderByAggregateInput
  }

  export type dishScalarWhereWithAggregatesInput = {
    AND?: Enumerable<dishScalarWhereWithAggregatesInput>
    OR?: Enumerable<dishScalarWhereWithAggregatesInput>
    NOT?: Enumerable<dishScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    shrt_desc?: StringWithAggregatesFilter | string
    long_desc?: StringNullableWithAggregatesFilter | string | null
    pict?: StringNullableWithAggregatesFilter | string | null
    note?: StringNullableWithAggregatesFilter | string | null
    shrt_source?: StringWithAggregatesFilter | string
    long_source?: StringNullableWithAggregatesFilter | string | null
    qty_max?: StringNullableWithAggregatesFilter | string | null
    resume?: StringNullableWithAggregatesFilter | string | null
    recette?: StringNullableWithAggregatesFilter | string | null
    nbpersonnes?: IntWithAggregatesFilter | number
    qte?: StringWithAggregatesFilter | string
    diabete?: StringWithAggregatesFilter | string
    cardiaque?: StringWithAggregatesFilter | string
    obese?: StringWithAggregatesFilter | string
    ssel?: StringWithAggregatesFilter | string
    chol?: StringWithAggregatesFilter | string
    trigly?: StringWithAggregatesFilter | string
    maxqty?: FloatWithAggregatesFilter | number
  }

  export type lexiconWhereInput = {
    AND?: Enumerable<lexiconWhereInput>
    OR?: Enumerable<lexiconWhereInput>
    NOT?: Enumerable<lexiconWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    code?: StringFilter | string
    title?: StringFilter | string
    text?: StringFilter | string
  }

  export type lexiconOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    code?: SortOrder
    title?: SortOrder
    text?: SortOrder
  }

  export type lexiconWhereUniqueInput = {
    id?: number
    code?: string
  }

  export type lexiconOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    code?: SortOrder
    title?: SortOrder
    text?: SortOrder
    _count?: lexiconCountOrderByAggregateInput
    _avg?: lexiconAvgOrderByAggregateInput
    _max?: lexiconMaxOrderByAggregateInput
    _min?: lexiconMinOrderByAggregateInput
    _sum?: lexiconSumOrderByAggregateInput
  }

  export type lexiconScalarWhereWithAggregatesInput = {
    AND?: Enumerable<lexiconScalarWhereWithAggregatesInput>
    OR?: Enumerable<lexiconScalarWhereWithAggregatesInput>
    NOT?: Enumerable<lexiconScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    code?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
  }

  export type qcu_imageWhereInput = {
    AND?: Enumerable<qcu_imageWhereInput>
    OR?: Enumerable<qcu_imageWhereInput>
    NOT?: Enumerable<qcu_imageWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    pict?: StringFilter | string
    question_id?: IntFilter | number
    question?: XOR<Qcu_questionRelationFilter, qcu_questionWhereInput>
  }

  export type qcu_imageOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    pict?: SortOrder
    question_id?: SortOrder
    question?: qcu_questionOrderByWithRelationInput
  }

  export type qcu_imageWhereUniqueInput = {
    id?: number
  }

  export type qcu_imageOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    pict?: SortOrder
    question_id?: SortOrder
    _count?: qcu_imageCountOrderByAggregateInput
    _avg?: qcu_imageAvgOrderByAggregateInput
    _max?: qcu_imageMaxOrderByAggregateInput
    _min?: qcu_imageMinOrderByAggregateInput
    _sum?: qcu_imageSumOrderByAggregateInput
  }

  export type qcu_imageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<qcu_imageScalarWhereWithAggregatesInput>
    OR?: Enumerable<qcu_imageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<qcu_imageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    pict?: StringWithAggregatesFilter | string
    question_id?: IntWithAggregatesFilter | number
  }

  export type qcu_questionWhereInput = {
    AND?: Enumerable<qcu_questionWhereInput>
    OR?: Enumerable<qcu_questionWhereInput>
    NOT?: Enumerable<qcu_questionWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    note?: StringFilter | string
    type?: StringFilter | string
    level?: StringFilter | string
    question?: StringFilter | string
    diabete?: StringFilter | string
    sssel?: StringFilter | string
    chol?: StringFilter | string
    trigly?: StringFilter | string
    items?: Qcu_itemListRelationFilter
    images?: Qcu_imageListRelationFilter
    answers?: User_qcuanswerListRelationFilter
  }

  export type qcu_questionOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    note?: SortOrder
    type?: SortOrder
    level?: SortOrder
    question?: SortOrder
    diabete?: SortOrder
    sssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    items?: qcu_itemOrderByRelationAggregateInput
    images?: qcu_imageOrderByRelationAggregateInput
    answers?: user_qcuanswerOrderByRelationAggregateInput
  }

  export type qcu_questionWhereUniqueInput = {
    id?: number
  }

  export type qcu_questionOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    note?: SortOrder
    type?: SortOrder
    level?: SortOrder
    question?: SortOrder
    diabete?: SortOrder
    sssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    _count?: qcu_questionCountOrderByAggregateInput
    _avg?: qcu_questionAvgOrderByAggregateInput
    _max?: qcu_questionMaxOrderByAggregateInput
    _min?: qcu_questionMinOrderByAggregateInput
    _sum?: qcu_questionSumOrderByAggregateInput
  }

  export type qcu_questionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<qcu_questionScalarWhereWithAggregatesInput>
    OR?: Enumerable<qcu_questionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<qcu_questionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    note?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    level?: StringWithAggregatesFilter | string
    question?: StringWithAggregatesFilter | string
    diabete?: StringWithAggregatesFilter | string
    sssel?: StringWithAggregatesFilter | string
    chol?: StringWithAggregatesFilter | string
    trigly?: StringWithAggregatesFilter | string
  }

  export type qcu_itemWhereInput = {
    AND?: Enumerable<qcu_itemWhereInput>
    OR?: Enumerable<qcu_itemWhereInput>
    NOT?: Enumerable<qcu_itemWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    proposition?: StringFilter | string
    pict?: StringFilter | string
    answer?: StringFilter | string
    success?: BoolFilter | boolean
    question_id?: IntFilter | number
    question?: XOR<Qcu_questionRelationFilter, qcu_questionWhereInput>
  }

  export type qcu_itemOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    proposition?: SortOrder
    pict?: SortOrder
    answer?: SortOrder
    success?: SortOrder
    question_id?: SortOrder
    question?: qcu_questionOrderByWithRelationInput
  }

  export type qcu_itemWhereUniqueInput = {
    id?: number
  }

  export type qcu_itemOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    proposition?: SortOrder
    pict?: SortOrder
    answer?: SortOrder
    success?: SortOrder
    question_id?: SortOrder
    _count?: qcu_itemCountOrderByAggregateInput
    _avg?: qcu_itemAvgOrderByAggregateInput
    _max?: qcu_itemMaxOrderByAggregateInput
    _min?: qcu_itemMinOrderByAggregateInput
    _sum?: qcu_itemSumOrderByAggregateInput
  }

  export type qcu_itemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<qcu_itemScalarWhereWithAggregatesInput>
    OR?: Enumerable<qcu_itemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<qcu_itemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    proposition?: StringWithAggregatesFilter | string
    pict?: StringWithAggregatesFilter | string
    answer?: StringWithAggregatesFilter | string
    success?: BoolWithAggregatesFilter | boolean
    question_id?: IntWithAggregatesFilter | number
  }

  export type user_qcuanswerWhereInput = {
    AND?: Enumerable<user_qcuanswerWhereInput>
    OR?: Enumerable<user_qcuanswerWhereInput>
    NOT?: Enumerable<user_qcuanswerWhereInput>
    id?: IntFilter | number
    timestamp?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    qcuquestion_id?: IntFilter | number
    success?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, userWhereInput>
    question?: XOR<Qcu_questionRelationFilter, qcu_questionWhereInput>
  }

  export type user_qcuanswerOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
    success?: SortOrder
    user?: userOrderByWithRelationInput
    question?: qcu_questionOrderByWithRelationInput
  }

  export type user_qcuanswerWhereUniqueInput = {
    id?: number
  }

  export type user_qcuanswerOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrderInput | SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
    success?: SortOrder
    _count?: user_qcuanswerCountOrderByAggregateInput
    _avg?: user_qcuanswerAvgOrderByAggregateInput
    _max?: user_qcuanswerMaxOrderByAggregateInput
    _min?: user_qcuanswerMinOrderByAggregateInput
    _sum?: user_qcuanswerSumOrderByAggregateInput
  }

  export type user_qcuanswerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_qcuanswerScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_qcuanswerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_qcuanswerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    user_id?: IntWithAggregatesFilter | number
    qcuquestion_id?: IntWithAggregatesFilter | number
    success?: BoolWithAggregatesFilter | boolean
  }

  export type sessionCreateInput = {
    startTime: Date | string
    endTime?: Date | string | null
    user_actions?: user_actionCreateNestedManyWithoutSessionInput
  }

  export type sessionUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type sessionUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_actions?: user_actionUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_actions?: user_actionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type sessionCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type sessionUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_actionCreateInput = {
    time: Date | string
    action: string
    session: sessionCreateNestedOneWithoutUser_actionsInput
    user: userCreateNestedOneWithoutUser_actionsInput
  }

  export type user_actionUncheckedCreateInput = {
    id?: number
    session_id: number
    time: Date | string
    user_id: number
    action: string
  }

  export type user_actionUpdateInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    session?: sessionUpdateOneRequiredWithoutUser_actionsNestedInput
    user?: userUpdateOneRequiredWithoutUser_actionsNestedInput
  }

  export type user_actionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
  }

  export type user_actionCreateManyInput = {
    id?: number
    session_id: number
    time: Date | string
    user_id: number
    action: string
  }

  export type user_actionUpdateManyMutationInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type user_actionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
  }

  export type centerCreateInput = {
    created_at?: Date | string | null
    type: CenterType
    name: string
    user_centers?: user_centerCreateNestedManyWithoutCenterInput
  }

  export type centerUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    type: CenterType
    name: string
    user_centers?: user_centerUncheckedCreateNestedManyWithoutCenterInput
  }

  export type centerUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
    user_centers?: user_centerUpdateManyWithoutCenterNestedInput
  }

  export type centerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
    user_centers?: user_centerUncheckedUpdateManyWithoutCenterNestedInput
  }

  export type centerCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    type: CenterType
    name: string
  }

  export type centerUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
  }

  export type centerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
  }

  export type messageCreateInput = {
    created_at?: Date | string | null
    read_on?: Date | string | null
    content: string
    from: userCreateNestedOneWithoutMessages_fromInput
    to: userCreateNestedOneWithoutMessages_toInput
  }

  export type messageUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    from_id: number
    to_id: number
    read_on?: Date | string | null
    content: string
  }

  export type messageUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    from?: userUpdateOneRequiredWithoutMessages_fromNestedInput
    to?: userUpdateOneRequiredWithoutMessages_toNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    from_id?: IntFieldUpdateOperationsInput | number
    to_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type messageCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    from_id: number
    to_id: number
    read_on?: Date | string | null
    content: string
  }

  export type messageUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    from_id?: IntFieldUpdateOperationsInput | number
    to_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type patient_caregiverCreateInput = {
    created_at?: Date | string | null
    confirmed?: boolean
    role: PatientCaregiverType
    patient: userCreateNestedOneWithoutPatientsInput
    caregiver: userCreateNestedOneWithoutCaregiversInput
  }

  export type patient_caregiverUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    patient_id: number
    caregiver_id: number
    role: PatientCaregiverType
  }

  export type patient_caregiverUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
    patient?: userUpdateOneRequiredWithoutPatientsNestedInput
    caregiver?: userUpdateOneRequiredWithoutCaregiversNestedInput
  }

  export type patient_caregiverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    patient_id?: IntFieldUpdateOperationsInput | number
    caregiver_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type patient_caregiverCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    patient_id: number
    caregiver_id: number
    role: PatientCaregiverType
  }

  export type patient_caregiverUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type patient_caregiverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    patient_id?: IntFieldUpdateOperationsInput | number
    caregiver_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type userCreateInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
  }

  export type userUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type user_centerCreateInput = {
    created_at?: Date | string | null
    role: CenterRole
    user: userCreateNestedOneWithoutUser_centersInput
    center: centerCreateNestedOneWithoutUser_centersInput
  }

  export type user_centerUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    center_id: number
    role: CenterRole
  }

  export type user_centerUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
    user?: userUpdateOneRequiredWithoutUser_centersNestedInput
    center?: centerUpdateOneRequiredWithoutUser_centersNestedInput
  }

  export type user_centerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    center_id?: IntFieldUpdateOperationsInput | number
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_centerCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    center_id: number
    role: CenterRole
  }

  export type user_centerUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_centerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    center_id?: IntFieldUpdateOperationsInput | number
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_goalCreateInput = {
    created_at?: Date | string | null
    date: Date | string
    type: GoalType
    value: string
    user: userCreateNestedOneWithoutUser_goalsInput
  }

  export type user_goalUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date: Date | string
    type: GoalType
    value: string
  }

  export type user_goalUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutUser_goalsNestedInput
  }

  export type user_goalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_goalCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date: Date | string
    type: GoalType
    value: string
  }

  export type user_goalUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_goalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_measurementCreateInput = {
    created_at?: Date | string | null
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
    user: userCreateNestedOneWithoutUser_measurementsInput
  }

  export type user_measurementUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: userUpdateOneRequiredWithoutUser_measurementsNestedInput
  }

  export type user_measurementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_withingsCreateInput = {
    created_at?: Date | string | null
    withings_userid: string
    access_token: string
    refresh_token: string
    user: userCreateNestedOneWithoutUser_withingsInput
  }

  export type user_withingsUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    withings_userid: string
    access_token: string
    refresh_token: string
  }

  export type user_withingsUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutUser_withingsNestedInput
  }

  export type user_withingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_withingsCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    withings_userid: string
    access_token: string
    refresh_token: string
  }

  export type user_withingsUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_withingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_patientCreateInput = {
    created_at?: Date | string | null
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
    user: userCreateNestedOneWithoutUser_patientsInput
  }

  export type user_patientUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
  }

  export type user_patientUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutUser_patientsNestedInput
  }

  export type user_patientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_patientCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
  }

  export type user_patientUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_patientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fractioningCreateInput = {
    created_at?: Date | string | null
    date?: string | null
    meal_types?: string | null
    user: userCreateNestedOneWithoutFractioningsInput
  }

  export type fractioningUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date?: string | null
    meal_types?: string | null
  }

  export type fractioningUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutFractioningsNestedInput
  }

  export type fractioningUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fractioningCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date?: string | null
    meal_types?: string | null
  }

  export type fractioningUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fractioningUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type meal_elementCreateInput = {
    created_at?: Date | string | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutMealElementsInput
    meal: mealCreateNestedOneWithoutMeal_elementsInput
    foodPortion?: food_portionCreateNestedOneWithoutMealElementsInput
  }

  export type meal_elementUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutMealElementsNestedInput
    meal?: mealUpdateOneRequiredWithoutMeal_elementsNestedInput
    foodPortion?: food_portionUpdateOneWithoutMealElementsNestedInput
  }

  export type meal_elementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meal_id?: IntFieldUpdateOperationsInput | number
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meal_id?: IntFieldUpdateOperationsInput | number
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type mealCreateInput = {
    created_at?: Date | string | null
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
    meal_elements?: meal_elementCreateNestedManyWithoutMealInput
    users: userCreateNestedOneWithoutMealsInput
  }

  export type mealUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
    meal_elements?: meal_elementUncheckedCreateNestedManyWithoutMealInput
  }

  export type mealUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meal_elements?: meal_elementUpdateManyWithoutMealNestedInput
    users?: userUpdateOneRequiredWithoutMealsNestedInput
  }

  export type mealUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meal_elements?: meal_elementUncheckedUpdateManyWithoutMealNestedInput
  }

  export type mealCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
  }

  export type mealUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mealUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type favoriteCreateInput = {
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutFavoritesInput
    foodPortion?: food_portionCreateNestedOneWithoutFavoritesInput
    user: userCreateNestedOneWithoutFavoritesInput
  }

  export type favoriteUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutFavoritesNestedInput
    foodPortion?: food_portionUpdateOneWithoutFavoritesNestedInput
    user?: userUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type favoriteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type categoryCreateInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_gpcd?: string | null
    member_of_id?: number | null
    rank?: number | null
    tag?: string | null
    food_categories?: food_categoryCreateNestedManyWithoutCategoriyInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_gpcd?: string | null
    member_of_id?: number | null
    rank?: number | null
    tag?: string | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutCategoriyInput
  }

  export type categoryUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    food_categories?: food_categoryUpdateManyWithoutCategoriyNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutCategoriyNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_gpcd?: string | null
    member_of_id?: number | null
    rank?: number | null
    tag?: string | null
  }

  export type categoryUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type food_categoryCreateInput = {
    created_at?: Date | string | null
    categoriy: categoryCreateNestedOneWithoutFood_categoriesInput
    food: foodCreateNestedOneWithoutFood_categoriesInput
  }

  export type food_categoryUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    food_id: number
    category_id: number
  }

  export type food_categoryUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoriy?: categoryUpdateOneRequiredWithoutFood_categoriesNestedInput
    food?: foodUpdateOneRequiredWithoutFood_categoriesNestedInput
  }

  export type food_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type food_categoryCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    food_id: number
    category_id: number
  }

  export type food_categoryUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type food_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type food_portionCreateInput = {
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food: foodCreateNestedOneWithoutFood_portionsInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodPortionInput
    favorites?: favoriteCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food_id: number
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodPortionInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutFood_portionsNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodPortionNestedInput
    favorites?: favoriteUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodPortionNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food_id: number
  }

  export type food_portionUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type food_portionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
  }

  export type foodCreateInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type foodCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
  }

  export type foodUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type foodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type nutdataCreateInput = {
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food: foodCreateNestedOneWithoutNutdataInput
    nutrient: nutrientCreateNestedOneWithoutNutdataInput
    source: sourceCreateNestedOneWithoutNutdataInput
  }

  export type nutdataUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    nutr_no: string
    source_id: number
  }

  export type nutdataUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutNutdataNestedInput
    nutrient?: nutrientUpdateOneRequiredWithoutNutdataNestedInput
    source?: sourceUpdateOneRequiredWithoutNutdataNestedInput
  }

  export type nutdataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    nutr_no?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type nutdataCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    nutr_no: string
    source_id: number
  }

  export type nutdataUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nutdataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    nutr_no?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type nutrientCreateInput = {
    nutr_no: string
    created_at?: Date | string | null
    ifda_no?: string | null
    unit?: string | null
    shrt_desc?: string | null
    long_desc?: string | null
    energy_density?: Decimal | DecimalJsLike | number | string | null
    nutdata?: nutdataCreateNestedManyWithoutNutrientInput
  }

  export type nutrientUncheckedCreateInput = {
    nutr_no: string
    created_at?: Date | string | null
    ifda_no?: string | null
    unit?: string | null
    shrt_desc?: string | null
    long_desc?: string | null
    energy_density?: Decimal | DecimalJsLike | number | string | null
    nutdata?: nutdataUncheckedCreateNestedManyWithoutNutrientInput
  }

  export type nutrientUpdateInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nutdata?: nutdataUpdateManyWithoutNutrientNestedInput
  }

  export type nutrientUncheckedUpdateInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nutdata?: nutdataUncheckedUpdateManyWithoutNutrientNestedInput
  }

  export type nutrientCreateManyInput = {
    nutr_no: string
    created_at?: Date | string | null
    ifda_no?: string | null
    unit?: string | null
    shrt_desc?: string | null
    long_desc?: string | null
    energy_density?: Decimal | DecimalJsLike | number | string | null
  }

  export type nutrientUpdateManyMutationInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type nutrientUncheckedUpdateManyInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type sourceCreateInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    foods?: foodCreateNestedManyWithoutSourceInput
    nutdata?: nutdataCreateNestedManyWithoutSourceInput
  }

  export type sourceUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    foods?: foodUncheckedCreateNestedManyWithoutSourceInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutSourceInput
  }

  export type sourceUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    foods?: foodUpdateManyWithoutSourceNestedInput
    nutdata?: nutdataUpdateManyWithoutSourceNestedInput
  }

  export type sourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    foods?: foodUncheckedUpdateManyWithoutSourceNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type sourceCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
  }

  export type sourceUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dishCreateInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    pict?: string | null
    note?: string | null
    shrt_source: string
    long_source?: string | null
    qty_max?: string | null
    resume?: string | null
    recette?: string | null
    nbpersonnes: number
    qte: string
    diabete?: string
    cardiaque?: string
    obese?: string
    ssel?: string
    chol?: string
    trigly?: string
    maxqty: number
  }

  export type dishUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    pict?: string | null
    note?: string | null
    shrt_source: string
    long_source?: string | null
    qty_max?: string | null
    resume?: string | null
    recette?: string | null
    nbpersonnes: number
    qte: string
    diabete?: string
    cardiaque?: string
    obese?: string
    ssel?: string
    chol?: string
    trigly?: string
    maxqty: number
  }

  export type dishUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_source?: StringFieldUpdateOperationsInput | string
    long_source?: NullableStringFieldUpdateOperationsInput | string | null
    qty_max?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: NullableStringFieldUpdateOperationsInput | string | null
    nbpersonnes?: IntFieldUpdateOperationsInput | number
    qte?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    cardiaque?: StringFieldUpdateOperationsInput | string
    obese?: StringFieldUpdateOperationsInput | string
    ssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    maxqty?: FloatFieldUpdateOperationsInput | number
  }

  export type dishUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_source?: StringFieldUpdateOperationsInput | string
    long_source?: NullableStringFieldUpdateOperationsInput | string | null
    qty_max?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: NullableStringFieldUpdateOperationsInput | string | null
    nbpersonnes?: IntFieldUpdateOperationsInput | number
    qte?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    cardiaque?: StringFieldUpdateOperationsInput | string
    obese?: StringFieldUpdateOperationsInput | string
    ssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    maxqty?: FloatFieldUpdateOperationsInput | number
  }

  export type dishCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    pict?: string | null
    note?: string | null
    shrt_source: string
    long_source?: string | null
    qty_max?: string | null
    resume?: string | null
    recette?: string | null
    nbpersonnes: number
    qte: string
    diabete?: string
    cardiaque?: string
    obese?: string
    ssel?: string
    chol?: string
    trigly?: string
    maxqty: number
  }

  export type dishUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_source?: StringFieldUpdateOperationsInput | string
    long_source?: NullableStringFieldUpdateOperationsInput | string | null
    qty_max?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: NullableStringFieldUpdateOperationsInput | string | null
    nbpersonnes?: IntFieldUpdateOperationsInput | number
    qte?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    cardiaque?: StringFieldUpdateOperationsInput | string
    obese?: StringFieldUpdateOperationsInput | string
    ssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    maxqty?: FloatFieldUpdateOperationsInput | number
  }

  export type dishUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_source?: StringFieldUpdateOperationsInput | string
    long_source?: NullableStringFieldUpdateOperationsInput | string | null
    qty_max?: NullableStringFieldUpdateOperationsInput | string | null
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    recette?: NullableStringFieldUpdateOperationsInput | string | null
    nbpersonnes?: IntFieldUpdateOperationsInput | number
    qte?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    cardiaque?: StringFieldUpdateOperationsInput | string
    obese?: StringFieldUpdateOperationsInput | string
    ssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    maxqty?: FloatFieldUpdateOperationsInput | number
  }

  export type lexiconCreateInput = {
    created_at?: Date | string | null
    code: string
    title: string
    text: string
  }

  export type lexiconUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    code: string
    title: string
    text: string
  }

  export type lexiconUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type lexiconUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type lexiconCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    code: string
    title: string
    text: string
  }

  export type lexiconUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type lexiconUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_imageCreateInput = {
    created_at?: Date | string | null
    pict: string
    question: qcu_questionCreateNestedOneWithoutImagesInput
  }

  export type qcu_imageUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    pict: string
    question_id: number
  }

  export type qcu_imageUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
    question?: qcu_questionUpdateOneRequiredWithoutImagesNestedInput
  }

  export type qcu_imageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type qcu_imageCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    pict: string
    question_id: number
  }

  export type qcu_imageUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_imageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type qcu_questionCreateInput = {
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemCreateNestedManyWithoutQuestionInput
    images?: qcu_imageCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemUncheckedCreateNestedManyWithoutQuestionInput
    images?: qcu_imageUncheckedCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUpdateManyWithoutQuestionNestedInput
    images?: qcu_imageUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_questionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUncheckedUpdateManyWithoutQuestionNestedInput
    images?: qcu_imageUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_questionCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
  }

  export type qcu_questionUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_questionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_itemCreateInput = {
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
    question: qcu_questionCreateNestedOneWithoutItemsInput
  }

  export type qcu_itemUncheckedCreateInput = {
    id?: number
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
    question_id: number
  }

  export type qcu_itemUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    question?: qcu_questionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type qcu_itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type qcu_itemCreateManyInput = {
    id?: number
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
    question_id: number
  }

  export type qcu_itemUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qcu_itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_qcuanswerCreateInput = {
    timestamp?: Date | string | null
    success: boolean
    user: userCreateNestedOneWithoutUser_qcuanswersInput
    question: qcu_questionCreateNestedOneWithoutAnswersInput
  }

  export type user_qcuanswerUncheckedCreateInput = {
    id?: number
    timestamp?: Date | string | null
    user_id: number
    qcuquestion_id: number
    success: boolean
  }

  export type user_qcuanswerUpdateInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutUser_qcuanswersNestedInput
    question?: qcu_questionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type user_qcuanswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    qcuquestion_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_qcuanswerCreateManyInput = {
    id?: number
    timestamp?: Date | string | null
    user_id: number
    qcuquestion_id: number
    success: boolean
  }

  export type user_qcuanswerUpdateManyMutationInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_qcuanswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    qcuquestion_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type User_actionListRelationFilter = {
    every?: user_actionWhereInput
    some?: user_actionWhereInput
    none?: user_actionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type user_actionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type sessionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
  }

  export type sessionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type SessionRelationFilter = {
    is?: sessionWhereInput | null
    isNot?: sessionWhereInput | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type user_actionCountOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
  }

  export type user_actionAvgOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
  }

  export type user_actionMaxOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
  }

  export type user_actionMinOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    action?: SortOrder
  }

  export type user_actionSumOrderByAggregateInput = {
    id?: SortOrder
    session_id?: SortOrder
    user_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumCenterTypeFilter = {
    equals?: CenterType
    in?: Enumerable<CenterType>
    notIn?: Enumerable<CenterType>
    not?: NestedEnumCenterTypeFilter | CenterType
  }

  export type User_centerListRelationFilter = {
    every?: user_centerWhereInput
    some?: user_centerWhereInput
    none?: user_centerWhereInput
  }

  export type user_centerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type centerCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type centerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type centerMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type centerMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    type?: SortOrder
    name?: SortOrder
  }

  export type centerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCenterTypeWithAggregatesFilter = {
    equals?: CenterType
    in?: Enumerable<CenterType>
    notIn?: Enumerable<CenterType>
    not?: NestedEnumCenterTypeWithAggregatesFilter | CenterType
    _count?: NestedIntFilter
    _min?: NestedEnumCenterTypeFilter
    _max?: NestedEnumCenterTypeFilter
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
    read_on?: SortOrder
    content?: SortOrder
  }

  export type messageAvgOrderByAggregateInput = {
    id?: SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
    read_on?: SortOrder
    content?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
    read_on?: SortOrder
    content?: SortOrder
  }

  export type messageSumOrderByAggregateInput = {
    id?: SortOrder
    from_id?: SortOrder
    to_id?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumPatientCaregiverTypeFilter = {
    equals?: PatientCaregiverType
    in?: Enumerable<PatientCaregiverType>
    notIn?: Enumerable<PatientCaregiverType>
    not?: NestedEnumPatientCaregiverTypeFilter | PatientCaregiverType
  }

  export type patient_caregiverCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    confirmed?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
  }

  export type patient_caregiverAvgOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
  }

  export type patient_caregiverMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    confirmed?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
  }

  export type patient_caregiverMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    confirmed?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
  }

  export type patient_caregiverSumOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    caregiver_id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumPatientCaregiverTypeWithAggregatesFilter = {
    equals?: PatientCaregiverType
    in?: Enumerable<PatientCaregiverType>
    notIn?: Enumerable<PatientCaregiverType>
    not?: NestedEnumPatientCaregiverTypeWithAggregatesFilter | PatientCaregiverType
    _count?: NestedIntFilter
    _min?: NestedEnumPatientCaregiverTypeFilter
    _max?: NestedEnumPatientCaregiverTypeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type EnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type FavoriteListRelationFilter = {
    every?: favoriteWhereInput
    some?: favoriteWhereInput
    none?: favoriteWhereInput
  }

  export type FractioningListRelationFilter = {
    every?: fractioningWhereInput
    some?: fractioningWhereInput
    none?: fractioningWhereInput
  }

  export type MealListRelationFilter = {
    every?: mealWhereInput
    some?: mealWhereInput
    none?: mealWhereInput
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type Patient_caregiverListRelationFilter = {
    every?: patient_caregiverWhereInput
    some?: patient_caregiverWhereInput
    none?: patient_caregiverWhereInput
  }

  export type User_goalListRelationFilter = {
    every?: user_goalWhereInput
    some?: user_goalWhereInput
    none?: user_goalWhereInput
  }

  export type User_measurementListRelationFilter = {
    every?: user_measurementWhereInput
    some?: user_measurementWhereInput
    none?: user_measurementWhereInput
  }

  export type User_withingsListRelationFilter = {
    every?: user_withingsWhereInput
    some?: user_withingsWhereInput
    none?: user_withingsWhereInput
  }

  export type User_patientListRelationFilter = {
    every?: user_patientWhereInput
    some?: user_patientWhereInput
    none?: user_patientWhereInput
  }

  export type User_qcuanswerListRelationFilter = {
    every?: user_qcuanswerWhereInput
    some?: user_qcuanswerWhereInput
    none?: user_qcuanswerWhereInput
  }

  export type favoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fractioningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patient_caregiverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_goalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_measurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_withingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_patientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_qcuanswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    sub?: SortOrder
    password?: SortOrder
    type?: SortOrder
    birthdate?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    alias?: SortOrder
    notes?: SortOrder
    avatarUrl?: SortOrder
    install_token?: SortOrder
    subscription?: SortOrder
    gender?: SortOrder
    height_cm?: SortOrder
    weight?: SortOrder
    actsport?: SortOrder
    actprof?: SortOrder
    diabetes_type?: SortOrder
    hypertriglyceridemia?: SortOrder
    hypercholesterolemia?: SortOrder
    salt_diet?: SortOrder
    energy_goal?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    height_cm?: SortOrder
    weight?: SortOrder
    actsport?: SortOrder
    actprof?: SortOrder
    diabetes_type?: SortOrder
    salt_diet?: SortOrder
    energy_goal?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    sub?: SortOrder
    password?: SortOrder
    type?: SortOrder
    birthdate?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    alias?: SortOrder
    notes?: SortOrder
    avatarUrl?: SortOrder
    install_token?: SortOrder
    subscription?: SortOrder
    gender?: SortOrder
    height_cm?: SortOrder
    weight?: SortOrder
    actsport?: SortOrder
    actprof?: SortOrder
    diabetes_type?: SortOrder
    hypertriglyceridemia?: SortOrder
    hypercholesterolemia?: SortOrder
    salt_diet?: SortOrder
    energy_goal?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    sub?: SortOrder
    password?: SortOrder
    type?: SortOrder
    birthdate?: SortOrder
    title?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    alias?: SortOrder
    notes?: SortOrder
    avatarUrl?: SortOrder
    install_token?: SortOrder
    subscription?: SortOrder
    gender?: SortOrder
    height_cm?: SortOrder
    weight?: SortOrder
    actsport?: SortOrder
    actprof?: SortOrder
    diabetes_type?: SortOrder
    hypertriglyceridemia?: SortOrder
    hypercholesterolemia?: SortOrder
    salt_diet?: SortOrder
    energy_goal?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    gender?: SortOrder
    height_cm?: SortOrder
    weight?: SortOrder
    actsport?: SortOrder
    actprof?: SortOrder
    diabetes_type?: SortOrder
    salt_diet?: SortOrder
    energy_goal?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type EnumCenterRoleFilter = {
    equals?: CenterRole
    in?: Enumerable<CenterRole>
    notIn?: Enumerable<CenterRole>
    not?: NestedEnumCenterRoleFilter | CenterRole
  }

  export type CenterRelationFilter = {
    is?: centerWhereInput | null
    isNot?: centerWhereInput | null
  }

  export type user_centerCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
    role?: SortOrder
  }

  export type user_centerAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
  }

  export type user_centerMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
    role?: SortOrder
  }

  export type user_centerMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
    role?: SortOrder
  }

  export type user_centerSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    center_id?: SortOrder
  }

  export type EnumCenterRoleWithAggregatesFilter = {
    equals?: CenterRole
    in?: Enumerable<CenterRole>
    notIn?: Enumerable<CenterRole>
    not?: NestedEnumCenterRoleWithAggregatesFilter | CenterRole
    _count?: NestedIntFilter
    _min?: NestedEnumCenterRoleFilter
    _max?: NestedEnumCenterRoleFilter
  }

  export type EnumGoalTypeFilter = {
    equals?: GoalType
    in?: Enumerable<GoalType>
    notIn?: Enumerable<GoalType>
    not?: NestedEnumGoalTypeFilter | GoalType
  }

  export type user_goalCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_goalAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_goalMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_goalMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_goalSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type EnumGoalTypeWithAggregatesFilter = {
    equals?: GoalType
    in?: Enumerable<GoalType>
    notIn?: Enumerable<GoalType>
    not?: NestedEnumGoalTypeWithAggregatesFilter | GoalType
    _count?: NestedIntFilter
    _min?: NestedEnumGoalTypeFilter
    _max?: NestedEnumGoalTypeFilter
  }

  export type EnumMeasurementTypeFilter = {
    equals?: MeasurementType
    in?: Enumerable<MeasurementType>
    notIn?: Enumerable<MeasurementType>
    not?: NestedEnumMeasurementTypeFilter | MeasurementType
  }

  export type user_measurementUser_idDateTypeCompoundUniqueInput = {
    user_id: number
    date: Date | string
    type: MeasurementType
  }

  export type user_measurementCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_measurementAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    value?: SortOrder
  }

  export type user_measurementMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_measurementMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
  }

  export type user_measurementSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    value?: SortOrder
  }

  export type EnumMeasurementTypeWithAggregatesFilter = {
    equals?: MeasurementType
    in?: Enumerable<MeasurementType>
    notIn?: Enumerable<MeasurementType>
    not?: NestedEnumMeasurementTypeWithAggregatesFilter | MeasurementType
    _count?: NestedIntFilter
    _min?: NestedEnumMeasurementTypeFilter
    _max?: NestedEnumMeasurementTypeFilter
  }

  export type user_withingsUser_idWithings_useridCompoundUniqueInput = {
    user_id: number
    withings_userid: string
  }

  export type user_withingsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    withings_userid?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
  }

  export type user_withingsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_withingsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    withings_userid?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
  }

  export type user_withingsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    withings_userid?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
  }

  export type user_withingsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_patientUser_idProtocol_codeCompoundUniqueInput = {
    user_id: number
    protocol_code: string
  }

  export type user_patientCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    protocol_code?: SortOrder
    protocol_inclusion_date?: SortOrder
  }

  export type user_patientAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type user_patientMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    protocol_code?: SortOrder
    protocol_inclusion_date?: SortOrder
  }

  export type user_patientMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    protocol_code?: SortOrder
    protocol_inclusion_date?: SortOrder
  }

  export type user_patientSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type fractioningUser_idDateCompoundUniqueInput = {
    user_id: number
    date: string
  }

  export type fractioningCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    meal_types?: SortOrder
  }

  export type fractioningAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type fractioningMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    meal_types?: SortOrder
  }

  export type fractioningMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    meal_types?: SortOrder
  }

  export type fractioningSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type FoodRelationFilter = {
    is?: foodWhereInput | null
    isNot?: foodWhereInput | null
  }

  export type MealRelationFilter = {
    is?: mealWhereInput | null
    isNot?: mealWhereInput | null
  }

  export type Food_portionRelationFilter = {
    is?: food_portionWhereInput | null
    isNot?: food_portionWhereInput | null
  }

  export type meal_elementCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    meal_id?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type meal_elementAvgOrderByAggregateInput = {
    id?: SortOrder
    meal_id?: SortOrder
    food_id?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type meal_elementMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    meal_id?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type meal_elementMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    meal_id?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type meal_elementSumOrderByAggregateInput = {
    id?: SortOrder
    meal_id?: SortOrder
    food_id?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type Meal_elementListRelationFilter = {
    every?: meal_elementWhereInput
    some?: meal_elementWhereInput
    none?: meal_elementWhereInput
  }

  export type meal_elementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mealUser_idDateMealtypeCompoundUniqueInput = {
    user_id: number
    date: string
    mealtype: string
  }

  export type mealCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    mealtype?: SortOrder
    really_eaten?: SortOrder
  }

  export type mealAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type mealMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    mealtype?: SortOrder
    really_eaten?: SortOrder
  }

  export type mealMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    mealtype?: SortOrder
    really_eaten?: SortOrder
  }

  export type mealSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type favoriteUser_idFood_idMealtypeCompoundUniqueInput = {
    user_id: number
    food_id: number
    mealtype: string
  }

  export type favoriteCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    mealtype?: SortOrder
    count?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type favoriteAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    count?: SortOrder
    food_id?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type favoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    mealtype?: SortOrder
    count?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type favoriteMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    mealtype?: SortOrder
    count?: SortOrder
    food_id?: SortOrder
    weight?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type favoriteSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    count?: SortOrder
    food_id?: SortOrder
    portion_id?: SortOrder
    portion_cnt?: SortOrder
  }

  export type Food_categoryListRelationFilter = {
    every?: food_categoryWhereInput
    some?: food_categoryWhereInput
    none?: food_categoryWhereInput
  }

  export type food_categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_gpcd?: SortOrder
    member_of_id?: SortOrder
    rank?: SortOrder
    tag?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    member_of_id?: SortOrder
    rank?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_gpcd?: SortOrder
    member_of_id?: SortOrder
    rank?: SortOrder
    tag?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_gpcd?: SortOrder
    member_of_id?: SortOrder
    rank?: SortOrder
    tag?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
    member_of_id?: SortOrder
    rank?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type food_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
  }

  export type food_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
  }

  export type food_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
  }

  export type food_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
  }

  export type food_categorySumOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
    category_id?: SortOrder
  }

  export type food_portionCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    qty?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    note?: SortOrder
    pict?: SortOrder
    food_id?: SortOrder
  }

  export type food_portionAvgOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
  }

  export type food_portionMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    qty?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    note?: SortOrder
    pict?: SortOrder
    food_id?: SortOrder
  }

  export type food_portionMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    qty?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    note?: SortOrder
    pict?: SortOrder
    food_id?: SortOrder
  }

  export type food_portionSumOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
  }

  export type Food_portionListRelationFilter = {
    every?: food_portionWhereInput
    some?: food_portionWhereInput
    none?: food_portionWhereInput
  }

  export type SourceRelationFilter = {
    is?: sourceWhereInput | null
    isNot?: sourceWhereInput | null
  }

  export type NutdataListRelationFilter = {
    every?: nutdataWhereInput
    some?: nutdataWhereInput
    none?: nutdataWhereInput
  }

  export type food_portionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type nutdataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type foodCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_name?: SortOrder
    ctdit_shrt_desc?: SortOrder
    ctdit_long_desc?: SortOrder
    keywords?: SortOrder
    ciqual_num?: SortOrder
    note?: SortOrder
    max_qty?: SortOrder
    pict?: SortOrder
    source_id?: SortOrder
    is_brand?: SortOrder
    is_raw?: SortOrder
    is_indivisible?: SortOrder
    is_chu?: SortOrder
    is_demo?: SortOrder
    is_patient_full?: SortOrder
    is_patient_simplified?: SortOrder
    pack_pict?: SortOrder
    is_validated?: SortOrder
  }

  export type foodAvgOrderByAggregateInput = {
    id?: SortOrder
    source_id?: SortOrder
  }

  export type foodMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_name?: SortOrder
    ctdit_shrt_desc?: SortOrder
    ctdit_long_desc?: SortOrder
    keywords?: SortOrder
    ciqual_num?: SortOrder
    note?: SortOrder
    max_qty?: SortOrder
    pict?: SortOrder
    source_id?: SortOrder
    is_brand?: SortOrder
    is_raw?: SortOrder
    is_indivisible?: SortOrder
    is_chu?: SortOrder
    is_demo?: SortOrder
    is_patient_full?: SortOrder
    is_patient_simplified?: SortOrder
    pack_pict?: SortOrder
    is_validated?: SortOrder
  }

  export type foodMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    ciqual_name?: SortOrder
    ctdit_shrt_desc?: SortOrder
    ctdit_long_desc?: SortOrder
    keywords?: SortOrder
    ciqual_num?: SortOrder
    note?: SortOrder
    max_qty?: SortOrder
    pict?: SortOrder
    source_id?: SortOrder
    is_brand?: SortOrder
    is_raw?: SortOrder
    is_indivisible?: SortOrder
    is_chu?: SortOrder
    is_demo?: SortOrder
    is_patient_full?: SortOrder
    is_patient_simplified?: SortOrder
    pack_pict?: SortOrder
    is_validated?: SortOrder
  }

  export type foodSumOrderByAggregateInput = {
    id?: SortOrder
    source_id?: SortOrder
  }

  export type NutrientRelationFilter = {
    is?: nutrientWhereInput | null
    isNot?: nutrientWhereInput | null
  }

  export type nutdataCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    val?: SortOrder
    note?: SortOrder
    food_id?: SortOrder
    nutr_no?: SortOrder
    source_id?: SortOrder
  }

  export type nutdataAvgOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
    source_id?: SortOrder
  }

  export type nutdataMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    val?: SortOrder
    note?: SortOrder
    food_id?: SortOrder
    nutr_no?: SortOrder
    source_id?: SortOrder
  }

  export type nutdataMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    val?: SortOrder
    note?: SortOrder
    food_id?: SortOrder
    nutr_no?: SortOrder
    source_id?: SortOrder
  }

  export type nutdataSumOrderByAggregateInput = {
    id?: SortOrder
    food_id?: SortOrder
    source_id?: SortOrder
  }

  export type nutrientCountOrderByAggregateInput = {
    nutr_no?: SortOrder
    created_at?: SortOrder
    ifda_no?: SortOrder
    unit?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    energy_density?: SortOrder
  }

  export type nutrientAvgOrderByAggregateInput = {
    energy_density?: SortOrder
  }

  export type nutrientMaxOrderByAggregateInput = {
    nutr_no?: SortOrder
    created_at?: SortOrder
    ifda_no?: SortOrder
    unit?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    energy_density?: SortOrder
  }

  export type nutrientMinOrderByAggregateInput = {
    nutr_no?: SortOrder
    created_at?: SortOrder
    ifda_no?: SortOrder
    unit?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    energy_density?: SortOrder
  }

  export type nutrientSumOrderByAggregateInput = {
    energy_density?: SortOrder
  }

  export type FoodListRelationFilter = {
    every?: foodWhereInput
    some?: foodWhereInput
    none?: foodWhereInput
  }

  export type foodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sourceCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
  }

  export type sourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sourceMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
  }

  export type sourceMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
  }

  export type sourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type dishCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    pict?: SortOrder
    note?: SortOrder
    shrt_source?: SortOrder
    long_source?: SortOrder
    qty_max?: SortOrder
    resume?: SortOrder
    recette?: SortOrder
    nbpersonnes?: SortOrder
    qte?: SortOrder
    diabete?: SortOrder
    cardiaque?: SortOrder
    obese?: SortOrder
    ssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    maxqty?: SortOrder
  }

  export type dishAvgOrderByAggregateInput = {
    id?: SortOrder
    nbpersonnes?: SortOrder
    maxqty?: SortOrder
  }

  export type dishMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    pict?: SortOrder
    note?: SortOrder
    shrt_source?: SortOrder
    long_source?: SortOrder
    qty_max?: SortOrder
    resume?: SortOrder
    recette?: SortOrder
    nbpersonnes?: SortOrder
    qte?: SortOrder
    diabete?: SortOrder
    cardiaque?: SortOrder
    obese?: SortOrder
    ssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    maxqty?: SortOrder
  }

  export type dishMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    shrt_desc?: SortOrder
    long_desc?: SortOrder
    pict?: SortOrder
    note?: SortOrder
    shrt_source?: SortOrder
    long_source?: SortOrder
    qty_max?: SortOrder
    resume?: SortOrder
    recette?: SortOrder
    nbpersonnes?: SortOrder
    qte?: SortOrder
    diabete?: SortOrder
    cardiaque?: SortOrder
    obese?: SortOrder
    ssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
    maxqty?: SortOrder
  }

  export type dishSumOrderByAggregateInput = {
    id?: SortOrder
    nbpersonnes?: SortOrder
    maxqty?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type lexiconCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    code?: SortOrder
    title?: SortOrder
    text?: SortOrder
  }

  export type lexiconAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type lexiconMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    code?: SortOrder
    title?: SortOrder
    text?: SortOrder
  }

  export type lexiconMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    code?: SortOrder
    title?: SortOrder
    text?: SortOrder
  }

  export type lexiconSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Qcu_questionRelationFilter = {
    is?: qcu_questionWhereInput | null
    isNot?: qcu_questionWhereInput | null
  }

  export type qcu_imageCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    pict?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_imageAvgOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_imageMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    pict?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_imageMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    pict?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_imageSumOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type Qcu_itemListRelationFilter = {
    every?: qcu_itemWhereInput
    some?: qcu_itemWhereInput
    none?: qcu_itemWhereInput
  }

  export type Qcu_imageListRelationFilter = {
    every?: qcu_imageWhereInput
    some?: qcu_imageWhereInput
    none?: qcu_imageWhereInput
  }

  export type qcu_itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qcu_imageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type qcu_questionCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    note?: SortOrder
    type?: SortOrder
    level?: SortOrder
    question?: SortOrder
    diabete?: SortOrder
    sssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
  }

  export type qcu_questionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type qcu_questionMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    note?: SortOrder
    type?: SortOrder
    level?: SortOrder
    question?: SortOrder
    diabete?: SortOrder
    sssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
  }

  export type qcu_questionMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    note?: SortOrder
    type?: SortOrder
    level?: SortOrder
    question?: SortOrder
    diabete?: SortOrder
    sssel?: SortOrder
    chol?: SortOrder
    trigly?: SortOrder
  }

  export type qcu_questionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type qcu_itemCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    proposition?: SortOrder
    pict?: SortOrder
    answer?: SortOrder
    success?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_itemAvgOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_itemMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    proposition?: SortOrder
    pict?: SortOrder
    answer?: SortOrder
    success?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_itemMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    proposition?: SortOrder
    pict?: SortOrder
    answer?: SortOrder
    success?: SortOrder
    question_id?: SortOrder
  }

  export type qcu_itemSumOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type user_qcuanswerCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
    success?: SortOrder
  }

  export type user_qcuanswerAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
  }

  export type user_qcuanswerMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
    success?: SortOrder
  }

  export type user_qcuanswerMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
    success?: SortOrder
  }

  export type user_qcuanswerSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    qcuquestion_id?: SortOrder
  }

  export type user_actionCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutSessionInput>, Enumerable<user_actionUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutSessionInput>
    createMany?: user_actionCreateManySessionInputEnvelope
    connect?: Enumerable<user_actionWhereUniqueInput>
  }

  export type user_actionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutSessionInput>, Enumerable<user_actionUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutSessionInput>
    createMany?: user_actionCreateManySessionInputEnvelope
    connect?: Enumerable<user_actionWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type user_actionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutSessionInput>, Enumerable<user_actionUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<user_actionUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: user_actionCreateManySessionInputEnvelope
    set?: Enumerable<user_actionWhereUniqueInput>
    disconnect?: Enumerable<user_actionWhereUniqueInput>
    delete?: Enumerable<user_actionWhereUniqueInput>
    connect?: Enumerable<user_actionWhereUniqueInput>
    update?: Enumerable<user_actionUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<user_actionUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<user_actionScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type user_actionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutSessionInput>, Enumerable<user_actionUncheckedCreateWithoutSessionInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutSessionInput>
    upsert?: Enumerable<user_actionUpsertWithWhereUniqueWithoutSessionInput>
    createMany?: user_actionCreateManySessionInputEnvelope
    set?: Enumerable<user_actionWhereUniqueInput>
    disconnect?: Enumerable<user_actionWhereUniqueInput>
    delete?: Enumerable<user_actionWhereUniqueInput>
    connect?: Enumerable<user_actionWhereUniqueInput>
    update?: Enumerable<user_actionUpdateWithWhereUniqueWithoutSessionInput>
    updateMany?: Enumerable<user_actionUpdateManyWithWhereWithoutSessionInput>
    deleteMany?: Enumerable<user_actionScalarWhereInput>
  }

  export type sessionCreateNestedOneWithoutUser_actionsInput = {
    create?: XOR<sessionCreateWithoutUser_actionsInput, sessionUncheckedCreateWithoutUser_actionsInput>
    connectOrCreate?: sessionCreateOrConnectWithoutUser_actionsInput
    connect?: sessionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUser_actionsInput = {
    create?: XOR<userCreateWithoutUser_actionsInput, userUncheckedCreateWithoutUser_actionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_actionsInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type sessionUpdateOneRequiredWithoutUser_actionsNestedInput = {
    create?: XOR<sessionCreateWithoutUser_actionsInput, sessionUncheckedCreateWithoutUser_actionsInput>
    connectOrCreate?: sessionCreateOrConnectWithoutUser_actionsInput
    upsert?: sessionUpsertWithoutUser_actionsInput
    connect?: sessionWhereUniqueInput
    update?: XOR<sessionUpdateWithoutUser_actionsInput, sessionUncheckedUpdateWithoutUser_actionsInput>
  }

  export type userUpdateOneRequiredWithoutUser_actionsNestedInput = {
    create?: XOR<userCreateWithoutUser_actionsInput, userUncheckedCreateWithoutUser_actionsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_actionsInput
    upsert?: userUpsertWithoutUser_actionsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_actionsInput, userUncheckedUpdateWithoutUser_actionsInput>
  }

  export type user_centerCreateNestedManyWithoutCenterInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutCenterInput>, Enumerable<user_centerUncheckedCreateWithoutCenterInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutCenterInput>
    createMany?: user_centerCreateManyCenterInputEnvelope
    connect?: Enumerable<user_centerWhereUniqueInput>
  }

  export type user_centerUncheckedCreateNestedManyWithoutCenterInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutCenterInput>, Enumerable<user_centerUncheckedCreateWithoutCenterInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutCenterInput>
    createMany?: user_centerCreateManyCenterInputEnvelope
    connect?: Enumerable<user_centerWhereUniqueInput>
  }

  export type EnumCenterTypeFieldUpdateOperationsInput = {
    set?: CenterType
  }

  export type user_centerUpdateManyWithoutCenterNestedInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutCenterInput>, Enumerable<user_centerUncheckedCreateWithoutCenterInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutCenterInput>
    upsert?: Enumerable<user_centerUpsertWithWhereUniqueWithoutCenterInput>
    createMany?: user_centerCreateManyCenterInputEnvelope
    set?: Enumerable<user_centerWhereUniqueInput>
    disconnect?: Enumerable<user_centerWhereUniqueInput>
    delete?: Enumerable<user_centerWhereUniqueInput>
    connect?: Enumerable<user_centerWhereUniqueInput>
    update?: Enumerable<user_centerUpdateWithWhereUniqueWithoutCenterInput>
    updateMany?: Enumerable<user_centerUpdateManyWithWhereWithoutCenterInput>
    deleteMany?: Enumerable<user_centerScalarWhereInput>
  }

  export type user_centerUncheckedUpdateManyWithoutCenterNestedInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutCenterInput>, Enumerable<user_centerUncheckedCreateWithoutCenterInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutCenterInput>
    upsert?: Enumerable<user_centerUpsertWithWhereUniqueWithoutCenterInput>
    createMany?: user_centerCreateManyCenterInputEnvelope
    set?: Enumerable<user_centerWhereUniqueInput>
    disconnect?: Enumerable<user_centerWhereUniqueInput>
    delete?: Enumerable<user_centerWhereUniqueInput>
    connect?: Enumerable<user_centerWhereUniqueInput>
    update?: Enumerable<user_centerUpdateWithWhereUniqueWithoutCenterInput>
    updateMany?: Enumerable<user_centerUpdateManyWithWhereWithoutCenterInput>
    deleteMany?: Enumerable<user_centerScalarWhereInput>
  }

  export type userCreateNestedOneWithoutMessages_fromInput = {
    create?: XOR<userCreateWithoutMessages_fromInput, userUncheckedCreateWithoutMessages_fromInput>
    connectOrCreate?: userCreateOrConnectWithoutMessages_fromInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessages_toInput = {
    create?: XOR<userCreateWithoutMessages_toInput, userUncheckedCreateWithoutMessages_toInput>
    connectOrCreate?: userCreateOrConnectWithoutMessages_toInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutMessages_fromNestedInput = {
    create?: XOR<userCreateWithoutMessages_fromInput, userUncheckedCreateWithoutMessages_fromInput>
    connectOrCreate?: userCreateOrConnectWithoutMessages_fromInput
    upsert?: userUpsertWithoutMessages_fromInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMessages_fromInput, userUncheckedUpdateWithoutMessages_fromInput>
  }

  export type userUpdateOneRequiredWithoutMessages_toNestedInput = {
    create?: XOR<userCreateWithoutMessages_toInput, userUncheckedCreateWithoutMessages_toInput>
    connectOrCreate?: userCreateOrConnectWithoutMessages_toInput
    upsert?: userUpsertWithoutMessages_toInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMessages_toInput, userUncheckedUpdateWithoutMessages_toInput>
  }

  export type userCreateNestedOneWithoutPatientsInput = {
    create?: XOR<userCreateWithoutPatientsInput, userUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: userCreateOrConnectWithoutPatientsInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCaregiversInput = {
    create?: XOR<userCreateWithoutCaregiversInput, userUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: userCreateOrConnectWithoutCaregiversInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumPatientCaregiverTypeFieldUpdateOperationsInput = {
    set?: PatientCaregiverType
  }

  export type userUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<userCreateWithoutPatientsInput, userUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: userCreateOrConnectWithoutPatientsInput
    upsert?: userUpsertWithoutPatientsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutPatientsInput, userUncheckedUpdateWithoutPatientsInput>
  }

  export type userUpdateOneRequiredWithoutCaregiversNestedInput = {
    create?: XOR<userCreateWithoutCaregiversInput, userUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: userCreateOrConnectWithoutCaregiversInput
    upsert?: userUpsertWithoutCaregiversInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCaregiversInput, userUncheckedUpdateWithoutCaregiversInput>
  }

  export type user_actionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutUserInput>, Enumerable<user_actionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutUserInput>
    createMany?: user_actionCreateManyUserInputEnvelope
    connect?: Enumerable<user_actionWhereUniqueInput>
  }

  export type favoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutUserInput>, Enumerable<favoriteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutUserInput>
    createMany?: favoriteCreateManyUserInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type fractioningCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<fractioningCreateWithoutUserInput>, Enumerable<fractioningUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fractioningCreateOrConnectWithoutUserInput>
    createMany?: fractioningCreateManyUserInputEnvelope
    connect?: Enumerable<fractioningWhereUniqueInput>
  }

  export type mealCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<mealCreateWithoutUsersInput>, Enumerable<mealUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<mealCreateOrConnectWithoutUsersInput>
    createMany?: mealCreateManyUsersInputEnvelope
    connect?: Enumerable<mealWhereUniqueInput>
  }

  export type messageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<messageCreateWithoutFromInput>, Enumerable<messageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutFromInput>
    createMany?: messageCreateManyFromInputEnvelope
    connect?: Enumerable<messageWhereUniqueInput>
  }

  export type messageCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<messageCreateWithoutToInput>, Enumerable<messageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutToInput>
    createMany?: messageCreateManyToInputEnvelope
    connect?: Enumerable<messageWhereUniqueInput>
  }

  export type patient_caregiverCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutPatientInput>, Enumerable<patient_caregiverUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutPatientInput>
    createMany?: patient_caregiverCreateManyPatientInputEnvelope
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
  }

  export type patient_caregiverCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutCaregiverInput>, Enumerable<patient_caregiverUncheckedCreateWithoutCaregiverInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutCaregiverInput>
    createMany?: patient_caregiverCreateManyCaregiverInputEnvelope
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
  }

  export type user_centerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutUserInput>, Enumerable<user_centerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutUserInput>
    createMany?: user_centerCreateManyUserInputEnvelope
    connect?: Enumerable<user_centerWhereUniqueInput>
  }

  export type user_goalCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_goalCreateWithoutUserInput>, Enumerable<user_goalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_goalCreateOrConnectWithoutUserInput>
    createMany?: user_goalCreateManyUserInputEnvelope
    connect?: Enumerable<user_goalWhereUniqueInput>
  }

  export type user_measurementCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_measurementCreateWithoutUserInput>, Enumerable<user_measurementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_measurementCreateOrConnectWithoutUserInput>
    createMany?: user_measurementCreateManyUserInputEnvelope
    connect?: Enumerable<user_measurementWhereUniqueInput>
  }

  export type user_withingsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_withingsCreateWithoutUserInput>, Enumerable<user_withingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_withingsCreateOrConnectWithoutUserInput>
    createMany?: user_withingsCreateManyUserInputEnvelope
    connect?: Enumerable<user_withingsWhereUniqueInput>
  }

  export type user_patientCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_patientCreateWithoutUserInput>, Enumerable<user_patientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_patientCreateOrConnectWithoutUserInput>
    createMany?: user_patientCreateManyUserInputEnvelope
    connect?: Enumerable<user_patientWhereUniqueInput>
  }

  export type user_qcuanswerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutUserInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutUserInput>
    createMany?: user_qcuanswerCreateManyUserInputEnvelope
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
  }

  export type user_actionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutUserInput>, Enumerable<user_actionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutUserInput>
    createMany?: user_actionCreateManyUserInputEnvelope
    connect?: Enumerable<user_actionWhereUniqueInput>
  }

  export type favoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutUserInput>, Enumerable<favoriteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutUserInput>
    createMany?: favoriteCreateManyUserInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type fractioningUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<fractioningCreateWithoutUserInput>, Enumerable<fractioningUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fractioningCreateOrConnectWithoutUserInput>
    createMany?: fractioningCreateManyUserInputEnvelope
    connect?: Enumerable<fractioningWhereUniqueInput>
  }

  export type mealUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<mealCreateWithoutUsersInput>, Enumerable<mealUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<mealCreateOrConnectWithoutUsersInput>
    createMany?: mealCreateManyUsersInputEnvelope
    connect?: Enumerable<mealWhereUniqueInput>
  }

  export type messageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<messageCreateWithoutFromInput>, Enumerable<messageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutFromInput>
    createMany?: messageCreateManyFromInputEnvelope
    connect?: Enumerable<messageWhereUniqueInput>
  }

  export type messageUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<messageCreateWithoutToInput>, Enumerable<messageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutToInput>
    createMany?: messageCreateManyToInputEnvelope
    connect?: Enumerable<messageWhereUniqueInput>
  }

  export type patient_caregiverUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutPatientInput>, Enumerable<patient_caregiverUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutPatientInput>
    createMany?: patient_caregiverCreateManyPatientInputEnvelope
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
  }

  export type patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutCaregiverInput>, Enumerable<patient_caregiverUncheckedCreateWithoutCaregiverInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutCaregiverInput>
    createMany?: patient_caregiverCreateManyCaregiverInputEnvelope
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
  }

  export type user_centerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutUserInput>, Enumerable<user_centerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutUserInput>
    createMany?: user_centerCreateManyUserInputEnvelope
    connect?: Enumerable<user_centerWhereUniqueInput>
  }

  export type user_goalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_goalCreateWithoutUserInput>, Enumerable<user_goalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_goalCreateOrConnectWithoutUserInput>
    createMany?: user_goalCreateManyUserInputEnvelope
    connect?: Enumerable<user_goalWhereUniqueInput>
  }

  export type user_measurementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_measurementCreateWithoutUserInput>, Enumerable<user_measurementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_measurementCreateOrConnectWithoutUserInput>
    createMany?: user_measurementCreateManyUserInputEnvelope
    connect?: Enumerable<user_measurementWhereUniqueInput>
  }

  export type user_withingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_withingsCreateWithoutUserInput>, Enumerable<user_withingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_withingsCreateOrConnectWithoutUserInput>
    createMany?: user_withingsCreateManyUserInputEnvelope
    connect?: Enumerable<user_withingsWhereUniqueInput>
  }

  export type user_patientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_patientCreateWithoutUserInput>, Enumerable<user_patientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_patientCreateOrConnectWithoutUserInput>
    createMany?: user_patientCreateManyUserInputEnvelope
    connect?: Enumerable<user_patientWhereUniqueInput>
  }

  export type user_qcuanswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutUserInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutUserInput>
    createMany?: user_qcuanswerCreateManyUserInputEnvelope
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: UserType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type user_actionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutUserInput>, Enumerable<user_actionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_actionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_actionCreateManyUserInputEnvelope
    set?: Enumerable<user_actionWhereUniqueInput>
    disconnect?: Enumerable<user_actionWhereUniqueInput>
    delete?: Enumerable<user_actionWhereUniqueInput>
    connect?: Enumerable<user_actionWhereUniqueInput>
    update?: Enumerable<user_actionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_actionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_actionScalarWhereInput>
  }

  export type favoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutUserInput>, Enumerable<favoriteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: favoriteCreateManyUserInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type fractioningUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<fractioningCreateWithoutUserInput>, Enumerable<fractioningUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fractioningCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<fractioningUpsertWithWhereUniqueWithoutUserInput>
    createMany?: fractioningCreateManyUserInputEnvelope
    set?: Enumerable<fractioningWhereUniqueInput>
    disconnect?: Enumerable<fractioningWhereUniqueInput>
    delete?: Enumerable<fractioningWhereUniqueInput>
    connect?: Enumerable<fractioningWhereUniqueInput>
    update?: Enumerable<fractioningUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<fractioningUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<fractioningScalarWhereInput>
  }

  export type mealUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<mealCreateWithoutUsersInput>, Enumerable<mealUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<mealCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<mealUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: mealCreateManyUsersInputEnvelope
    set?: Enumerable<mealWhereUniqueInput>
    disconnect?: Enumerable<mealWhereUniqueInput>
    delete?: Enumerable<mealWhereUniqueInput>
    connect?: Enumerable<mealWhereUniqueInput>
    update?: Enumerable<mealUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<mealUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<mealScalarWhereInput>
  }

  export type messageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<messageCreateWithoutFromInput>, Enumerable<messageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<messageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: messageCreateManyFromInputEnvelope
    set?: Enumerable<messageWhereUniqueInput>
    disconnect?: Enumerable<messageWhereUniqueInput>
    delete?: Enumerable<messageWhereUniqueInput>
    connect?: Enumerable<messageWhereUniqueInput>
    update?: Enumerable<messageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<messageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<messageScalarWhereInput>
  }

  export type messageUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<messageCreateWithoutToInput>, Enumerable<messageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<messageUpsertWithWhereUniqueWithoutToInput>
    createMany?: messageCreateManyToInputEnvelope
    set?: Enumerable<messageWhereUniqueInput>
    disconnect?: Enumerable<messageWhereUniqueInput>
    delete?: Enumerable<messageWhereUniqueInput>
    connect?: Enumerable<messageWhereUniqueInput>
    update?: Enumerable<messageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<messageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<messageScalarWhereInput>
  }

  export type patient_caregiverUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutPatientInput>, Enumerable<patient_caregiverUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<patient_caregiverUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: patient_caregiverCreateManyPatientInputEnvelope
    set?: Enumerable<patient_caregiverWhereUniqueInput>
    disconnect?: Enumerable<patient_caregiverWhereUniqueInput>
    delete?: Enumerable<patient_caregiverWhereUniqueInput>
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
    update?: Enumerable<patient_caregiverUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<patient_caregiverUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<patient_caregiverScalarWhereInput>
  }

  export type patient_caregiverUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutCaregiverInput>, Enumerable<patient_caregiverUncheckedCreateWithoutCaregiverInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutCaregiverInput>
    upsert?: Enumerable<patient_caregiverUpsertWithWhereUniqueWithoutCaregiverInput>
    createMany?: patient_caregiverCreateManyCaregiverInputEnvelope
    set?: Enumerable<patient_caregiverWhereUniqueInput>
    disconnect?: Enumerable<patient_caregiverWhereUniqueInput>
    delete?: Enumerable<patient_caregiverWhereUniqueInput>
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
    update?: Enumerable<patient_caregiverUpdateWithWhereUniqueWithoutCaregiverInput>
    updateMany?: Enumerable<patient_caregiverUpdateManyWithWhereWithoutCaregiverInput>
    deleteMany?: Enumerable<patient_caregiverScalarWhereInput>
  }

  export type user_centerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutUserInput>, Enumerable<user_centerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_centerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_centerCreateManyUserInputEnvelope
    set?: Enumerable<user_centerWhereUniqueInput>
    disconnect?: Enumerable<user_centerWhereUniqueInput>
    delete?: Enumerable<user_centerWhereUniqueInput>
    connect?: Enumerable<user_centerWhereUniqueInput>
    update?: Enumerable<user_centerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_centerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_centerScalarWhereInput>
  }

  export type user_goalUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_goalCreateWithoutUserInput>, Enumerable<user_goalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_goalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_goalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_goalCreateManyUserInputEnvelope
    set?: Enumerable<user_goalWhereUniqueInput>
    disconnect?: Enumerable<user_goalWhereUniqueInput>
    delete?: Enumerable<user_goalWhereUniqueInput>
    connect?: Enumerable<user_goalWhereUniqueInput>
    update?: Enumerable<user_goalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_goalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_goalScalarWhereInput>
  }

  export type user_measurementUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_measurementCreateWithoutUserInput>, Enumerable<user_measurementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_measurementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_measurementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_measurementCreateManyUserInputEnvelope
    set?: Enumerable<user_measurementWhereUniqueInput>
    disconnect?: Enumerable<user_measurementWhereUniqueInput>
    delete?: Enumerable<user_measurementWhereUniqueInput>
    connect?: Enumerable<user_measurementWhereUniqueInput>
    update?: Enumerable<user_measurementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_measurementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_measurementScalarWhereInput>
  }

  export type user_withingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_withingsCreateWithoutUserInput>, Enumerable<user_withingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_withingsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_withingsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_withingsCreateManyUserInputEnvelope
    set?: Enumerable<user_withingsWhereUniqueInput>
    disconnect?: Enumerable<user_withingsWhereUniqueInput>
    delete?: Enumerable<user_withingsWhereUniqueInput>
    connect?: Enumerable<user_withingsWhereUniqueInput>
    update?: Enumerable<user_withingsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_withingsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_withingsScalarWhereInput>
  }

  export type user_patientUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_patientCreateWithoutUserInput>, Enumerable<user_patientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_patientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_patientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_patientCreateManyUserInputEnvelope
    set?: Enumerable<user_patientWhereUniqueInput>
    disconnect?: Enumerable<user_patientWhereUniqueInput>
    delete?: Enumerable<user_patientWhereUniqueInput>
    connect?: Enumerable<user_patientWhereUniqueInput>
    update?: Enumerable<user_patientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_patientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_patientScalarWhereInput>
  }

  export type user_qcuanswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutUserInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_qcuanswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_qcuanswerCreateManyUserInputEnvelope
    set?: Enumerable<user_qcuanswerWhereUniqueInput>
    disconnect?: Enumerable<user_qcuanswerWhereUniqueInput>
    delete?: Enumerable<user_qcuanswerWhereUniqueInput>
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
    update?: Enumerable<user_qcuanswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_qcuanswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_qcuanswerScalarWhereInput>
  }

  export type user_actionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_actionCreateWithoutUserInput>, Enumerable<user_actionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_actionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_actionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_actionCreateManyUserInputEnvelope
    set?: Enumerable<user_actionWhereUniqueInput>
    disconnect?: Enumerable<user_actionWhereUniqueInput>
    delete?: Enumerable<user_actionWhereUniqueInput>
    connect?: Enumerable<user_actionWhereUniqueInput>
    update?: Enumerable<user_actionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_actionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_actionScalarWhereInput>
  }

  export type favoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutUserInput>, Enumerable<favoriteUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutUserInput>
    createMany?: favoriteCreateManyUserInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type fractioningUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<fractioningCreateWithoutUserInput>, Enumerable<fractioningUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fractioningCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<fractioningUpsertWithWhereUniqueWithoutUserInput>
    createMany?: fractioningCreateManyUserInputEnvelope
    set?: Enumerable<fractioningWhereUniqueInput>
    disconnect?: Enumerable<fractioningWhereUniqueInput>
    delete?: Enumerable<fractioningWhereUniqueInput>
    connect?: Enumerable<fractioningWhereUniqueInput>
    update?: Enumerable<fractioningUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<fractioningUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<fractioningScalarWhereInput>
  }

  export type mealUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<mealCreateWithoutUsersInput>, Enumerable<mealUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<mealCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<mealUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: mealCreateManyUsersInputEnvelope
    set?: Enumerable<mealWhereUniqueInput>
    disconnect?: Enumerable<mealWhereUniqueInput>
    delete?: Enumerable<mealWhereUniqueInput>
    connect?: Enumerable<mealWhereUniqueInput>
    update?: Enumerable<mealUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<mealUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<mealScalarWhereInput>
  }

  export type messageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<messageCreateWithoutFromInput>, Enumerable<messageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<messageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: messageCreateManyFromInputEnvelope
    set?: Enumerable<messageWhereUniqueInput>
    disconnect?: Enumerable<messageWhereUniqueInput>
    delete?: Enumerable<messageWhereUniqueInput>
    connect?: Enumerable<messageWhereUniqueInput>
    update?: Enumerable<messageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<messageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<messageScalarWhereInput>
  }

  export type messageUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<messageCreateWithoutToInput>, Enumerable<messageUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<messageCreateOrConnectWithoutToInput>
    upsert?: Enumerable<messageUpsertWithWhereUniqueWithoutToInput>
    createMany?: messageCreateManyToInputEnvelope
    set?: Enumerable<messageWhereUniqueInput>
    disconnect?: Enumerable<messageWhereUniqueInput>
    delete?: Enumerable<messageWhereUniqueInput>
    connect?: Enumerable<messageWhereUniqueInput>
    update?: Enumerable<messageUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<messageUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<messageScalarWhereInput>
  }

  export type patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutPatientInput>, Enumerable<patient_caregiverUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<patient_caregiverUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: patient_caregiverCreateManyPatientInputEnvelope
    set?: Enumerable<patient_caregiverWhereUniqueInput>
    disconnect?: Enumerable<patient_caregiverWhereUniqueInput>
    delete?: Enumerable<patient_caregiverWhereUniqueInput>
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
    update?: Enumerable<patient_caregiverUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<patient_caregiverUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<patient_caregiverScalarWhereInput>
  }

  export type patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput = {
    create?: XOR<Enumerable<patient_caregiverCreateWithoutCaregiverInput>, Enumerable<patient_caregiverUncheckedCreateWithoutCaregiverInput>>
    connectOrCreate?: Enumerable<patient_caregiverCreateOrConnectWithoutCaregiverInput>
    upsert?: Enumerable<patient_caregiverUpsertWithWhereUniqueWithoutCaregiverInput>
    createMany?: patient_caregiverCreateManyCaregiverInputEnvelope
    set?: Enumerable<patient_caregiverWhereUniqueInput>
    disconnect?: Enumerable<patient_caregiverWhereUniqueInput>
    delete?: Enumerable<patient_caregiverWhereUniqueInput>
    connect?: Enumerable<patient_caregiverWhereUniqueInput>
    update?: Enumerable<patient_caregiverUpdateWithWhereUniqueWithoutCaregiverInput>
    updateMany?: Enumerable<patient_caregiverUpdateManyWithWhereWithoutCaregiverInput>
    deleteMany?: Enumerable<patient_caregiverScalarWhereInput>
  }

  export type user_centerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_centerCreateWithoutUserInput>, Enumerable<user_centerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_centerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_centerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_centerCreateManyUserInputEnvelope
    set?: Enumerable<user_centerWhereUniqueInput>
    disconnect?: Enumerable<user_centerWhereUniqueInput>
    delete?: Enumerable<user_centerWhereUniqueInput>
    connect?: Enumerable<user_centerWhereUniqueInput>
    update?: Enumerable<user_centerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_centerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_centerScalarWhereInput>
  }

  export type user_goalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_goalCreateWithoutUserInput>, Enumerable<user_goalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_goalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_goalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_goalCreateManyUserInputEnvelope
    set?: Enumerable<user_goalWhereUniqueInput>
    disconnect?: Enumerable<user_goalWhereUniqueInput>
    delete?: Enumerable<user_goalWhereUniqueInput>
    connect?: Enumerable<user_goalWhereUniqueInput>
    update?: Enumerable<user_goalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_goalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_goalScalarWhereInput>
  }

  export type user_measurementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_measurementCreateWithoutUserInput>, Enumerable<user_measurementUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_measurementCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_measurementUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_measurementCreateManyUserInputEnvelope
    set?: Enumerable<user_measurementWhereUniqueInput>
    disconnect?: Enumerable<user_measurementWhereUniqueInput>
    delete?: Enumerable<user_measurementWhereUniqueInput>
    connect?: Enumerable<user_measurementWhereUniqueInput>
    update?: Enumerable<user_measurementUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_measurementUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_measurementScalarWhereInput>
  }

  export type user_withingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_withingsCreateWithoutUserInput>, Enumerable<user_withingsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_withingsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_withingsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_withingsCreateManyUserInputEnvelope
    set?: Enumerable<user_withingsWhereUniqueInput>
    disconnect?: Enumerable<user_withingsWhereUniqueInput>
    delete?: Enumerable<user_withingsWhereUniqueInput>
    connect?: Enumerable<user_withingsWhereUniqueInput>
    update?: Enumerable<user_withingsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_withingsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_withingsScalarWhereInput>
  }

  export type user_patientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_patientCreateWithoutUserInput>, Enumerable<user_patientUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_patientCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_patientUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_patientCreateManyUserInputEnvelope
    set?: Enumerable<user_patientWhereUniqueInput>
    disconnect?: Enumerable<user_patientWhereUniqueInput>
    delete?: Enumerable<user_patientWhereUniqueInput>
    connect?: Enumerable<user_patientWhereUniqueInput>
    update?: Enumerable<user_patientUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_patientUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_patientScalarWhereInput>
  }

  export type user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutUserInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<user_qcuanswerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: user_qcuanswerCreateManyUserInputEnvelope
    set?: Enumerable<user_qcuanswerWhereUniqueInput>
    disconnect?: Enumerable<user_qcuanswerWhereUniqueInput>
    delete?: Enumerable<user_qcuanswerWhereUniqueInput>
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
    update?: Enumerable<user_qcuanswerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<user_qcuanswerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<user_qcuanswerScalarWhereInput>
  }

  export type userCreateNestedOneWithoutUser_centersInput = {
    create?: XOR<userCreateWithoutUser_centersInput, userUncheckedCreateWithoutUser_centersInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_centersInput
    connect?: userWhereUniqueInput
  }

  export type centerCreateNestedOneWithoutUser_centersInput = {
    create?: XOR<centerCreateWithoutUser_centersInput, centerUncheckedCreateWithoutUser_centersInput>
    connectOrCreate?: centerCreateOrConnectWithoutUser_centersInput
    connect?: centerWhereUniqueInput
  }

  export type EnumCenterRoleFieldUpdateOperationsInput = {
    set?: CenterRole
  }

  export type userUpdateOneRequiredWithoutUser_centersNestedInput = {
    create?: XOR<userCreateWithoutUser_centersInput, userUncheckedCreateWithoutUser_centersInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_centersInput
    upsert?: userUpsertWithoutUser_centersInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_centersInput, userUncheckedUpdateWithoutUser_centersInput>
  }

  export type centerUpdateOneRequiredWithoutUser_centersNestedInput = {
    create?: XOR<centerCreateWithoutUser_centersInput, centerUncheckedCreateWithoutUser_centersInput>
    connectOrCreate?: centerCreateOrConnectWithoutUser_centersInput
    upsert?: centerUpsertWithoutUser_centersInput
    connect?: centerWhereUniqueInput
    update?: XOR<centerUpdateWithoutUser_centersInput, centerUncheckedUpdateWithoutUser_centersInput>
  }

  export type userCreateNestedOneWithoutUser_goalsInput = {
    create?: XOR<userCreateWithoutUser_goalsInput, userUncheckedCreateWithoutUser_goalsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_goalsInput
    connect?: userWhereUniqueInput
  }

  export type EnumGoalTypeFieldUpdateOperationsInput = {
    set?: GoalType
  }

  export type userUpdateOneRequiredWithoutUser_goalsNestedInput = {
    create?: XOR<userCreateWithoutUser_goalsInput, userUncheckedCreateWithoutUser_goalsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_goalsInput
    upsert?: userUpsertWithoutUser_goalsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_goalsInput, userUncheckedUpdateWithoutUser_goalsInput>
  }

  export type userCreateNestedOneWithoutUser_measurementsInput = {
    create?: XOR<userCreateWithoutUser_measurementsInput, userUncheckedCreateWithoutUser_measurementsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_measurementsInput
    connect?: userWhereUniqueInput
  }

  export type EnumMeasurementTypeFieldUpdateOperationsInput = {
    set?: MeasurementType
  }

  export type userUpdateOneRequiredWithoutUser_measurementsNestedInput = {
    create?: XOR<userCreateWithoutUser_measurementsInput, userUncheckedCreateWithoutUser_measurementsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_measurementsInput
    upsert?: userUpsertWithoutUser_measurementsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_measurementsInput, userUncheckedUpdateWithoutUser_measurementsInput>
  }

  export type userCreateNestedOneWithoutUser_withingsInput = {
    create?: XOR<userCreateWithoutUser_withingsInput, userUncheckedCreateWithoutUser_withingsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_withingsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_withingsNestedInput = {
    create?: XOR<userCreateWithoutUser_withingsInput, userUncheckedCreateWithoutUser_withingsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_withingsInput
    upsert?: userUpsertWithoutUser_withingsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_withingsInput, userUncheckedUpdateWithoutUser_withingsInput>
  }

  export type userCreateNestedOneWithoutUser_patientsInput = {
    create?: XOR<userCreateWithoutUser_patientsInput, userUncheckedCreateWithoutUser_patientsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_patientsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_patientsNestedInput = {
    create?: XOR<userCreateWithoutUser_patientsInput, userUncheckedCreateWithoutUser_patientsInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_patientsInput
    upsert?: userUpsertWithoutUser_patientsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_patientsInput, userUncheckedUpdateWithoutUser_patientsInput>
  }

  export type userCreateNestedOneWithoutFractioningsInput = {
    create?: XOR<userCreateWithoutFractioningsInput, userUncheckedCreateWithoutFractioningsInput>
    connectOrCreate?: userCreateOrConnectWithoutFractioningsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutFractioningsNestedInput = {
    create?: XOR<userCreateWithoutFractioningsInput, userUncheckedCreateWithoutFractioningsInput>
    connectOrCreate?: userCreateOrConnectWithoutFractioningsInput
    upsert?: userUpsertWithoutFractioningsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutFractioningsInput, userUncheckedUpdateWithoutFractioningsInput>
  }

  export type foodCreateNestedOneWithoutMealElementsInput = {
    create?: XOR<foodCreateWithoutMealElementsInput, foodUncheckedCreateWithoutMealElementsInput>
    connectOrCreate?: foodCreateOrConnectWithoutMealElementsInput
    connect?: foodWhereUniqueInput
  }

  export type mealCreateNestedOneWithoutMeal_elementsInput = {
    create?: XOR<mealCreateWithoutMeal_elementsInput, mealUncheckedCreateWithoutMeal_elementsInput>
    connectOrCreate?: mealCreateOrConnectWithoutMeal_elementsInput
    connect?: mealWhereUniqueInput
  }

  export type food_portionCreateNestedOneWithoutMealElementsInput = {
    create?: XOR<food_portionCreateWithoutMealElementsInput, food_portionUncheckedCreateWithoutMealElementsInput>
    connectOrCreate?: food_portionCreateOrConnectWithoutMealElementsInput
    connect?: food_portionWhereUniqueInput
  }

  export type foodUpdateOneWithoutMealElementsNestedInput = {
    create?: XOR<foodCreateWithoutMealElementsInput, foodUncheckedCreateWithoutMealElementsInput>
    connectOrCreate?: foodCreateOrConnectWithoutMealElementsInput
    upsert?: foodUpsertWithoutMealElementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: foodWhereUniqueInput
    update?: XOR<foodUpdateWithoutMealElementsInput, foodUncheckedUpdateWithoutMealElementsInput>
  }

  export type mealUpdateOneRequiredWithoutMeal_elementsNestedInput = {
    create?: XOR<mealCreateWithoutMeal_elementsInput, mealUncheckedCreateWithoutMeal_elementsInput>
    connectOrCreate?: mealCreateOrConnectWithoutMeal_elementsInput
    upsert?: mealUpsertWithoutMeal_elementsInput
    connect?: mealWhereUniqueInput
    update?: XOR<mealUpdateWithoutMeal_elementsInput, mealUncheckedUpdateWithoutMeal_elementsInput>
  }

  export type food_portionUpdateOneWithoutMealElementsNestedInput = {
    create?: XOR<food_portionCreateWithoutMealElementsInput, food_portionUncheckedCreateWithoutMealElementsInput>
    connectOrCreate?: food_portionCreateOrConnectWithoutMealElementsInput
    upsert?: food_portionUpsertWithoutMealElementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: food_portionWhereUniqueInput
    update?: XOR<food_portionUpdateWithoutMealElementsInput, food_portionUncheckedUpdateWithoutMealElementsInput>
  }

  export type meal_elementCreateNestedManyWithoutMealInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutMealInput>, Enumerable<meal_elementUncheckedCreateWithoutMealInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutMealInput>
    createMany?: meal_elementCreateManyMealInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type userCreateNestedOneWithoutMealsInput = {
    create?: XOR<userCreateWithoutMealsInput, userUncheckedCreateWithoutMealsInput>
    connectOrCreate?: userCreateOrConnectWithoutMealsInput
    connect?: userWhereUniqueInput
  }

  export type meal_elementUncheckedCreateNestedManyWithoutMealInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutMealInput>, Enumerable<meal_elementUncheckedCreateWithoutMealInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutMealInput>
    createMany?: meal_elementCreateManyMealInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type meal_elementUpdateManyWithoutMealNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutMealInput>, Enumerable<meal_elementUncheckedCreateWithoutMealInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutMealInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutMealInput>
    createMany?: meal_elementCreateManyMealInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutMealInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutMealInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type userUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<userCreateWithoutMealsInput, userUncheckedCreateWithoutMealsInput>
    connectOrCreate?: userCreateOrConnectWithoutMealsInput
    upsert?: userUpsertWithoutMealsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMealsInput, userUncheckedUpdateWithoutMealsInput>
  }

  export type meal_elementUncheckedUpdateManyWithoutMealNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutMealInput>, Enumerable<meal_elementUncheckedCreateWithoutMealInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutMealInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutMealInput>
    createMany?: meal_elementCreateManyMealInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutMealInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutMealInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type foodCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<foodCreateWithoutFavoritesInput, foodUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: foodCreateOrConnectWithoutFavoritesInput
    connect?: foodWhereUniqueInput
  }

  export type food_portionCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<food_portionCreateWithoutFavoritesInput, food_portionUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: food_portionCreateOrConnectWithoutFavoritesInput
    connect?: food_portionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<userCreateWithoutFavoritesInput, userUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: userCreateOrConnectWithoutFavoritesInput
    connect?: userWhereUniqueInput
  }

  export type foodUpdateOneWithoutFavoritesNestedInput = {
    create?: XOR<foodCreateWithoutFavoritesInput, foodUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: foodCreateOrConnectWithoutFavoritesInput
    upsert?: foodUpsertWithoutFavoritesInput
    disconnect?: boolean
    delete?: boolean
    connect?: foodWhereUniqueInput
    update?: XOR<foodUpdateWithoutFavoritesInput, foodUncheckedUpdateWithoutFavoritesInput>
  }

  export type food_portionUpdateOneWithoutFavoritesNestedInput = {
    create?: XOR<food_portionCreateWithoutFavoritesInput, food_portionUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: food_portionCreateOrConnectWithoutFavoritesInput
    upsert?: food_portionUpsertWithoutFavoritesInput
    disconnect?: boolean
    delete?: boolean
    connect?: food_portionWhereUniqueInput
    update?: XOR<food_portionUpdateWithoutFavoritesInput, food_portionUncheckedUpdateWithoutFavoritesInput>
  }

  export type userUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<userCreateWithoutFavoritesInput, userUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: userCreateOrConnectWithoutFavoritesInput
    upsert?: userUpsertWithoutFavoritesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutFavoritesInput, userUncheckedUpdateWithoutFavoritesInput>
  }

  export type food_categoryCreateNestedManyWithoutCategoriyInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutCategoriyInput>, Enumerable<food_categoryUncheckedCreateWithoutCategoriyInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutCategoriyInput>
    createMany?: food_categoryCreateManyCategoriyInputEnvelope
    connect?: Enumerable<food_categoryWhereUniqueInput>
  }

  export type food_categoryUncheckedCreateNestedManyWithoutCategoriyInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutCategoriyInput>, Enumerable<food_categoryUncheckedCreateWithoutCategoriyInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutCategoriyInput>
    createMany?: food_categoryCreateManyCategoriyInputEnvelope
    connect?: Enumerable<food_categoryWhereUniqueInput>
  }

  export type food_categoryUpdateManyWithoutCategoriyNestedInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutCategoriyInput>, Enumerable<food_categoryUncheckedCreateWithoutCategoriyInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutCategoriyInput>
    upsert?: Enumerable<food_categoryUpsertWithWhereUniqueWithoutCategoriyInput>
    createMany?: food_categoryCreateManyCategoriyInputEnvelope
    set?: Enumerable<food_categoryWhereUniqueInput>
    disconnect?: Enumerable<food_categoryWhereUniqueInput>
    delete?: Enumerable<food_categoryWhereUniqueInput>
    connect?: Enumerable<food_categoryWhereUniqueInput>
    update?: Enumerable<food_categoryUpdateWithWhereUniqueWithoutCategoriyInput>
    updateMany?: Enumerable<food_categoryUpdateManyWithWhereWithoutCategoriyInput>
    deleteMany?: Enumerable<food_categoryScalarWhereInput>
  }

  export type food_categoryUncheckedUpdateManyWithoutCategoriyNestedInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutCategoriyInput>, Enumerable<food_categoryUncheckedCreateWithoutCategoriyInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutCategoriyInput>
    upsert?: Enumerable<food_categoryUpsertWithWhereUniqueWithoutCategoriyInput>
    createMany?: food_categoryCreateManyCategoriyInputEnvelope
    set?: Enumerable<food_categoryWhereUniqueInput>
    disconnect?: Enumerable<food_categoryWhereUniqueInput>
    delete?: Enumerable<food_categoryWhereUniqueInput>
    connect?: Enumerable<food_categoryWhereUniqueInput>
    update?: Enumerable<food_categoryUpdateWithWhereUniqueWithoutCategoriyInput>
    updateMany?: Enumerable<food_categoryUpdateManyWithWhereWithoutCategoriyInput>
    deleteMany?: Enumerable<food_categoryScalarWhereInput>
  }

  export type categoryCreateNestedOneWithoutFood_categoriesInput = {
    create?: XOR<categoryCreateWithoutFood_categoriesInput, categoryUncheckedCreateWithoutFood_categoriesInput>
    connectOrCreate?: categoryCreateOrConnectWithoutFood_categoriesInput
    connect?: categoryWhereUniqueInput
  }

  export type foodCreateNestedOneWithoutFood_categoriesInput = {
    create?: XOR<foodCreateWithoutFood_categoriesInput, foodUncheckedCreateWithoutFood_categoriesInput>
    connectOrCreate?: foodCreateOrConnectWithoutFood_categoriesInput
    connect?: foodWhereUniqueInput
  }

  export type categoryUpdateOneRequiredWithoutFood_categoriesNestedInput = {
    create?: XOR<categoryCreateWithoutFood_categoriesInput, categoryUncheckedCreateWithoutFood_categoriesInput>
    connectOrCreate?: categoryCreateOrConnectWithoutFood_categoriesInput
    upsert?: categoryUpsertWithoutFood_categoriesInput
    connect?: categoryWhereUniqueInput
    update?: XOR<categoryUpdateWithoutFood_categoriesInput, categoryUncheckedUpdateWithoutFood_categoriesInput>
  }

  export type foodUpdateOneRequiredWithoutFood_categoriesNestedInput = {
    create?: XOR<foodCreateWithoutFood_categoriesInput, foodUncheckedCreateWithoutFood_categoriesInput>
    connectOrCreate?: foodCreateOrConnectWithoutFood_categoriesInput
    upsert?: foodUpsertWithoutFood_categoriesInput
    connect?: foodWhereUniqueInput
    update?: XOR<foodUpdateWithoutFood_categoriesInput, foodUncheckedUpdateWithoutFood_categoriesInput>
  }

  export type foodCreateNestedOneWithoutFood_portionsInput = {
    create?: XOR<foodCreateWithoutFood_portionsInput, foodUncheckedCreateWithoutFood_portionsInput>
    connectOrCreate?: foodCreateOrConnectWithoutFood_portionsInput
    connect?: foodWhereUniqueInput
  }

  export type meal_elementCreateNestedManyWithoutFoodPortionInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodPortionInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodPortionInput>
    createMany?: meal_elementCreateManyFoodPortionInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type favoriteCreateNestedManyWithoutFoodPortionInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodPortionInput>, Enumerable<favoriteUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodPortionInput>
    createMany?: favoriteCreateManyFoodPortionInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type meal_elementUncheckedCreateNestedManyWithoutFoodPortionInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodPortionInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodPortionInput>
    createMany?: meal_elementCreateManyFoodPortionInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type favoriteUncheckedCreateNestedManyWithoutFoodPortionInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodPortionInput>, Enumerable<favoriteUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodPortionInput>
    createMany?: favoriteCreateManyFoodPortionInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type foodUpdateOneRequiredWithoutFood_portionsNestedInput = {
    create?: XOR<foodCreateWithoutFood_portionsInput, foodUncheckedCreateWithoutFood_portionsInput>
    connectOrCreate?: foodCreateOrConnectWithoutFood_portionsInput
    upsert?: foodUpsertWithoutFood_portionsInput
    connect?: foodWhereUniqueInput
    update?: XOR<foodUpdateWithoutFood_portionsInput, foodUncheckedUpdateWithoutFood_portionsInput>
  }

  export type meal_elementUpdateManyWithoutFoodPortionNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodPortionInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodPortionInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutFoodPortionInput>
    createMany?: meal_elementCreateManyFoodPortionInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutFoodPortionInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutFoodPortionInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type favoriteUpdateManyWithoutFoodPortionNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodPortionInput>, Enumerable<favoriteUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodPortionInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutFoodPortionInput>
    createMany?: favoriteCreateManyFoodPortionInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutFoodPortionInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutFoodPortionInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type meal_elementUncheckedUpdateManyWithoutFoodPortionNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodPortionInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodPortionInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutFoodPortionInput>
    createMany?: meal_elementCreateManyFoodPortionInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutFoodPortionInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutFoodPortionInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type favoriteUncheckedUpdateManyWithoutFoodPortionNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodPortionInput>, Enumerable<favoriteUncheckedCreateWithoutFoodPortionInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodPortionInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutFoodPortionInput>
    createMany?: favoriteCreateManyFoodPortionInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutFoodPortionInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutFoodPortionInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type food_categoryCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutFoodInput>, Enumerable<food_categoryUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutFoodInput>
    createMany?: food_categoryCreateManyFoodInputEnvelope
    connect?: Enumerable<food_categoryWhereUniqueInput>
  }

  export type food_portionCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<food_portionCreateWithoutFoodInput>, Enumerable<food_portionUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_portionCreateOrConnectWithoutFoodInput>
    createMany?: food_portionCreateManyFoodInputEnvelope
    connect?: Enumerable<food_portionWhereUniqueInput>
  }

  export type sourceCreateNestedOneWithoutFoodsInput = {
    create?: XOR<sourceCreateWithoutFoodsInput, sourceUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: sourceCreateOrConnectWithoutFoodsInput
    connect?: sourceWhereUniqueInput
  }

  export type nutdataCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutFoodInput>, Enumerable<nutdataUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutFoodInput>
    createMany?: nutdataCreateManyFoodInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type meal_elementCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodInput>
    createMany?: meal_elementCreateManyFoodInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type favoriteCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodInput>, Enumerable<favoriteUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodInput>
    createMany?: favoriteCreateManyFoodInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type food_categoryUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutFoodInput>, Enumerable<food_categoryUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutFoodInput>
    createMany?: food_categoryCreateManyFoodInputEnvelope
    connect?: Enumerable<food_categoryWhereUniqueInput>
  }

  export type food_portionUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<food_portionCreateWithoutFoodInput>, Enumerable<food_portionUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_portionCreateOrConnectWithoutFoodInput>
    createMany?: food_portionCreateManyFoodInputEnvelope
    connect?: Enumerable<food_portionWhereUniqueInput>
  }

  export type nutdataUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutFoodInput>, Enumerable<nutdataUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutFoodInput>
    createMany?: nutdataCreateManyFoodInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type meal_elementUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodInput>
    createMany?: meal_elementCreateManyFoodInputEnvelope
    connect?: Enumerable<meal_elementWhereUniqueInput>
  }

  export type favoriteUncheckedCreateNestedManyWithoutFoodInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodInput>, Enumerable<favoriteUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodInput>
    createMany?: favoriteCreateManyFoodInputEnvelope
    connect?: Enumerable<favoriteWhereUniqueInput>
  }

  export type food_categoryUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutFoodInput>, Enumerable<food_categoryUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<food_categoryUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: food_categoryCreateManyFoodInputEnvelope
    set?: Enumerable<food_categoryWhereUniqueInput>
    disconnect?: Enumerable<food_categoryWhereUniqueInput>
    delete?: Enumerable<food_categoryWhereUniqueInput>
    connect?: Enumerable<food_categoryWhereUniqueInput>
    update?: Enumerable<food_categoryUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<food_categoryUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<food_categoryScalarWhereInput>
  }

  export type food_portionUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<food_portionCreateWithoutFoodInput>, Enumerable<food_portionUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_portionCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<food_portionUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: food_portionCreateManyFoodInputEnvelope
    set?: Enumerable<food_portionWhereUniqueInput>
    disconnect?: Enumerable<food_portionWhereUniqueInput>
    delete?: Enumerable<food_portionWhereUniqueInput>
    connect?: Enumerable<food_portionWhereUniqueInput>
    update?: Enumerable<food_portionUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<food_portionUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<food_portionScalarWhereInput>
  }

  export type sourceUpdateOneRequiredWithoutFoodsNestedInput = {
    create?: XOR<sourceCreateWithoutFoodsInput, sourceUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: sourceCreateOrConnectWithoutFoodsInput
    upsert?: sourceUpsertWithoutFoodsInput
    connect?: sourceWhereUniqueInput
    update?: XOR<sourceUpdateWithoutFoodsInput, sourceUncheckedUpdateWithoutFoodsInput>
  }

  export type nutdataUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutFoodInput>, Enumerable<nutdataUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: nutdataCreateManyFoodInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type meal_elementUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: meal_elementCreateManyFoodInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type favoriteUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodInput>, Enumerable<favoriteUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: favoriteCreateManyFoodInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type food_categoryUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<food_categoryCreateWithoutFoodInput>, Enumerable<food_categoryUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_categoryCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<food_categoryUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: food_categoryCreateManyFoodInputEnvelope
    set?: Enumerable<food_categoryWhereUniqueInput>
    disconnect?: Enumerable<food_categoryWhereUniqueInput>
    delete?: Enumerable<food_categoryWhereUniqueInput>
    connect?: Enumerable<food_categoryWhereUniqueInput>
    update?: Enumerable<food_categoryUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<food_categoryUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<food_categoryScalarWhereInput>
  }

  export type food_portionUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<food_portionCreateWithoutFoodInput>, Enumerable<food_portionUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<food_portionCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<food_portionUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: food_portionCreateManyFoodInputEnvelope
    set?: Enumerable<food_portionWhereUniqueInput>
    disconnect?: Enumerable<food_portionWhereUniqueInput>
    delete?: Enumerable<food_portionWhereUniqueInput>
    connect?: Enumerable<food_portionWhereUniqueInput>
    update?: Enumerable<food_portionUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<food_portionUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<food_portionScalarWhereInput>
  }

  export type nutdataUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutFoodInput>, Enumerable<nutdataUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: nutdataCreateManyFoodInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type meal_elementUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<meal_elementCreateWithoutFoodInput>, Enumerable<meal_elementUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<meal_elementCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<meal_elementUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: meal_elementCreateManyFoodInputEnvelope
    set?: Enumerable<meal_elementWhereUniqueInput>
    disconnect?: Enumerable<meal_elementWhereUniqueInput>
    delete?: Enumerable<meal_elementWhereUniqueInput>
    connect?: Enumerable<meal_elementWhereUniqueInput>
    update?: Enumerable<meal_elementUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<meal_elementUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<meal_elementScalarWhereInput>
  }

  export type favoriteUncheckedUpdateManyWithoutFoodNestedInput = {
    create?: XOR<Enumerable<favoriteCreateWithoutFoodInput>, Enumerable<favoriteUncheckedCreateWithoutFoodInput>>
    connectOrCreate?: Enumerable<favoriteCreateOrConnectWithoutFoodInput>
    upsert?: Enumerable<favoriteUpsertWithWhereUniqueWithoutFoodInput>
    createMany?: favoriteCreateManyFoodInputEnvelope
    set?: Enumerable<favoriteWhereUniqueInput>
    disconnect?: Enumerable<favoriteWhereUniqueInput>
    delete?: Enumerable<favoriteWhereUniqueInput>
    connect?: Enumerable<favoriteWhereUniqueInput>
    update?: Enumerable<favoriteUpdateWithWhereUniqueWithoutFoodInput>
    updateMany?: Enumerable<favoriteUpdateManyWithWhereWithoutFoodInput>
    deleteMany?: Enumerable<favoriteScalarWhereInput>
  }

  export type foodCreateNestedOneWithoutNutdataInput = {
    create?: XOR<foodCreateWithoutNutdataInput, foodUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: foodCreateOrConnectWithoutNutdataInput
    connect?: foodWhereUniqueInput
  }

  export type nutrientCreateNestedOneWithoutNutdataInput = {
    create?: XOR<nutrientCreateWithoutNutdataInput, nutrientUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: nutrientCreateOrConnectWithoutNutdataInput
    connect?: nutrientWhereUniqueInput
  }

  export type sourceCreateNestedOneWithoutNutdataInput = {
    create?: XOR<sourceCreateWithoutNutdataInput, sourceUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: sourceCreateOrConnectWithoutNutdataInput
    connect?: sourceWhereUniqueInput
  }

  export type foodUpdateOneRequiredWithoutNutdataNestedInput = {
    create?: XOR<foodCreateWithoutNutdataInput, foodUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: foodCreateOrConnectWithoutNutdataInput
    upsert?: foodUpsertWithoutNutdataInput
    connect?: foodWhereUniqueInput
    update?: XOR<foodUpdateWithoutNutdataInput, foodUncheckedUpdateWithoutNutdataInput>
  }

  export type nutrientUpdateOneRequiredWithoutNutdataNestedInput = {
    create?: XOR<nutrientCreateWithoutNutdataInput, nutrientUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: nutrientCreateOrConnectWithoutNutdataInput
    upsert?: nutrientUpsertWithoutNutdataInput
    connect?: nutrientWhereUniqueInput
    update?: XOR<nutrientUpdateWithoutNutdataInput, nutrientUncheckedUpdateWithoutNutdataInput>
  }

  export type sourceUpdateOneRequiredWithoutNutdataNestedInput = {
    create?: XOR<sourceCreateWithoutNutdataInput, sourceUncheckedCreateWithoutNutdataInput>
    connectOrCreate?: sourceCreateOrConnectWithoutNutdataInput
    upsert?: sourceUpsertWithoutNutdataInput
    connect?: sourceWhereUniqueInput
    update?: XOR<sourceUpdateWithoutNutdataInput, sourceUncheckedUpdateWithoutNutdataInput>
  }

  export type nutdataCreateNestedManyWithoutNutrientInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutNutrientInput>, Enumerable<nutdataUncheckedCreateWithoutNutrientInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutNutrientInput>
    createMany?: nutdataCreateManyNutrientInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type nutdataUncheckedCreateNestedManyWithoutNutrientInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutNutrientInput>, Enumerable<nutdataUncheckedCreateWithoutNutrientInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutNutrientInput>
    createMany?: nutdataCreateManyNutrientInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type nutdataUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutNutrientInput>, Enumerable<nutdataUncheckedCreateWithoutNutrientInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutNutrientInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutNutrientInput>
    createMany?: nutdataCreateManyNutrientInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutNutrientInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutNutrientInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type nutdataUncheckedUpdateManyWithoutNutrientNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutNutrientInput>, Enumerable<nutdataUncheckedCreateWithoutNutrientInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutNutrientInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutNutrientInput>
    createMany?: nutdataCreateManyNutrientInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutNutrientInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutNutrientInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type foodCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<foodCreateWithoutSourceInput>, Enumerable<foodUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<foodCreateOrConnectWithoutSourceInput>
    createMany?: foodCreateManySourceInputEnvelope
    connect?: Enumerable<foodWhereUniqueInput>
  }

  export type nutdataCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutSourceInput>, Enumerable<nutdataUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutSourceInput>
    createMany?: nutdataCreateManySourceInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type foodUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<foodCreateWithoutSourceInput>, Enumerable<foodUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<foodCreateOrConnectWithoutSourceInput>
    createMany?: foodCreateManySourceInputEnvelope
    connect?: Enumerable<foodWhereUniqueInput>
  }

  export type nutdataUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutSourceInput>, Enumerable<nutdataUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutSourceInput>
    createMany?: nutdataCreateManySourceInputEnvelope
    connect?: Enumerable<nutdataWhereUniqueInput>
  }

  export type foodUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<foodCreateWithoutSourceInput>, Enumerable<foodUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<foodCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<foodUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: foodCreateManySourceInputEnvelope
    set?: Enumerable<foodWhereUniqueInput>
    disconnect?: Enumerable<foodWhereUniqueInput>
    delete?: Enumerable<foodWhereUniqueInput>
    connect?: Enumerable<foodWhereUniqueInput>
    update?: Enumerable<foodUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<foodUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<foodScalarWhereInput>
  }

  export type nutdataUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutSourceInput>, Enumerable<nutdataUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: nutdataCreateManySourceInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type foodUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<foodCreateWithoutSourceInput>, Enumerable<foodUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<foodCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<foodUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: foodCreateManySourceInputEnvelope
    set?: Enumerable<foodWhereUniqueInput>
    disconnect?: Enumerable<foodWhereUniqueInput>
    delete?: Enumerable<foodWhereUniqueInput>
    connect?: Enumerable<foodWhereUniqueInput>
    update?: Enumerable<foodUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<foodUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<foodScalarWhereInput>
  }

  export type nutdataUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<nutdataCreateWithoutSourceInput>, Enumerable<nutdataUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<nutdataCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<nutdataUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: nutdataCreateManySourceInputEnvelope
    set?: Enumerable<nutdataWhereUniqueInput>
    disconnect?: Enumerable<nutdataWhereUniqueInput>
    delete?: Enumerable<nutdataWhereUniqueInput>
    connect?: Enumerable<nutdataWhereUniqueInput>
    update?: Enumerable<nutdataUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<nutdataUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<nutdataScalarWhereInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type qcu_questionCreateNestedOneWithoutImagesInput = {
    create?: XOR<qcu_questionCreateWithoutImagesInput, qcu_questionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutImagesInput
    connect?: qcu_questionWhereUniqueInput
  }

  export type qcu_questionUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<qcu_questionCreateWithoutImagesInput, qcu_questionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutImagesInput
    upsert?: qcu_questionUpsertWithoutImagesInput
    connect?: qcu_questionWhereUniqueInput
    update?: XOR<qcu_questionUpdateWithoutImagesInput, qcu_questionUncheckedUpdateWithoutImagesInput>
  }

  export type qcu_itemCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<qcu_itemCreateWithoutQuestionInput>, Enumerable<qcu_itemUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_itemCreateOrConnectWithoutQuestionInput>
    createMany?: qcu_itemCreateManyQuestionInputEnvelope
    connect?: Enumerable<qcu_itemWhereUniqueInput>
  }

  export type qcu_imageCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<qcu_imageCreateWithoutQuestionInput>, Enumerable<qcu_imageUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_imageCreateOrConnectWithoutQuestionInput>
    createMany?: qcu_imageCreateManyQuestionInputEnvelope
    connect?: Enumerable<qcu_imageWhereUniqueInput>
  }

  export type user_qcuanswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutQuestionInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutQuestionInput>
    createMany?: user_qcuanswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
  }

  export type qcu_itemUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<qcu_itemCreateWithoutQuestionInput>, Enumerable<qcu_itemUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_itemCreateOrConnectWithoutQuestionInput>
    createMany?: qcu_itemCreateManyQuestionInputEnvelope
    connect?: Enumerable<qcu_itemWhereUniqueInput>
  }

  export type qcu_imageUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<qcu_imageCreateWithoutQuestionInput>, Enumerable<qcu_imageUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_imageCreateOrConnectWithoutQuestionInput>
    createMany?: qcu_imageCreateManyQuestionInputEnvelope
    connect?: Enumerable<qcu_imageWhereUniqueInput>
  }

  export type user_qcuanswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutQuestionInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutQuestionInput>
    createMany?: user_qcuanswerCreateManyQuestionInputEnvelope
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
  }

  export type qcu_itemUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<qcu_itemCreateWithoutQuestionInput>, Enumerable<qcu_itemUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_itemCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<qcu_itemUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: qcu_itemCreateManyQuestionInputEnvelope
    set?: Enumerable<qcu_itemWhereUniqueInput>
    disconnect?: Enumerable<qcu_itemWhereUniqueInput>
    delete?: Enumerable<qcu_itemWhereUniqueInput>
    connect?: Enumerable<qcu_itemWhereUniqueInput>
    update?: Enumerable<qcu_itemUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<qcu_itemUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<qcu_itemScalarWhereInput>
  }

  export type qcu_imageUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<qcu_imageCreateWithoutQuestionInput>, Enumerable<qcu_imageUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_imageCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<qcu_imageUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: qcu_imageCreateManyQuestionInputEnvelope
    set?: Enumerable<qcu_imageWhereUniqueInput>
    disconnect?: Enumerable<qcu_imageWhereUniqueInput>
    delete?: Enumerable<qcu_imageWhereUniqueInput>
    connect?: Enumerable<qcu_imageWhereUniqueInput>
    update?: Enumerable<qcu_imageUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<qcu_imageUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<qcu_imageScalarWhereInput>
  }

  export type user_qcuanswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutQuestionInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<user_qcuanswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: user_qcuanswerCreateManyQuestionInputEnvelope
    set?: Enumerable<user_qcuanswerWhereUniqueInput>
    disconnect?: Enumerable<user_qcuanswerWhereUniqueInput>
    delete?: Enumerable<user_qcuanswerWhereUniqueInput>
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
    update?: Enumerable<user_qcuanswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<user_qcuanswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<user_qcuanswerScalarWhereInput>
  }

  export type qcu_itemUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<qcu_itemCreateWithoutQuestionInput>, Enumerable<qcu_itemUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_itemCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<qcu_itemUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: qcu_itemCreateManyQuestionInputEnvelope
    set?: Enumerable<qcu_itemWhereUniqueInput>
    disconnect?: Enumerable<qcu_itemWhereUniqueInput>
    delete?: Enumerable<qcu_itemWhereUniqueInput>
    connect?: Enumerable<qcu_itemWhereUniqueInput>
    update?: Enumerable<qcu_itemUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<qcu_itemUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<qcu_itemScalarWhereInput>
  }

  export type qcu_imageUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<qcu_imageCreateWithoutQuestionInput>, Enumerable<qcu_imageUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<qcu_imageCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<qcu_imageUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: qcu_imageCreateManyQuestionInputEnvelope
    set?: Enumerable<qcu_imageWhereUniqueInput>
    disconnect?: Enumerable<qcu_imageWhereUniqueInput>
    delete?: Enumerable<qcu_imageWhereUniqueInput>
    connect?: Enumerable<qcu_imageWhereUniqueInput>
    update?: Enumerable<qcu_imageUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<qcu_imageUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<qcu_imageScalarWhereInput>
  }

  export type user_qcuanswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<Enumerable<user_qcuanswerCreateWithoutQuestionInput>, Enumerable<user_qcuanswerUncheckedCreateWithoutQuestionInput>>
    connectOrCreate?: Enumerable<user_qcuanswerCreateOrConnectWithoutQuestionInput>
    upsert?: Enumerable<user_qcuanswerUpsertWithWhereUniqueWithoutQuestionInput>
    createMany?: user_qcuanswerCreateManyQuestionInputEnvelope
    set?: Enumerable<user_qcuanswerWhereUniqueInput>
    disconnect?: Enumerable<user_qcuanswerWhereUniqueInput>
    delete?: Enumerable<user_qcuanswerWhereUniqueInput>
    connect?: Enumerable<user_qcuanswerWhereUniqueInput>
    update?: Enumerable<user_qcuanswerUpdateWithWhereUniqueWithoutQuestionInput>
    updateMany?: Enumerable<user_qcuanswerUpdateManyWithWhereWithoutQuestionInput>
    deleteMany?: Enumerable<user_qcuanswerScalarWhereInput>
  }

  export type qcu_questionCreateNestedOneWithoutItemsInput = {
    create?: XOR<qcu_questionCreateWithoutItemsInput, qcu_questionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutItemsInput
    connect?: qcu_questionWhereUniqueInput
  }

  export type qcu_questionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<qcu_questionCreateWithoutItemsInput, qcu_questionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutItemsInput
    upsert?: qcu_questionUpsertWithoutItemsInput
    connect?: qcu_questionWhereUniqueInput
    update?: XOR<qcu_questionUpdateWithoutItemsInput, qcu_questionUncheckedUpdateWithoutItemsInput>
  }

  export type userCreateNestedOneWithoutUser_qcuanswersInput = {
    create?: XOR<userCreateWithoutUser_qcuanswersInput, userUncheckedCreateWithoutUser_qcuanswersInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_qcuanswersInput
    connect?: userWhereUniqueInput
  }

  export type qcu_questionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<qcu_questionCreateWithoutAnswersInput, qcu_questionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutAnswersInput
    connect?: qcu_questionWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUser_qcuanswersNestedInput = {
    create?: XOR<userCreateWithoutUser_qcuanswersInput, userUncheckedCreateWithoutUser_qcuanswersInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_qcuanswersInput
    upsert?: userUpsertWithoutUser_qcuanswersInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutUser_qcuanswersInput, userUncheckedUpdateWithoutUser_qcuanswersInput>
  }

  export type qcu_questionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<qcu_questionCreateWithoutAnswersInput, qcu_questionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: qcu_questionCreateOrConnectWithoutAnswersInput
    upsert?: qcu_questionUpsertWithoutAnswersInput
    connect?: qcu_questionWhereUniqueInput
    update?: XOR<qcu_questionUpdateWithoutAnswersInput, qcu_questionUncheckedUpdateWithoutAnswersInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumCenterTypeFilter = {
    equals?: CenterType
    in?: Enumerable<CenterType>
    notIn?: Enumerable<CenterType>
    not?: NestedEnumCenterTypeFilter | CenterType
  }

  export type NestedEnumCenterTypeWithAggregatesFilter = {
    equals?: CenterType
    in?: Enumerable<CenterType>
    notIn?: Enumerable<CenterType>
    not?: NestedEnumCenterTypeWithAggregatesFilter | CenterType
    _count?: NestedIntFilter
    _min?: NestedEnumCenterTypeFilter
    _max?: NestedEnumCenterTypeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumPatientCaregiverTypeFilter = {
    equals?: PatientCaregiverType
    in?: Enumerable<PatientCaregiverType>
    notIn?: Enumerable<PatientCaregiverType>
    not?: NestedEnumPatientCaregiverTypeFilter | PatientCaregiverType
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumPatientCaregiverTypeWithAggregatesFilter = {
    equals?: PatientCaregiverType
    in?: Enumerable<PatientCaregiverType>
    notIn?: Enumerable<PatientCaregiverType>
    not?: NestedEnumPatientCaregiverTypeWithAggregatesFilter | PatientCaregiverType
    _count?: NestedIntFilter
    _min?: NestedEnumPatientCaregiverTypeFilter
    _max?: NestedEnumPatientCaregiverTypeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | Decimal | DecimalJsLike | number | string | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumCenterRoleFilter = {
    equals?: CenterRole
    in?: Enumerable<CenterRole>
    notIn?: Enumerable<CenterRole>
    not?: NestedEnumCenterRoleFilter | CenterRole
  }

  export type NestedEnumCenterRoleWithAggregatesFilter = {
    equals?: CenterRole
    in?: Enumerable<CenterRole>
    notIn?: Enumerable<CenterRole>
    not?: NestedEnumCenterRoleWithAggregatesFilter | CenterRole
    _count?: NestedIntFilter
    _min?: NestedEnumCenterRoleFilter
    _max?: NestedEnumCenterRoleFilter
  }

  export type NestedEnumGoalTypeFilter = {
    equals?: GoalType
    in?: Enumerable<GoalType>
    notIn?: Enumerable<GoalType>
    not?: NestedEnumGoalTypeFilter | GoalType
  }

  export type NestedEnumGoalTypeWithAggregatesFilter = {
    equals?: GoalType
    in?: Enumerable<GoalType>
    notIn?: Enumerable<GoalType>
    not?: NestedEnumGoalTypeWithAggregatesFilter | GoalType
    _count?: NestedIntFilter
    _min?: NestedEnumGoalTypeFilter
    _max?: NestedEnumGoalTypeFilter
  }

  export type NestedEnumMeasurementTypeFilter = {
    equals?: MeasurementType
    in?: Enumerable<MeasurementType>
    notIn?: Enumerable<MeasurementType>
    not?: NestedEnumMeasurementTypeFilter | MeasurementType
  }

  export type NestedEnumMeasurementTypeWithAggregatesFilter = {
    equals?: MeasurementType
    in?: Enumerable<MeasurementType>
    notIn?: Enumerable<MeasurementType>
    not?: NestedEnumMeasurementTypeWithAggregatesFilter | MeasurementType
    _count?: NestedIntFilter
    _min?: NestedEnumMeasurementTypeFilter
    _max?: NestedEnumMeasurementTypeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type user_actionCreateWithoutSessionInput = {
    time: Date | string
    action: string
    user: userCreateNestedOneWithoutUser_actionsInput
  }

  export type user_actionUncheckedCreateWithoutSessionInput = {
    id?: number
    time: Date | string
    user_id: number
    action: string
  }

  export type user_actionCreateOrConnectWithoutSessionInput = {
    where: user_actionWhereUniqueInput
    create: XOR<user_actionCreateWithoutSessionInput, user_actionUncheckedCreateWithoutSessionInput>
  }

  export type user_actionCreateManySessionInputEnvelope = {
    data: Enumerable<user_actionCreateManySessionInput>
    skipDuplicates?: boolean
  }

  export type user_actionUpsertWithWhereUniqueWithoutSessionInput = {
    where: user_actionWhereUniqueInput
    update: XOR<user_actionUpdateWithoutSessionInput, user_actionUncheckedUpdateWithoutSessionInput>
    create: XOR<user_actionCreateWithoutSessionInput, user_actionUncheckedCreateWithoutSessionInput>
  }

  export type user_actionUpdateWithWhereUniqueWithoutSessionInput = {
    where: user_actionWhereUniqueInput
    data: XOR<user_actionUpdateWithoutSessionInput, user_actionUncheckedUpdateWithoutSessionInput>
  }

  export type user_actionUpdateManyWithWhereWithoutSessionInput = {
    where: user_actionScalarWhereInput
    data: XOR<user_actionUpdateManyMutationInput, user_actionUncheckedUpdateManyWithoutUser_actionsInput>
  }

  export type user_actionScalarWhereInput = {
    AND?: Enumerable<user_actionScalarWhereInput>
    OR?: Enumerable<user_actionScalarWhereInput>
    NOT?: Enumerable<user_actionScalarWhereInput>
    id?: IntFilter | number
    session_id?: IntFilter | number
    time?: DateTimeFilter | Date | string
    user_id?: IntFilter | number
    action?: StringFilter | string
  }

  export type sessionCreateWithoutUser_actionsInput = {
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type sessionUncheckedCreateWithoutUser_actionsInput = {
    id?: number
    startTime: Date | string
    endTime?: Date | string | null
  }

  export type sessionCreateOrConnectWithoutUser_actionsInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutUser_actionsInput, sessionUncheckedCreateWithoutUser_actionsInput>
  }

  export type userCreateWithoutUser_actionsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_actionsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_actionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_actionsInput, userUncheckedCreateWithoutUser_actionsInput>
  }

  export type sessionUpsertWithoutUser_actionsInput = {
    update: XOR<sessionUpdateWithoutUser_actionsInput, sessionUncheckedUpdateWithoutUser_actionsInput>
    create: XOR<sessionCreateWithoutUser_actionsInput, sessionUncheckedCreateWithoutUser_actionsInput>
  }

  export type sessionUpdateWithoutUser_actionsInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUncheckedUpdateWithoutUser_actionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUpsertWithoutUser_actionsInput = {
    update: XOR<userUpdateWithoutUser_actionsInput, userUncheckedUpdateWithoutUser_actionsInput>
    create: XOR<userCreateWithoutUser_actionsInput, userUncheckedCreateWithoutUser_actionsInput>
  }

  export type userUpdateWithoutUser_actionsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_actionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type user_centerCreateWithoutCenterInput = {
    created_at?: Date | string | null
    role: CenterRole
    user: userCreateNestedOneWithoutUser_centersInput
  }

  export type user_centerUncheckedCreateWithoutCenterInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    role: CenterRole
  }

  export type user_centerCreateOrConnectWithoutCenterInput = {
    where: user_centerWhereUniqueInput
    create: XOR<user_centerCreateWithoutCenterInput, user_centerUncheckedCreateWithoutCenterInput>
  }

  export type user_centerCreateManyCenterInputEnvelope = {
    data: Enumerable<user_centerCreateManyCenterInput>
    skipDuplicates?: boolean
  }

  export type user_centerUpsertWithWhereUniqueWithoutCenterInput = {
    where: user_centerWhereUniqueInput
    update: XOR<user_centerUpdateWithoutCenterInput, user_centerUncheckedUpdateWithoutCenterInput>
    create: XOR<user_centerCreateWithoutCenterInput, user_centerUncheckedCreateWithoutCenterInput>
  }

  export type user_centerUpdateWithWhereUniqueWithoutCenterInput = {
    where: user_centerWhereUniqueInput
    data: XOR<user_centerUpdateWithoutCenterInput, user_centerUncheckedUpdateWithoutCenterInput>
  }

  export type user_centerUpdateManyWithWhereWithoutCenterInput = {
    where: user_centerScalarWhereInput
    data: XOR<user_centerUpdateManyMutationInput, user_centerUncheckedUpdateManyWithoutUser_centersInput>
  }

  export type user_centerScalarWhereInput = {
    AND?: Enumerable<user_centerScalarWhereInput>
    OR?: Enumerable<user_centerScalarWhereInput>
    NOT?: Enumerable<user_centerScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    center_id?: IntFilter | number
    role?: EnumCenterRoleFilter | CenterRole
  }

  export type userCreateWithoutMessages_fromInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessages_fromInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessages_fromInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessages_fromInput, userUncheckedCreateWithoutMessages_fromInput>
  }

  export type userCreateWithoutMessages_toInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessages_toInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessages_toInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessages_toInput, userUncheckedCreateWithoutMessages_toInput>
  }

  export type userUpsertWithoutMessages_fromInput = {
    update: XOR<userUpdateWithoutMessages_fromInput, userUncheckedUpdateWithoutMessages_fromInput>
    create: XOR<userCreateWithoutMessages_fromInput, userUncheckedCreateWithoutMessages_fromInput>
  }

  export type userUpdateWithoutMessages_fromInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessages_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutMessages_toInput = {
    update: XOR<userUpdateWithoutMessages_toInput, userUncheckedUpdateWithoutMessages_toInput>
    create: XOR<userCreateWithoutMessages_toInput, userUncheckedCreateWithoutMessages_toInput>
  }

  export type userUpdateWithoutMessages_toInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessages_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutPatientsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPatientsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPatientsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPatientsInput, userUncheckedCreateWithoutPatientsInput>
  }

  export type userCreateWithoutCaregiversInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCaregiversInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCaregiversInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCaregiversInput, userUncheckedCreateWithoutCaregiversInput>
  }

  export type userUpsertWithoutPatientsInput = {
    update: XOR<userUpdateWithoutPatientsInput, userUncheckedUpdateWithoutPatientsInput>
    create: XOR<userCreateWithoutPatientsInput, userUncheckedCreateWithoutPatientsInput>
  }

  export type userUpdateWithoutPatientsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutCaregiversInput = {
    update: XOR<userUpdateWithoutCaregiversInput, userUncheckedUpdateWithoutCaregiversInput>
    create: XOR<userCreateWithoutCaregiversInput, userUncheckedCreateWithoutCaregiversInput>
  }

  export type userUpdateWithoutCaregiversInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCaregiversInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type user_actionCreateWithoutUserInput = {
    time: Date | string
    action: string
    session: sessionCreateNestedOneWithoutUser_actionsInput
  }

  export type user_actionUncheckedCreateWithoutUserInput = {
    id?: number
    session_id: number
    time: Date | string
    action: string
  }

  export type user_actionCreateOrConnectWithoutUserInput = {
    where: user_actionWhereUniqueInput
    create: XOR<user_actionCreateWithoutUserInput, user_actionUncheckedCreateWithoutUserInput>
  }

  export type user_actionCreateManyUserInputEnvelope = {
    data: Enumerable<user_actionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type favoriteCreateWithoutUserInput = {
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutFavoritesInput
    foodPortion?: food_portionCreateNestedOneWithoutFavoritesInput
  }

  export type favoriteUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateOrConnectWithoutUserInput = {
    where: favoriteWhereUniqueInput
    create: XOR<favoriteCreateWithoutUserInput, favoriteUncheckedCreateWithoutUserInput>
  }

  export type favoriteCreateManyUserInputEnvelope = {
    data: Enumerable<favoriteCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type fractioningCreateWithoutUserInput = {
    created_at?: Date | string | null
    date?: string | null
    meal_types?: string | null
  }

  export type fractioningUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    date?: string | null
    meal_types?: string | null
  }

  export type fractioningCreateOrConnectWithoutUserInput = {
    where: fractioningWhereUniqueInput
    create: XOR<fractioningCreateWithoutUserInput, fractioningUncheckedCreateWithoutUserInput>
  }

  export type fractioningCreateManyUserInputEnvelope = {
    data: Enumerable<fractioningCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type mealCreateWithoutUsersInput = {
    created_at?: Date | string | null
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
    meal_elements?: meal_elementCreateNestedManyWithoutMealInput
  }

  export type mealUncheckedCreateWithoutUsersInput = {
    id?: number
    created_at?: Date | string | null
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
    meal_elements?: meal_elementUncheckedCreateNestedManyWithoutMealInput
  }

  export type mealCreateOrConnectWithoutUsersInput = {
    where: mealWhereUniqueInput
    create: XOR<mealCreateWithoutUsersInput, mealUncheckedCreateWithoutUsersInput>
  }

  export type mealCreateManyUsersInputEnvelope = {
    data: Enumerable<mealCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutFromInput = {
    created_at?: Date | string | null
    read_on?: Date | string | null
    content: string
    to: userCreateNestedOneWithoutMessages_toInput
  }

  export type messageUncheckedCreateWithoutFromInput = {
    id?: number
    created_at?: Date | string | null
    to_id: number
    read_on?: Date | string | null
    content: string
  }

  export type messageCreateOrConnectWithoutFromInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutFromInput, messageUncheckedCreateWithoutFromInput>
  }

  export type messageCreateManyFromInputEnvelope = {
    data: Enumerable<messageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutToInput = {
    created_at?: Date | string | null
    read_on?: Date | string | null
    content: string
    from: userCreateNestedOneWithoutMessages_fromInput
  }

  export type messageUncheckedCreateWithoutToInput = {
    id?: number
    created_at?: Date | string | null
    from_id: number
    read_on?: Date | string | null
    content: string
  }

  export type messageCreateOrConnectWithoutToInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutToInput, messageUncheckedCreateWithoutToInput>
  }

  export type messageCreateManyToInputEnvelope = {
    data: Enumerable<messageCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type patient_caregiverCreateWithoutPatientInput = {
    created_at?: Date | string | null
    confirmed?: boolean
    role: PatientCaregiverType
    caregiver: userCreateNestedOneWithoutCaregiversInput
  }

  export type patient_caregiverUncheckedCreateWithoutPatientInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    caregiver_id: number
    role: PatientCaregiverType
  }

  export type patient_caregiverCreateOrConnectWithoutPatientInput = {
    where: patient_caregiverWhereUniqueInput
    create: XOR<patient_caregiverCreateWithoutPatientInput, patient_caregiverUncheckedCreateWithoutPatientInput>
  }

  export type patient_caregiverCreateManyPatientInputEnvelope = {
    data: Enumerable<patient_caregiverCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type patient_caregiverCreateWithoutCaregiverInput = {
    created_at?: Date | string | null
    confirmed?: boolean
    role: PatientCaregiverType
    patient: userCreateNestedOneWithoutPatientsInput
  }

  export type patient_caregiverUncheckedCreateWithoutCaregiverInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    patient_id: number
    role: PatientCaregiverType
  }

  export type patient_caregiverCreateOrConnectWithoutCaregiverInput = {
    where: patient_caregiverWhereUniqueInput
    create: XOR<patient_caregiverCreateWithoutCaregiverInput, patient_caregiverUncheckedCreateWithoutCaregiverInput>
  }

  export type patient_caregiverCreateManyCaregiverInputEnvelope = {
    data: Enumerable<patient_caregiverCreateManyCaregiverInput>
    skipDuplicates?: boolean
  }

  export type user_centerCreateWithoutUserInput = {
    created_at?: Date | string | null
    role: CenterRole
    center: centerCreateNestedOneWithoutUser_centersInput
  }

  export type user_centerUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    center_id: number
    role: CenterRole
  }

  export type user_centerCreateOrConnectWithoutUserInput = {
    where: user_centerWhereUniqueInput
    create: XOR<user_centerCreateWithoutUserInput, user_centerUncheckedCreateWithoutUserInput>
  }

  export type user_centerCreateManyUserInputEnvelope = {
    data: Enumerable<user_centerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_goalCreateWithoutUserInput = {
    created_at?: Date | string | null
    date: Date | string
    type: GoalType
    value: string
  }

  export type user_goalUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    date: Date | string
    type: GoalType
    value: string
  }

  export type user_goalCreateOrConnectWithoutUserInput = {
    where: user_goalWhereUniqueInput
    create: XOR<user_goalCreateWithoutUserInput, user_goalUncheckedCreateWithoutUserInput>
  }

  export type user_goalCreateManyUserInputEnvelope = {
    data: Enumerable<user_goalCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_measurementCreateWithoutUserInput = {
    created_at?: Date | string | null
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementCreateOrConnectWithoutUserInput = {
    where: user_measurementWhereUniqueInput
    create: XOR<user_measurementCreateWithoutUserInput, user_measurementUncheckedCreateWithoutUserInput>
  }

  export type user_measurementCreateManyUserInputEnvelope = {
    data: Enumerable<user_measurementCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_withingsCreateWithoutUserInput = {
    created_at?: Date | string | null
    withings_userid: string
    access_token: string
    refresh_token: string
  }

  export type user_withingsUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    withings_userid: string
    access_token: string
    refresh_token: string
  }

  export type user_withingsCreateOrConnectWithoutUserInput = {
    where: user_withingsWhereUniqueInput
    create: XOR<user_withingsCreateWithoutUserInput, user_withingsUncheckedCreateWithoutUserInput>
  }

  export type user_withingsCreateManyUserInputEnvelope = {
    data: Enumerable<user_withingsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_patientCreateWithoutUserInput = {
    created_at?: Date | string | null
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
  }

  export type user_patientUncheckedCreateWithoutUserInput = {
    id?: number
    created_at?: Date | string | null
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
  }

  export type user_patientCreateOrConnectWithoutUserInput = {
    where: user_patientWhereUniqueInput
    create: XOR<user_patientCreateWithoutUserInput, user_patientUncheckedCreateWithoutUserInput>
  }

  export type user_patientCreateManyUserInputEnvelope = {
    data: Enumerable<user_patientCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_qcuanswerCreateWithoutUserInput = {
    timestamp?: Date | string | null
    success: boolean
    question: qcu_questionCreateNestedOneWithoutAnswersInput
  }

  export type user_qcuanswerUncheckedCreateWithoutUserInput = {
    id?: number
    timestamp?: Date | string | null
    qcuquestion_id: number
    success: boolean
  }

  export type user_qcuanswerCreateOrConnectWithoutUserInput = {
    where: user_qcuanswerWhereUniqueInput
    create: XOR<user_qcuanswerCreateWithoutUserInput, user_qcuanswerUncheckedCreateWithoutUserInput>
  }

  export type user_qcuanswerCreateManyUserInputEnvelope = {
    data: Enumerable<user_qcuanswerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type user_actionUpsertWithWhereUniqueWithoutUserInput = {
    where: user_actionWhereUniqueInput
    update: XOR<user_actionUpdateWithoutUserInput, user_actionUncheckedUpdateWithoutUserInput>
    create: XOR<user_actionCreateWithoutUserInput, user_actionUncheckedCreateWithoutUserInput>
  }

  export type user_actionUpdateWithWhereUniqueWithoutUserInput = {
    where: user_actionWhereUniqueInput
    data: XOR<user_actionUpdateWithoutUserInput, user_actionUncheckedUpdateWithoutUserInput>
  }

  export type user_actionUpdateManyWithWhereWithoutUserInput = {
    where: user_actionScalarWhereInput
    data: XOR<user_actionUpdateManyMutationInput, user_actionUncheckedUpdateManyWithoutUser_actionsInput>
  }

  export type favoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: favoriteWhereUniqueInput
    update: XOR<favoriteUpdateWithoutUserInput, favoriteUncheckedUpdateWithoutUserInput>
    create: XOR<favoriteCreateWithoutUserInput, favoriteUncheckedCreateWithoutUserInput>
  }

  export type favoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: favoriteWhereUniqueInput
    data: XOR<favoriteUpdateWithoutUserInput, favoriteUncheckedUpdateWithoutUserInput>
  }

  export type favoriteUpdateManyWithWhereWithoutUserInput = {
    where: favoriteScalarWhereInput
    data: XOR<favoriteUpdateManyMutationInput, favoriteUncheckedUpdateManyWithoutFavoritesInput>
  }

  export type favoriteScalarWhereInput = {
    AND?: Enumerable<favoriteScalarWhereInput>
    OR?: Enumerable<favoriteScalarWhereInput>
    NOT?: Enumerable<favoriteScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    mealtype?: StringNullableFilter | string | null
    count?: IntNullableFilter | number | null
    food_id?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    portion_id?: IntNullableFilter | number | null
    portion_cnt?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type fractioningUpsertWithWhereUniqueWithoutUserInput = {
    where: fractioningWhereUniqueInput
    update: XOR<fractioningUpdateWithoutUserInput, fractioningUncheckedUpdateWithoutUserInput>
    create: XOR<fractioningCreateWithoutUserInput, fractioningUncheckedCreateWithoutUserInput>
  }

  export type fractioningUpdateWithWhereUniqueWithoutUserInput = {
    where: fractioningWhereUniqueInput
    data: XOR<fractioningUpdateWithoutUserInput, fractioningUncheckedUpdateWithoutUserInput>
  }

  export type fractioningUpdateManyWithWhereWithoutUserInput = {
    where: fractioningScalarWhereInput
    data: XOR<fractioningUpdateManyMutationInput, fractioningUncheckedUpdateManyWithoutFractioningsInput>
  }

  export type fractioningScalarWhereInput = {
    AND?: Enumerable<fractioningScalarWhereInput>
    OR?: Enumerable<fractioningScalarWhereInput>
    NOT?: Enumerable<fractioningScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: StringNullableFilter | string | null
    meal_types?: StringNullableFilter | string | null
  }

  export type mealUpsertWithWhereUniqueWithoutUsersInput = {
    where: mealWhereUniqueInput
    update: XOR<mealUpdateWithoutUsersInput, mealUncheckedUpdateWithoutUsersInput>
    create: XOR<mealCreateWithoutUsersInput, mealUncheckedCreateWithoutUsersInput>
  }

  export type mealUpdateWithWhereUniqueWithoutUsersInput = {
    where: mealWhereUniqueInput
    data: XOR<mealUpdateWithoutUsersInput, mealUncheckedUpdateWithoutUsersInput>
  }

  export type mealUpdateManyWithWhereWithoutUsersInput = {
    where: mealScalarWhereInput
    data: XOR<mealUpdateManyMutationInput, mealUncheckedUpdateManyWithoutMealsInput>
  }

  export type mealScalarWhereInput = {
    AND?: Enumerable<mealScalarWhereInput>
    OR?: Enumerable<mealScalarWhereInput>
    NOT?: Enumerable<mealScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: StringNullableFilter | string | null
    mealtype?: StringNullableFilter | string | null
    really_eaten?: BoolNullableFilter | boolean | null
  }

  export type messageUpsertWithWhereUniqueWithoutFromInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutFromInput, messageUncheckedUpdateWithoutFromInput>
    create: XOR<messageCreateWithoutFromInput, messageUncheckedCreateWithoutFromInput>
  }

  export type messageUpdateWithWhereUniqueWithoutFromInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutFromInput, messageUncheckedUpdateWithoutFromInput>
  }

  export type messageUpdateManyWithWhereWithoutFromInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutMessages_fromInput>
  }

  export type messageScalarWhereInput = {
    AND?: Enumerable<messageScalarWhereInput>
    OR?: Enumerable<messageScalarWhereInput>
    NOT?: Enumerable<messageScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    from_id?: IntFilter | number
    to_id?: IntFilter | number
    read_on?: DateTimeNullableFilter | Date | string | null
    content?: StringFilter | string
  }

  export type messageUpsertWithWhereUniqueWithoutToInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutToInput, messageUncheckedUpdateWithoutToInput>
    create: XOR<messageCreateWithoutToInput, messageUncheckedCreateWithoutToInput>
  }

  export type messageUpdateWithWhereUniqueWithoutToInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutToInput, messageUncheckedUpdateWithoutToInput>
  }

  export type messageUpdateManyWithWhereWithoutToInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutMessages_toInput>
  }

  export type patient_caregiverUpsertWithWhereUniqueWithoutPatientInput = {
    where: patient_caregiverWhereUniqueInput
    update: XOR<patient_caregiverUpdateWithoutPatientInput, patient_caregiverUncheckedUpdateWithoutPatientInput>
    create: XOR<patient_caregiverCreateWithoutPatientInput, patient_caregiverUncheckedCreateWithoutPatientInput>
  }

  export type patient_caregiverUpdateWithWhereUniqueWithoutPatientInput = {
    where: patient_caregiverWhereUniqueInput
    data: XOR<patient_caregiverUpdateWithoutPatientInput, patient_caregiverUncheckedUpdateWithoutPatientInput>
  }

  export type patient_caregiverUpdateManyWithWhereWithoutPatientInput = {
    where: patient_caregiverScalarWhereInput
    data: XOR<patient_caregiverUpdateManyMutationInput, patient_caregiverUncheckedUpdateManyWithoutPatientsInput>
  }

  export type patient_caregiverScalarWhereInput = {
    AND?: Enumerable<patient_caregiverScalarWhereInput>
    OR?: Enumerable<patient_caregiverScalarWhereInput>
    NOT?: Enumerable<patient_caregiverScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    confirmed?: BoolFilter | boolean
    patient_id?: IntFilter | number
    caregiver_id?: IntFilter | number
    role?: EnumPatientCaregiverTypeFilter | PatientCaregiverType
  }

  export type patient_caregiverUpsertWithWhereUniqueWithoutCaregiverInput = {
    where: patient_caregiverWhereUniqueInput
    update: XOR<patient_caregiverUpdateWithoutCaregiverInput, patient_caregiverUncheckedUpdateWithoutCaregiverInput>
    create: XOR<patient_caregiverCreateWithoutCaregiverInput, patient_caregiverUncheckedCreateWithoutCaregiverInput>
  }

  export type patient_caregiverUpdateWithWhereUniqueWithoutCaregiverInput = {
    where: patient_caregiverWhereUniqueInput
    data: XOR<patient_caregiverUpdateWithoutCaregiverInput, patient_caregiverUncheckedUpdateWithoutCaregiverInput>
  }

  export type patient_caregiverUpdateManyWithWhereWithoutCaregiverInput = {
    where: patient_caregiverScalarWhereInput
    data: XOR<patient_caregiverUpdateManyMutationInput, patient_caregiverUncheckedUpdateManyWithoutCaregiversInput>
  }

  export type user_centerUpsertWithWhereUniqueWithoutUserInput = {
    where: user_centerWhereUniqueInput
    update: XOR<user_centerUpdateWithoutUserInput, user_centerUncheckedUpdateWithoutUserInput>
    create: XOR<user_centerCreateWithoutUserInput, user_centerUncheckedCreateWithoutUserInput>
  }

  export type user_centerUpdateWithWhereUniqueWithoutUserInput = {
    where: user_centerWhereUniqueInput
    data: XOR<user_centerUpdateWithoutUserInput, user_centerUncheckedUpdateWithoutUserInput>
  }

  export type user_centerUpdateManyWithWhereWithoutUserInput = {
    where: user_centerScalarWhereInput
    data: XOR<user_centerUpdateManyMutationInput, user_centerUncheckedUpdateManyWithoutUser_centersInput>
  }

  export type user_goalUpsertWithWhereUniqueWithoutUserInput = {
    where: user_goalWhereUniqueInput
    update: XOR<user_goalUpdateWithoutUserInput, user_goalUncheckedUpdateWithoutUserInput>
    create: XOR<user_goalCreateWithoutUserInput, user_goalUncheckedCreateWithoutUserInput>
  }

  export type user_goalUpdateWithWhereUniqueWithoutUserInput = {
    where: user_goalWhereUniqueInput
    data: XOR<user_goalUpdateWithoutUserInput, user_goalUncheckedUpdateWithoutUserInput>
  }

  export type user_goalUpdateManyWithWhereWithoutUserInput = {
    where: user_goalScalarWhereInput
    data: XOR<user_goalUpdateManyMutationInput, user_goalUncheckedUpdateManyWithoutUser_goalsInput>
  }

  export type user_goalScalarWhereInput = {
    AND?: Enumerable<user_goalScalarWhereInput>
    OR?: Enumerable<user_goalScalarWhereInput>
    NOT?: Enumerable<user_goalScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumGoalTypeFilter | GoalType
    value?: StringFilter | string
  }

  export type user_measurementUpsertWithWhereUniqueWithoutUserInput = {
    where: user_measurementWhereUniqueInput
    update: XOR<user_measurementUpdateWithoutUserInput, user_measurementUncheckedUpdateWithoutUserInput>
    create: XOR<user_measurementCreateWithoutUserInput, user_measurementUncheckedCreateWithoutUserInput>
  }

  export type user_measurementUpdateWithWhereUniqueWithoutUserInput = {
    where: user_measurementWhereUniqueInput
    data: XOR<user_measurementUpdateWithoutUserInput, user_measurementUncheckedUpdateWithoutUserInput>
  }

  export type user_measurementUpdateManyWithWhereWithoutUserInput = {
    where: user_measurementScalarWhereInput
    data: XOR<user_measurementUpdateManyMutationInput, user_measurementUncheckedUpdateManyWithoutUser_measurementsInput>
  }

  export type user_measurementScalarWhereInput = {
    AND?: Enumerable<user_measurementScalarWhereInput>
    OR?: Enumerable<user_measurementScalarWhereInput>
    NOT?: Enumerable<user_measurementScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    type?: EnumMeasurementTypeFilter | MeasurementType
    value?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type user_withingsUpsertWithWhereUniqueWithoutUserInput = {
    where: user_withingsWhereUniqueInput
    update: XOR<user_withingsUpdateWithoutUserInput, user_withingsUncheckedUpdateWithoutUserInput>
    create: XOR<user_withingsCreateWithoutUserInput, user_withingsUncheckedCreateWithoutUserInput>
  }

  export type user_withingsUpdateWithWhereUniqueWithoutUserInput = {
    where: user_withingsWhereUniqueInput
    data: XOR<user_withingsUpdateWithoutUserInput, user_withingsUncheckedUpdateWithoutUserInput>
  }

  export type user_withingsUpdateManyWithWhereWithoutUserInput = {
    where: user_withingsScalarWhereInput
    data: XOR<user_withingsUpdateManyMutationInput, user_withingsUncheckedUpdateManyWithoutUser_withingsInput>
  }

  export type user_withingsScalarWhereInput = {
    AND?: Enumerable<user_withingsScalarWhereInput>
    OR?: Enumerable<user_withingsScalarWhereInput>
    NOT?: Enumerable<user_withingsScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    withings_userid?: StringFilter | string
    access_token?: StringFilter | string
    refresh_token?: StringFilter | string
  }

  export type user_patientUpsertWithWhereUniqueWithoutUserInput = {
    where: user_patientWhereUniqueInput
    update: XOR<user_patientUpdateWithoutUserInput, user_patientUncheckedUpdateWithoutUserInput>
    create: XOR<user_patientCreateWithoutUserInput, user_patientUncheckedCreateWithoutUserInput>
  }

  export type user_patientUpdateWithWhereUniqueWithoutUserInput = {
    where: user_patientWhereUniqueInput
    data: XOR<user_patientUpdateWithoutUserInput, user_patientUncheckedUpdateWithoutUserInput>
  }

  export type user_patientUpdateManyWithWhereWithoutUserInput = {
    where: user_patientScalarWhereInput
    data: XOR<user_patientUpdateManyMutationInput, user_patientUncheckedUpdateManyWithoutUser_patientsInput>
  }

  export type user_patientScalarWhereInput = {
    AND?: Enumerable<user_patientScalarWhereInput>
    OR?: Enumerable<user_patientScalarWhereInput>
    NOT?: Enumerable<user_patientScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    protocol_code?: StringNullableFilter | string | null
    protocol_inclusion_date?: StringNullableFilter | string | null
  }

  export type user_qcuanswerUpsertWithWhereUniqueWithoutUserInput = {
    where: user_qcuanswerWhereUniqueInput
    update: XOR<user_qcuanswerUpdateWithoutUserInput, user_qcuanswerUncheckedUpdateWithoutUserInput>
    create: XOR<user_qcuanswerCreateWithoutUserInput, user_qcuanswerUncheckedCreateWithoutUserInput>
  }

  export type user_qcuanswerUpdateWithWhereUniqueWithoutUserInput = {
    where: user_qcuanswerWhereUniqueInput
    data: XOR<user_qcuanswerUpdateWithoutUserInput, user_qcuanswerUncheckedUpdateWithoutUserInput>
  }

  export type user_qcuanswerUpdateManyWithWhereWithoutUserInput = {
    where: user_qcuanswerScalarWhereInput
    data: XOR<user_qcuanswerUpdateManyMutationInput, user_qcuanswerUncheckedUpdateManyWithoutUser_qcuanswersInput>
  }

  export type user_qcuanswerScalarWhereInput = {
    AND?: Enumerable<user_qcuanswerScalarWhereInput>
    OR?: Enumerable<user_qcuanswerScalarWhereInput>
    NOT?: Enumerable<user_qcuanswerScalarWhereInput>
    id?: IntFilter | number
    timestamp?: DateTimeNullableFilter | Date | string | null
    user_id?: IntFilter | number
    qcuquestion_id?: IntFilter | number
    success?: BoolFilter | boolean
  }

  export type userCreateWithoutUser_centersInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_centersInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_centersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_centersInput, userUncheckedCreateWithoutUser_centersInput>
  }

  export type centerCreateWithoutUser_centersInput = {
    created_at?: Date | string | null
    type: CenterType
    name: string
  }

  export type centerUncheckedCreateWithoutUser_centersInput = {
    id?: number
    created_at?: Date | string | null
    type: CenterType
    name: string
  }

  export type centerCreateOrConnectWithoutUser_centersInput = {
    where: centerWhereUniqueInput
    create: XOR<centerCreateWithoutUser_centersInput, centerUncheckedCreateWithoutUser_centersInput>
  }

  export type userUpsertWithoutUser_centersInput = {
    update: XOR<userUpdateWithoutUser_centersInput, userUncheckedUpdateWithoutUser_centersInput>
    create: XOR<userCreateWithoutUser_centersInput, userUncheckedCreateWithoutUser_centersInput>
  }

  export type userUpdateWithoutUser_centersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_centersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type centerUpsertWithoutUser_centersInput = {
    update: XOR<centerUpdateWithoutUser_centersInput, centerUncheckedUpdateWithoutUser_centersInput>
    create: XOR<centerCreateWithoutUser_centersInput, centerUncheckedCreateWithoutUser_centersInput>
  }

  export type centerUpdateWithoutUser_centersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
  }

  export type centerUncheckedUpdateWithoutUser_centersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: EnumCenterTypeFieldUpdateOperationsInput | CenterType
    name?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateWithoutUser_goalsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_goalsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_goalsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_goalsInput, userUncheckedCreateWithoutUser_goalsInput>
  }

  export type userUpsertWithoutUser_goalsInput = {
    update: XOR<userUpdateWithoutUser_goalsInput, userUncheckedUpdateWithoutUser_goalsInput>
    create: XOR<userCreateWithoutUser_goalsInput, userUncheckedCreateWithoutUser_goalsInput>
  }

  export type userUpdateWithoutUser_goalsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_goalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUser_measurementsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_measurementsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_measurementsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_measurementsInput, userUncheckedCreateWithoutUser_measurementsInput>
  }

  export type userUpsertWithoutUser_measurementsInput = {
    update: XOR<userUpdateWithoutUser_measurementsInput, userUncheckedUpdateWithoutUser_measurementsInput>
    create: XOR<userCreateWithoutUser_measurementsInput, userUncheckedCreateWithoutUser_measurementsInput>
  }

  export type userUpdateWithoutUser_measurementsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_measurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUser_withingsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_withingsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_withingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_withingsInput, userUncheckedCreateWithoutUser_withingsInput>
  }

  export type userUpsertWithoutUser_withingsInput = {
    update: XOR<userUpdateWithoutUser_withingsInput, userUncheckedUpdateWithoutUser_withingsInput>
    create: XOR<userCreateWithoutUser_withingsInput, userUncheckedCreateWithoutUser_withingsInput>
  }

  export type userUpdateWithoutUser_withingsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_withingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutUser_patientsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_patientsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_patientsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_patientsInput, userUncheckedCreateWithoutUser_patientsInput>
  }

  export type userUpsertWithoutUser_patientsInput = {
    update: XOR<userUpdateWithoutUser_patientsInput, userUncheckedUpdateWithoutUser_patientsInput>
    create: XOR<userCreateWithoutUser_patientsInput, userUncheckedCreateWithoutUser_patientsInput>
  }

  export type userUpdateWithoutUser_patientsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_patientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutFractioningsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFractioningsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFractioningsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFractioningsInput, userUncheckedCreateWithoutFractioningsInput>
  }

  export type userUpsertWithoutFractioningsInput = {
    update: XOR<userUpdateWithoutFractioningsInput, userUncheckedUpdateWithoutFractioningsInput>
    create: XOR<userCreateWithoutFractioningsInput, userUncheckedCreateWithoutFractioningsInput>
  }

  export type userUpdateWithoutFractioningsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFractioningsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type foodCreateWithoutMealElementsInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutMealElementsInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutMealElementsInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutMealElementsInput, foodUncheckedCreateWithoutMealElementsInput>
  }

  export type mealCreateWithoutMeal_elementsInput = {
    created_at?: Date | string | null
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
    users: userCreateNestedOneWithoutMealsInput
  }

  export type mealUncheckedCreateWithoutMeal_elementsInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
  }

  export type mealCreateOrConnectWithoutMeal_elementsInput = {
    where: mealWhereUniqueInput
    create: XOR<mealCreateWithoutMeal_elementsInput, mealUncheckedCreateWithoutMeal_elementsInput>
  }

  export type food_portionCreateWithoutMealElementsInput = {
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food: foodCreateNestedOneWithoutFood_portionsInput
    favorites?: favoriteCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionUncheckedCreateWithoutMealElementsInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food_id: number
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionCreateOrConnectWithoutMealElementsInput = {
    where: food_portionWhereUniqueInput
    create: XOR<food_portionCreateWithoutMealElementsInput, food_portionUncheckedCreateWithoutMealElementsInput>
  }

  export type foodUpsertWithoutMealElementsInput = {
    update: XOR<foodUpdateWithoutMealElementsInput, foodUncheckedUpdateWithoutMealElementsInput>
    create: XOR<foodCreateWithoutMealElementsInput, foodUncheckedCreateWithoutMealElementsInput>
  }

  export type foodUpdateWithoutMealElementsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutMealElementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type mealUpsertWithoutMeal_elementsInput = {
    update: XOR<mealUpdateWithoutMeal_elementsInput, mealUncheckedUpdateWithoutMeal_elementsInput>
    create: XOR<mealCreateWithoutMeal_elementsInput, mealUncheckedCreateWithoutMeal_elementsInput>
  }

  export type mealUpdateWithoutMeal_elementsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: userUpdateOneRequiredWithoutMealsNestedInput
  }

  export type mealUncheckedUpdateWithoutMeal_elementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type food_portionUpsertWithoutMealElementsInput = {
    update: XOR<food_portionUpdateWithoutMealElementsInput, food_portionUncheckedUpdateWithoutMealElementsInput>
    create: XOR<food_portionCreateWithoutMealElementsInput, food_portionUncheckedCreateWithoutMealElementsInput>
  }

  export type food_portionUpdateWithoutMealElementsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutFood_portionsNestedInput
    favorites?: favoriteUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionUncheckedUpdateWithoutMealElementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    favorites?: favoriteUncheckedUpdateManyWithoutFoodPortionNestedInput
  }

  export type meal_elementCreateWithoutMealInput = {
    created_at?: Date | string | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutMealElementsInput
    foodPortion?: food_portionCreateNestedOneWithoutMealElementsInput
  }

  export type meal_elementUncheckedCreateWithoutMealInput = {
    id?: number
    created_at?: Date | string | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementCreateOrConnectWithoutMealInput = {
    where: meal_elementWhereUniqueInput
    create: XOR<meal_elementCreateWithoutMealInput, meal_elementUncheckedCreateWithoutMealInput>
  }

  export type meal_elementCreateManyMealInputEnvelope = {
    data: Enumerable<meal_elementCreateManyMealInput>
    skipDuplicates?: boolean
  }

  export type userCreateWithoutMealsInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMealsInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMealsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMealsInput, userUncheckedCreateWithoutMealsInput>
  }

  export type meal_elementUpsertWithWhereUniqueWithoutMealInput = {
    where: meal_elementWhereUniqueInput
    update: XOR<meal_elementUpdateWithoutMealInput, meal_elementUncheckedUpdateWithoutMealInput>
    create: XOR<meal_elementCreateWithoutMealInput, meal_elementUncheckedCreateWithoutMealInput>
  }

  export type meal_elementUpdateWithWhereUniqueWithoutMealInput = {
    where: meal_elementWhereUniqueInput
    data: XOR<meal_elementUpdateWithoutMealInput, meal_elementUncheckedUpdateWithoutMealInput>
  }

  export type meal_elementUpdateManyWithWhereWithoutMealInput = {
    where: meal_elementScalarWhereInput
    data: XOR<meal_elementUpdateManyMutationInput, meal_elementUncheckedUpdateManyWithoutMeal_elementsInput>
  }

  export type meal_elementScalarWhereInput = {
    AND?: Enumerable<meal_elementScalarWhereInput>
    OR?: Enumerable<meal_elementScalarWhereInput>
    NOT?: Enumerable<meal_elementScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    meal_id?: IntFilter | number
    food_id?: IntNullableFilter | number | null
    weight?: StringNullableFilter | string | null
    portion_id?: IntNullableFilter | number | null
    portion_cnt?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type userUpsertWithoutMealsInput = {
    update: XOR<userUpdateWithoutMealsInput, userUncheckedUpdateWithoutMealsInput>
    create: XOR<userCreateWithoutMealsInput, userUncheckedCreateWithoutMealsInput>
  }

  export type userUpdateWithoutMealsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMealsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type foodCreateWithoutFavoritesInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutFavoritesInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutFavoritesInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutFavoritesInput, foodUncheckedCreateWithoutFavoritesInput>
  }

  export type food_portionCreateWithoutFavoritesInput = {
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food: foodCreateNestedOneWithoutFood_portionsInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionUncheckedCreateWithoutFavoritesInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    food_id: number
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionCreateOrConnectWithoutFavoritesInput = {
    where: food_portionWhereUniqueInput
    create: XOR<food_portionCreateWithoutFavoritesInput, food_portionUncheckedCreateWithoutFavoritesInput>
  }

  export type userCreateWithoutFavoritesInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFavoritesInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
    user_qcuanswers?: user_qcuanswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFavoritesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFavoritesInput, userUncheckedCreateWithoutFavoritesInput>
  }

  export type foodUpsertWithoutFavoritesInput = {
    update: XOR<foodUpdateWithoutFavoritesInput, foodUncheckedUpdateWithoutFavoritesInput>
    create: XOR<foodCreateWithoutFavoritesInput, foodUncheckedCreateWithoutFavoritesInput>
  }

  export type foodUpdateWithoutFavoritesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type food_portionUpsertWithoutFavoritesInput = {
    update: XOR<food_portionUpdateWithoutFavoritesInput, food_portionUncheckedUpdateWithoutFavoritesInput>
    create: XOR<food_portionCreateWithoutFavoritesInput, food_portionUncheckedCreateWithoutFavoritesInput>
  }

  export type food_portionUpdateWithoutFavoritesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutFood_portionsNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodPortionNestedInput
  }

  export type userUpsertWithoutFavoritesInput = {
    update: XOR<userUpdateWithoutFavoritesInput, userUncheckedUpdateWithoutFavoritesInput>
    create: XOR<userCreateWithoutFavoritesInput, userUncheckedCreateWithoutFavoritesInput>
  }

  export type userUpdateWithoutFavoritesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
    user_qcuanswers?: user_qcuanswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type food_categoryCreateWithoutCategoriyInput = {
    created_at?: Date | string | null
    food: foodCreateNestedOneWithoutFood_categoriesInput
  }

  export type food_categoryUncheckedCreateWithoutCategoriyInput = {
    id?: number
    created_at?: Date | string | null
    food_id: number
  }

  export type food_categoryCreateOrConnectWithoutCategoriyInput = {
    where: food_categoryWhereUniqueInput
    create: XOR<food_categoryCreateWithoutCategoriyInput, food_categoryUncheckedCreateWithoutCategoriyInput>
  }

  export type food_categoryCreateManyCategoriyInputEnvelope = {
    data: Enumerable<food_categoryCreateManyCategoriyInput>
    skipDuplicates?: boolean
  }

  export type food_categoryUpsertWithWhereUniqueWithoutCategoriyInput = {
    where: food_categoryWhereUniqueInput
    update: XOR<food_categoryUpdateWithoutCategoriyInput, food_categoryUncheckedUpdateWithoutCategoriyInput>
    create: XOR<food_categoryCreateWithoutCategoriyInput, food_categoryUncheckedCreateWithoutCategoriyInput>
  }

  export type food_categoryUpdateWithWhereUniqueWithoutCategoriyInput = {
    where: food_categoryWhereUniqueInput
    data: XOR<food_categoryUpdateWithoutCategoriyInput, food_categoryUncheckedUpdateWithoutCategoriyInput>
  }

  export type food_categoryUpdateManyWithWhereWithoutCategoriyInput = {
    where: food_categoryScalarWhereInput
    data: XOR<food_categoryUpdateManyMutationInput, food_categoryUncheckedUpdateManyWithoutFood_categoriesInput>
  }

  export type food_categoryScalarWhereInput = {
    AND?: Enumerable<food_categoryScalarWhereInput>
    OR?: Enumerable<food_categoryScalarWhereInput>
    NOT?: Enumerable<food_categoryScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    food_id?: IntFilter | number
    category_id?: IntFilter | number
  }

  export type categoryCreateWithoutFood_categoriesInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_gpcd?: string | null
    member_of_id?: number | null
    rank?: number | null
    tag?: string | null
  }

  export type categoryUncheckedCreateWithoutFood_categoriesInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_gpcd?: string | null
    member_of_id?: number | null
    rank?: number | null
    tag?: string | null
  }

  export type categoryCreateOrConnectWithoutFood_categoriesInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutFood_categoriesInput, categoryUncheckedCreateWithoutFood_categoriesInput>
  }

  export type foodCreateWithoutFood_categoriesInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutFood_categoriesInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutFood_categoriesInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutFood_categoriesInput, foodUncheckedCreateWithoutFood_categoriesInput>
  }

  export type categoryUpsertWithoutFood_categoriesInput = {
    update: XOR<categoryUpdateWithoutFood_categoriesInput, categoryUncheckedUpdateWithoutFood_categoriesInput>
    create: XOR<categoryCreateWithoutFood_categoriesInput, categoryUncheckedCreateWithoutFood_categoriesInput>
  }

  export type categoryUpdateWithoutFood_categoriesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoryUncheckedUpdateWithoutFood_categoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_gpcd?: NullableStringFieldUpdateOperationsInput | string | null
    member_of_id?: NullableIntFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foodUpsertWithoutFood_categoriesInput = {
    update: XOR<foodUpdateWithoutFood_categoriesInput, foodUncheckedUpdateWithoutFood_categoriesInput>
    create: XOR<foodCreateWithoutFood_categoriesInput, foodUncheckedCreateWithoutFood_categoriesInput>
  }

  export type foodUpdateWithoutFood_categoriesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutFood_categoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type foodCreateWithoutFood_portionsInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutFood_portionsInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutFood_portionsInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutFood_portionsInput, foodUncheckedCreateWithoutFood_portionsInput>
  }

  export type meal_elementCreateWithoutFoodPortionInput = {
    created_at?: Date | string | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutMealElementsInput
    meal: mealCreateNestedOneWithoutMeal_elementsInput
  }

  export type meal_elementUncheckedCreateWithoutFoodPortionInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    food_id?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementCreateOrConnectWithoutFoodPortionInput = {
    where: meal_elementWhereUniqueInput
    create: XOR<meal_elementCreateWithoutFoodPortionInput, meal_elementUncheckedCreateWithoutFoodPortionInput>
  }

  export type meal_elementCreateManyFoodPortionInputEnvelope = {
    data: Enumerable<meal_elementCreateManyFoodPortionInput>
    skipDuplicates?: boolean
  }

  export type favoriteCreateWithoutFoodPortionInput = {
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    food?: foodCreateNestedOneWithoutFavoritesInput
    user: userCreateNestedOneWithoutFavoritesInput
  }

  export type favoriteUncheckedCreateWithoutFoodPortionInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateOrConnectWithoutFoodPortionInput = {
    where: favoriteWhereUniqueInput
    create: XOR<favoriteCreateWithoutFoodPortionInput, favoriteUncheckedCreateWithoutFoodPortionInput>
  }

  export type favoriteCreateManyFoodPortionInputEnvelope = {
    data: Enumerable<favoriteCreateManyFoodPortionInput>
    skipDuplicates?: boolean
  }

  export type foodUpsertWithoutFood_portionsInput = {
    update: XOR<foodUpdateWithoutFood_portionsInput, foodUncheckedUpdateWithoutFood_portionsInput>
    create: XOR<foodCreateWithoutFood_portionsInput, foodUncheckedCreateWithoutFood_portionsInput>
  }

  export type foodUpdateWithoutFood_portionsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutFood_portionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type meal_elementUpsertWithWhereUniqueWithoutFoodPortionInput = {
    where: meal_elementWhereUniqueInput
    update: XOR<meal_elementUpdateWithoutFoodPortionInput, meal_elementUncheckedUpdateWithoutFoodPortionInput>
    create: XOR<meal_elementCreateWithoutFoodPortionInput, meal_elementUncheckedCreateWithoutFoodPortionInput>
  }

  export type meal_elementUpdateWithWhereUniqueWithoutFoodPortionInput = {
    where: meal_elementWhereUniqueInput
    data: XOR<meal_elementUpdateWithoutFoodPortionInput, meal_elementUncheckedUpdateWithoutFoodPortionInput>
  }

  export type meal_elementUpdateManyWithWhereWithoutFoodPortionInput = {
    where: meal_elementScalarWhereInput
    data: XOR<meal_elementUpdateManyMutationInput, meal_elementUncheckedUpdateManyWithoutMealElementsInput>
  }

  export type favoriteUpsertWithWhereUniqueWithoutFoodPortionInput = {
    where: favoriteWhereUniqueInput
    update: XOR<favoriteUpdateWithoutFoodPortionInput, favoriteUncheckedUpdateWithoutFoodPortionInput>
    create: XOR<favoriteCreateWithoutFoodPortionInput, favoriteUncheckedCreateWithoutFoodPortionInput>
  }

  export type favoriteUpdateWithWhereUniqueWithoutFoodPortionInput = {
    where: favoriteWhereUniqueInput
    data: XOR<favoriteUpdateWithoutFoodPortionInput, favoriteUncheckedUpdateWithoutFoodPortionInput>
  }

  export type favoriteUpdateManyWithWhereWithoutFoodPortionInput = {
    where: favoriteScalarWhereInput
    data: XOR<favoriteUpdateManyMutationInput, favoriteUncheckedUpdateManyWithoutFavoritesInput>
  }

  export type food_categoryCreateWithoutFoodInput = {
    created_at?: Date | string | null
    categoriy: categoryCreateNestedOneWithoutFood_categoriesInput
  }

  export type food_categoryUncheckedCreateWithoutFoodInput = {
    id?: number
    created_at?: Date | string | null
    category_id: number
  }

  export type food_categoryCreateOrConnectWithoutFoodInput = {
    where: food_categoryWhereUniqueInput
    create: XOR<food_categoryCreateWithoutFoodInput, food_categoryUncheckedCreateWithoutFoodInput>
  }

  export type food_categoryCreateManyFoodInputEnvelope = {
    data: Enumerable<food_categoryCreateManyFoodInput>
    skipDuplicates?: boolean
  }

  export type food_portionCreateWithoutFoodInput = {
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    mealElements?: meal_elementCreateNestedManyWithoutFoodPortionInput
    favorites?: favoriteCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionUncheckedCreateWithoutFoodInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodPortionInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodPortionInput
  }

  export type food_portionCreateOrConnectWithoutFoodInput = {
    where: food_portionWhereUniqueInput
    create: XOR<food_portionCreateWithoutFoodInput, food_portionUncheckedCreateWithoutFoodInput>
  }

  export type food_portionCreateManyFoodInputEnvelope = {
    data: Enumerable<food_portionCreateManyFoodInput>
    skipDuplicates?: boolean
  }

  export type sourceCreateWithoutFoodsInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    nutdata?: nutdataCreateNestedManyWithoutSourceInput
  }

  export type sourceUncheckedCreateWithoutFoodsInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    nutdata?: nutdataUncheckedCreateNestedManyWithoutSourceInput
  }

  export type sourceCreateOrConnectWithoutFoodsInput = {
    where: sourceWhereUniqueInput
    create: XOR<sourceCreateWithoutFoodsInput, sourceUncheckedCreateWithoutFoodsInput>
  }

  export type nutdataCreateWithoutFoodInput = {
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    nutrient: nutrientCreateNestedOneWithoutNutdataInput
    source: sourceCreateNestedOneWithoutNutdataInput
  }

  export type nutdataUncheckedCreateWithoutFoodInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    nutr_no: string
    source_id: number
  }

  export type nutdataCreateOrConnectWithoutFoodInput = {
    where: nutdataWhereUniqueInput
    create: XOR<nutdataCreateWithoutFoodInput, nutdataUncheckedCreateWithoutFoodInput>
  }

  export type nutdataCreateManyFoodInputEnvelope = {
    data: Enumerable<nutdataCreateManyFoodInput>
    skipDuplicates?: boolean
  }

  export type meal_elementCreateWithoutFoodInput = {
    created_at?: Date | string | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    meal: mealCreateNestedOneWithoutMeal_elementsInput
    foodPortion?: food_portionCreateNestedOneWithoutMealElementsInput
  }

  export type meal_elementUncheckedCreateWithoutFoodInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementCreateOrConnectWithoutFoodInput = {
    where: meal_elementWhereUniqueInput
    create: XOR<meal_elementCreateWithoutFoodInput, meal_elementUncheckedCreateWithoutFoodInput>
  }

  export type meal_elementCreateManyFoodInputEnvelope = {
    data: Enumerable<meal_elementCreateManyFoodInput>
    skipDuplicates?: boolean
  }

  export type favoriteCreateWithoutFoodInput = {
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
    foodPortion?: food_portionCreateNestedOneWithoutFavoritesInput
    user: userCreateNestedOneWithoutFavoritesInput
  }

  export type favoriteUncheckedCreateWithoutFoodInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateOrConnectWithoutFoodInput = {
    where: favoriteWhereUniqueInput
    create: XOR<favoriteCreateWithoutFoodInput, favoriteUncheckedCreateWithoutFoodInput>
  }

  export type favoriteCreateManyFoodInputEnvelope = {
    data: Enumerable<favoriteCreateManyFoodInput>
    skipDuplicates?: boolean
  }

  export type food_categoryUpsertWithWhereUniqueWithoutFoodInput = {
    where: food_categoryWhereUniqueInput
    update: XOR<food_categoryUpdateWithoutFoodInput, food_categoryUncheckedUpdateWithoutFoodInput>
    create: XOR<food_categoryCreateWithoutFoodInput, food_categoryUncheckedCreateWithoutFoodInput>
  }

  export type food_categoryUpdateWithWhereUniqueWithoutFoodInput = {
    where: food_categoryWhereUniqueInput
    data: XOR<food_categoryUpdateWithoutFoodInput, food_categoryUncheckedUpdateWithoutFoodInput>
  }

  export type food_categoryUpdateManyWithWhereWithoutFoodInput = {
    where: food_categoryScalarWhereInput
    data: XOR<food_categoryUpdateManyMutationInput, food_categoryUncheckedUpdateManyWithoutFood_categoriesInput>
  }

  export type food_portionUpsertWithWhereUniqueWithoutFoodInput = {
    where: food_portionWhereUniqueInput
    update: XOR<food_portionUpdateWithoutFoodInput, food_portionUncheckedUpdateWithoutFoodInput>
    create: XOR<food_portionCreateWithoutFoodInput, food_portionUncheckedCreateWithoutFoodInput>
  }

  export type food_portionUpdateWithWhereUniqueWithoutFoodInput = {
    where: food_portionWhereUniqueInput
    data: XOR<food_portionUpdateWithoutFoodInput, food_portionUncheckedUpdateWithoutFoodInput>
  }

  export type food_portionUpdateManyWithWhereWithoutFoodInput = {
    where: food_portionScalarWhereInput
    data: XOR<food_portionUpdateManyMutationInput, food_portionUncheckedUpdateManyWithoutFood_portionsInput>
  }

  export type food_portionScalarWhereInput = {
    AND?: Enumerable<food_portionScalarWhereInput>
    OR?: Enumerable<food_portionScalarWhereInput>
    NOT?: Enumerable<food_portionScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    qty?: StringFilter | string
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    pict?: StringNullableFilter | string | null
    food_id?: IntFilter | number
  }

  export type sourceUpsertWithoutFoodsInput = {
    update: XOR<sourceUpdateWithoutFoodsInput, sourceUncheckedUpdateWithoutFoodsInput>
    create: XOR<sourceCreateWithoutFoodsInput, sourceUncheckedCreateWithoutFoodsInput>
  }

  export type sourceUpdateWithoutFoodsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    nutdata?: nutdataUpdateManyWithoutSourceNestedInput
  }

  export type sourceUncheckedUpdateWithoutFoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    nutdata?: nutdataUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type nutdataUpsertWithWhereUniqueWithoutFoodInput = {
    where: nutdataWhereUniqueInput
    update: XOR<nutdataUpdateWithoutFoodInput, nutdataUncheckedUpdateWithoutFoodInput>
    create: XOR<nutdataCreateWithoutFoodInput, nutdataUncheckedCreateWithoutFoodInput>
  }

  export type nutdataUpdateWithWhereUniqueWithoutFoodInput = {
    where: nutdataWhereUniqueInput
    data: XOR<nutdataUpdateWithoutFoodInput, nutdataUncheckedUpdateWithoutFoodInput>
  }

  export type nutdataUpdateManyWithWhereWithoutFoodInput = {
    where: nutdataScalarWhereInput
    data: XOR<nutdataUpdateManyMutationInput, nutdataUncheckedUpdateManyWithoutNutdataInput>
  }

  export type nutdataScalarWhereInput = {
    AND?: Enumerable<nutdataScalarWhereInput>
    OR?: Enumerable<nutdataScalarWhereInput>
    NOT?: Enumerable<nutdataScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    val?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    food_id?: IntFilter | number
    nutr_no?: StringFilter | string
    source_id?: IntFilter | number
  }

  export type meal_elementUpsertWithWhereUniqueWithoutFoodInput = {
    where: meal_elementWhereUniqueInput
    update: XOR<meal_elementUpdateWithoutFoodInput, meal_elementUncheckedUpdateWithoutFoodInput>
    create: XOR<meal_elementCreateWithoutFoodInput, meal_elementUncheckedCreateWithoutFoodInput>
  }

  export type meal_elementUpdateWithWhereUniqueWithoutFoodInput = {
    where: meal_elementWhereUniqueInput
    data: XOR<meal_elementUpdateWithoutFoodInput, meal_elementUncheckedUpdateWithoutFoodInput>
  }

  export type meal_elementUpdateManyWithWhereWithoutFoodInput = {
    where: meal_elementScalarWhereInput
    data: XOR<meal_elementUpdateManyMutationInput, meal_elementUncheckedUpdateManyWithoutMealElementsInput>
  }

  export type favoriteUpsertWithWhereUniqueWithoutFoodInput = {
    where: favoriteWhereUniqueInput
    update: XOR<favoriteUpdateWithoutFoodInput, favoriteUncheckedUpdateWithoutFoodInput>
    create: XOR<favoriteCreateWithoutFoodInput, favoriteUncheckedCreateWithoutFoodInput>
  }

  export type favoriteUpdateWithWhereUniqueWithoutFoodInput = {
    where: favoriteWhereUniqueInput
    data: XOR<favoriteUpdateWithoutFoodInput, favoriteUncheckedUpdateWithoutFoodInput>
  }

  export type favoriteUpdateManyWithWhereWithoutFoodInput = {
    where: favoriteScalarWhereInput
    data: XOR<favoriteUpdateManyMutationInput, favoriteUncheckedUpdateManyWithoutFavoritesInput>
  }

  export type foodCreateWithoutNutdataInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    source: sourceCreateNestedOneWithoutFoodsInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutNutdataInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    source_id: number
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutNutdataInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutNutdataInput, foodUncheckedCreateWithoutNutdataInput>
  }

  export type nutrientCreateWithoutNutdataInput = {
    nutr_no: string
    created_at?: Date | string | null
    ifda_no?: string | null
    unit?: string | null
    shrt_desc?: string | null
    long_desc?: string | null
    energy_density?: Decimal | DecimalJsLike | number | string | null
  }

  export type nutrientUncheckedCreateWithoutNutdataInput = {
    nutr_no: string
    created_at?: Date | string | null
    ifda_no?: string | null
    unit?: string | null
    shrt_desc?: string | null
    long_desc?: string | null
    energy_density?: Decimal | DecimalJsLike | number | string | null
  }

  export type nutrientCreateOrConnectWithoutNutdataInput = {
    where: nutrientWhereUniqueInput
    create: XOR<nutrientCreateWithoutNutdataInput, nutrientUncheckedCreateWithoutNutdataInput>
  }

  export type sourceCreateWithoutNutdataInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    foods?: foodCreateNestedManyWithoutSourceInput
  }

  export type sourceUncheckedCreateWithoutNutdataInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    foods?: foodUncheckedCreateNestedManyWithoutSourceInput
  }

  export type sourceCreateOrConnectWithoutNutdataInput = {
    where: sourceWhereUniqueInput
    create: XOR<sourceCreateWithoutNutdataInput, sourceUncheckedCreateWithoutNutdataInput>
  }

  export type foodUpsertWithoutNutdataInput = {
    update: XOR<foodUpdateWithoutNutdataInput, foodUncheckedUpdateWithoutNutdataInput>
    create: XOR<foodCreateWithoutNutdataInput, foodUncheckedCreateWithoutNutdataInput>
  }

  export type foodUpdateWithoutNutdataInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    source?: sourceUpdateOneRequiredWithoutFoodsNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutNutdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: IntFieldUpdateOperationsInput | number
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type nutrientUpsertWithoutNutdataInput = {
    update: XOR<nutrientUpdateWithoutNutdataInput, nutrientUncheckedUpdateWithoutNutdataInput>
    create: XOR<nutrientCreateWithoutNutdataInput, nutrientUncheckedCreateWithoutNutdataInput>
  }

  export type nutrientUpdateWithoutNutdataInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type nutrientUncheckedUpdateWithoutNutdataInput = {
    nutr_no?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ifda_no?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    energy_density?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type sourceUpsertWithoutNutdataInput = {
    update: XOR<sourceUpdateWithoutNutdataInput, sourceUncheckedUpdateWithoutNutdataInput>
    create: XOR<sourceCreateWithoutNutdataInput, sourceUncheckedCreateWithoutNutdataInput>
  }

  export type sourceUpdateWithoutNutdataInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    foods?: foodUpdateManyWithoutSourceNestedInput
  }

  export type sourceUncheckedUpdateWithoutNutdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    foods?: foodUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type nutdataCreateWithoutNutrientInput = {
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food: foodCreateNestedOneWithoutNutdataInput
    source: sourceCreateNestedOneWithoutNutdataInput
  }

  export type nutdataUncheckedCreateWithoutNutrientInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    source_id: number
  }

  export type nutdataCreateOrConnectWithoutNutrientInput = {
    where: nutdataWhereUniqueInput
    create: XOR<nutdataCreateWithoutNutrientInput, nutdataUncheckedCreateWithoutNutrientInput>
  }

  export type nutdataCreateManyNutrientInputEnvelope = {
    data: Enumerable<nutdataCreateManyNutrientInput>
    skipDuplicates?: boolean
  }

  export type nutdataUpsertWithWhereUniqueWithoutNutrientInput = {
    where: nutdataWhereUniqueInput
    update: XOR<nutdataUpdateWithoutNutrientInput, nutdataUncheckedUpdateWithoutNutrientInput>
    create: XOR<nutdataCreateWithoutNutrientInput, nutdataUncheckedCreateWithoutNutrientInput>
  }

  export type nutdataUpdateWithWhereUniqueWithoutNutrientInput = {
    where: nutdataWhereUniqueInput
    data: XOR<nutdataUpdateWithoutNutrientInput, nutdataUncheckedUpdateWithoutNutrientInput>
  }

  export type nutdataUpdateManyWithWhereWithoutNutrientInput = {
    where: nutdataScalarWhereInput
    data: XOR<nutdataUpdateManyMutationInput, nutdataUncheckedUpdateManyWithoutNutdataInput>
  }

  export type foodCreateWithoutSourceInput = {
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryCreateNestedManyWithoutFoodInput
    food_portions?: food_portionCreateNestedManyWithoutFoodInput
    nutdata?: nutdataCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementCreateNestedManyWithoutFoodInput
    favorites?: favoriteCreateNestedManyWithoutFoodInput
  }

  export type foodUncheckedCreateWithoutSourceInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
    food_categories?: food_categoryUncheckedCreateNestedManyWithoutFoodInput
    food_portions?: food_portionUncheckedCreateNestedManyWithoutFoodInput
    nutdata?: nutdataUncheckedCreateNestedManyWithoutFoodInput
    mealElements?: meal_elementUncheckedCreateNestedManyWithoutFoodInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutFoodInput
  }

  export type foodCreateOrConnectWithoutSourceInput = {
    where: foodWhereUniqueInput
    create: XOR<foodCreateWithoutSourceInput, foodUncheckedCreateWithoutSourceInput>
  }

  export type foodCreateManySourceInputEnvelope = {
    data: Enumerable<foodCreateManySourceInput>
    skipDuplicates?: boolean
  }

  export type nutdataCreateWithoutSourceInput = {
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food: foodCreateNestedOneWithoutNutdataInput
    nutrient: nutrientCreateNestedOneWithoutNutdataInput
  }

  export type nutdataUncheckedCreateWithoutSourceInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    nutr_no: string
  }

  export type nutdataCreateOrConnectWithoutSourceInput = {
    where: nutdataWhereUniqueInput
    create: XOR<nutdataCreateWithoutSourceInput, nutdataUncheckedCreateWithoutSourceInput>
  }

  export type nutdataCreateManySourceInputEnvelope = {
    data: Enumerable<nutdataCreateManySourceInput>
    skipDuplicates?: boolean
  }

  export type foodUpsertWithWhereUniqueWithoutSourceInput = {
    where: foodWhereUniqueInput
    update: XOR<foodUpdateWithoutSourceInput, foodUncheckedUpdateWithoutSourceInput>
    create: XOR<foodCreateWithoutSourceInput, foodUncheckedCreateWithoutSourceInput>
  }

  export type foodUpdateWithWhereUniqueWithoutSourceInput = {
    where: foodWhereUniqueInput
    data: XOR<foodUpdateWithoutSourceInput, foodUncheckedUpdateWithoutSourceInput>
  }

  export type foodUpdateManyWithWhereWithoutSourceInput = {
    where: foodScalarWhereInput
    data: XOR<foodUpdateManyMutationInput, foodUncheckedUpdateManyWithoutFoodsInput>
  }

  export type foodScalarWhereInput = {
    AND?: Enumerable<foodScalarWhereInput>
    OR?: Enumerable<foodScalarWhereInput>
    NOT?: Enumerable<foodScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    shrt_desc?: StringFilter | string
    long_desc?: StringNullableFilter | string | null
    ciqual_name?: StringNullableFilter | string | null
    ctdit_shrt_desc?: StringNullableFilter | string | null
    ctdit_long_desc?: StringNullableFilter | string | null
    keywords?: StringNullableFilter | string | null
    ciqual_num?: StringNullableFilter | string | null
    note?: StringNullableFilter | string | null
    max_qty?: StringNullableFilter | string | null
    pict?: StringNullableFilter | string | null
    source_id?: IntFilter | number
    is_brand?: BoolNullableFilter | boolean | null
    is_raw?: BoolNullableFilter | boolean | null
    is_indivisible?: BoolNullableFilter | boolean | null
    is_chu?: BoolNullableFilter | boolean | null
    is_demo?: BoolNullableFilter | boolean | null
    is_patient_full?: BoolNullableFilter | boolean | null
    is_patient_simplified?: BoolNullableFilter | boolean | null
    pack_pict?: StringNullableFilter | string | null
    is_validated?: BoolNullableFilter | boolean | null
  }

  export type nutdataUpsertWithWhereUniqueWithoutSourceInput = {
    where: nutdataWhereUniqueInput
    update: XOR<nutdataUpdateWithoutSourceInput, nutdataUncheckedUpdateWithoutSourceInput>
    create: XOR<nutdataCreateWithoutSourceInput, nutdataUncheckedCreateWithoutSourceInput>
  }

  export type nutdataUpdateWithWhereUniqueWithoutSourceInput = {
    where: nutdataWhereUniqueInput
    data: XOR<nutdataUpdateWithoutSourceInput, nutdataUncheckedUpdateWithoutSourceInput>
  }

  export type nutdataUpdateManyWithWhereWithoutSourceInput = {
    where: nutdataScalarWhereInput
    data: XOR<nutdataUpdateManyMutationInput, nutdataUncheckedUpdateManyWithoutNutdataInput>
  }

  export type qcu_questionCreateWithoutImagesInput = {
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionUncheckedCreateWithoutImagesInput = {
    id?: number
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemUncheckedCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionCreateOrConnectWithoutImagesInput = {
    where: qcu_questionWhereUniqueInput
    create: XOR<qcu_questionCreateWithoutImagesInput, qcu_questionUncheckedCreateWithoutImagesInput>
  }

  export type qcu_questionUpsertWithoutImagesInput = {
    update: XOR<qcu_questionUpdateWithoutImagesInput, qcu_questionUncheckedUpdateWithoutImagesInput>
    create: XOR<qcu_questionCreateWithoutImagesInput, qcu_questionUncheckedCreateWithoutImagesInput>
  }

  export type qcu_questionUpdateWithoutImagesInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_questionUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_itemCreateWithoutQuestionInput = {
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
  }

  export type qcu_itemUncheckedCreateWithoutQuestionInput = {
    id?: number
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
  }

  export type qcu_itemCreateOrConnectWithoutQuestionInput = {
    where: qcu_itemWhereUniqueInput
    create: XOR<qcu_itemCreateWithoutQuestionInput, qcu_itemUncheckedCreateWithoutQuestionInput>
  }

  export type qcu_itemCreateManyQuestionInputEnvelope = {
    data: Enumerable<qcu_itemCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type qcu_imageCreateWithoutQuestionInput = {
    created_at?: Date | string | null
    pict: string
  }

  export type qcu_imageUncheckedCreateWithoutQuestionInput = {
    id?: number
    created_at?: Date | string | null
    pict: string
  }

  export type qcu_imageCreateOrConnectWithoutQuestionInput = {
    where: qcu_imageWhereUniqueInput
    create: XOR<qcu_imageCreateWithoutQuestionInput, qcu_imageUncheckedCreateWithoutQuestionInput>
  }

  export type qcu_imageCreateManyQuestionInputEnvelope = {
    data: Enumerable<qcu_imageCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type user_qcuanswerCreateWithoutQuestionInput = {
    timestamp?: Date | string | null
    success: boolean
    user: userCreateNestedOneWithoutUser_qcuanswersInput
  }

  export type user_qcuanswerUncheckedCreateWithoutQuestionInput = {
    id?: number
    timestamp?: Date | string | null
    user_id: number
    success: boolean
  }

  export type user_qcuanswerCreateOrConnectWithoutQuestionInput = {
    where: user_qcuanswerWhereUniqueInput
    create: XOR<user_qcuanswerCreateWithoutQuestionInput, user_qcuanswerUncheckedCreateWithoutQuestionInput>
  }

  export type user_qcuanswerCreateManyQuestionInputEnvelope = {
    data: Enumerable<user_qcuanswerCreateManyQuestionInput>
    skipDuplicates?: boolean
  }

  export type qcu_itemUpsertWithWhereUniqueWithoutQuestionInput = {
    where: qcu_itemWhereUniqueInput
    update: XOR<qcu_itemUpdateWithoutQuestionInput, qcu_itemUncheckedUpdateWithoutQuestionInput>
    create: XOR<qcu_itemCreateWithoutQuestionInput, qcu_itemUncheckedCreateWithoutQuestionInput>
  }

  export type qcu_itemUpdateWithWhereUniqueWithoutQuestionInput = {
    where: qcu_itemWhereUniqueInput
    data: XOR<qcu_itemUpdateWithoutQuestionInput, qcu_itemUncheckedUpdateWithoutQuestionInput>
  }

  export type qcu_itemUpdateManyWithWhereWithoutQuestionInput = {
    where: qcu_itemScalarWhereInput
    data: XOR<qcu_itemUpdateManyMutationInput, qcu_itemUncheckedUpdateManyWithoutItemsInput>
  }

  export type qcu_itemScalarWhereInput = {
    AND?: Enumerable<qcu_itemScalarWhereInput>
    OR?: Enumerable<qcu_itemScalarWhereInput>
    NOT?: Enumerable<qcu_itemScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    proposition?: StringFilter | string
    pict?: StringFilter | string
    answer?: StringFilter | string
    success?: BoolFilter | boolean
    question_id?: IntFilter | number
  }

  export type qcu_imageUpsertWithWhereUniqueWithoutQuestionInput = {
    where: qcu_imageWhereUniqueInput
    update: XOR<qcu_imageUpdateWithoutQuestionInput, qcu_imageUncheckedUpdateWithoutQuestionInput>
    create: XOR<qcu_imageCreateWithoutQuestionInput, qcu_imageUncheckedCreateWithoutQuestionInput>
  }

  export type qcu_imageUpdateWithWhereUniqueWithoutQuestionInput = {
    where: qcu_imageWhereUniqueInput
    data: XOR<qcu_imageUpdateWithoutQuestionInput, qcu_imageUncheckedUpdateWithoutQuestionInput>
  }

  export type qcu_imageUpdateManyWithWhereWithoutQuestionInput = {
    where: qcu_imageScalarWhereInput
    data: XOR<qcu_imageUpdateManyMutationInput, qcu_imageUncheckedUpdateManyWithoutImagesInput>
  }

  export type qcu_imageScalarWhereInput = {
    AND?: Enumerable<qcu_imageScalarWhereInput>
    OR?: Enumerable<qcu_imageScalarWhereInput>
    NOT?: Enumerable<qcu_imageScalarWhereInput>
    id?: IntFilter | number
    created_at?: DateTimeNullableFilter | Date | string | null
    pict?: StringFilter | string
    question_id?: IntFilter | number
  }

  export type user_qcuanswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: user_qcuanswerWhereUniqueInput
    update: XOR<user_qcuanswerUpdateWithoutQuestionInput, user_qcuanswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<user_qcuanswerCreateWithoutQuestionInput, user_qcuanswerUncheckedCreateWithoutQuestionInput>
  }

  export type user_qcuanswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: user_qcuanswerWhereUniqueInput
    data: XOR<user_qcuanswerUpdateWithoutQuestionInput, user_qcuanswerUncheckedUpdateWithoutQuestionInput>
  }

  export type user_qcuanswerUpdateManyWithWhereWithoutQuestionInput = {
    where: user_qcuanswerScalarWhereInput
    data: XOR<user_qcuanswerUpdateManyMutationInput, user_qcuanswerUncheckedUpdateManyWithoutAnswersInput>
  }

  export type qcu_questionCreateWithoutItemsInput = {
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    images?: qcu_imageCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionUncheckedCreateWithoutItemsInput = {
    id?: number
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    images?: qcu_imageUncheckedCreateNestedManyWithoutQuestionInput
    answers?: user_qcuanswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionCreateOrConnectWithoutItemsInput = {
    where: qcu_questionWhereUniqueInput
    create: XOR<qcu_questionCreateWithoutItemsInput, qcu_questionUncheckedCreateWithoutItemsInput>
  }

  export type qcu_questionUpsertWithoutItemsInput = {
    update: XOR<qcu_questionUpdateWithoutItemsInput, qcu_questionUncheckedUpdateWithoutItemsInput>
    create: XOR<qcu_questionCreateWithoutItemsInput, qcu_questionUncheckedCreateWithoutItemsInput>
  }

  export type qcu_questionUpdateWithoutItemsInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    images?: qcu_imageUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_questionUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    images?: qcu_imageUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: user_qcuanswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type userCreateWithoutUser_qcuanswersInput = {
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionCreateNestedManyWithoutUserInput
    favorites?: favoriteCreateNestedManyWithoutUserInput
    fractionings?: fractioningCreateNestedManyWithoutUserInput
    meals?: mealCreateNestedManyWithoutUsersInput
    messages_from?: messageCreateNestedManyWithoutFromInput
    messages_to?: messageCreateNestedManyWithoutToInput
    patients?: patient_caregiverCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerCreateNestedManyWithoutUserInput
    user_goals?: user_goalCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementCreateNestedManyWithoutUserInput
    user_withings?: user_withingsCreateNestedManyWithoutUserInput
    user_patients?: user_patientCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUser_qcuanswersInput = {
    id?: number
    created_at?: Date | string | null
    sub?: string | null
    password?: string | null
    type: UserType
    birthdate?: Date | string | null
    title?: string | null
    email?: string | null
    phone?: string | null
    firstname?: string | null
    lastname?: string | null
    alias?: string | null
    notes?: string | null
    avatarUrl?: string | null
    install_token?: string | null
    subscription?: string | null
    gender?: number | null
    height_cm?: number | null
    weight?: Decimal | DecimalJsLike | number | string | null
    actsport?: number | null
    actprof?: number | null
    diabetes_type?: number | null
    hypertriglyceridemia?: boolean | null
    hypercholesterolemia?: boolean | null
    salt_diet?: number | null
    energy_goal?: number | null
    user_actions?: user_actionUncheckedCreateNestedManyWithoutUserInput
    favorites?: favoriteUncheckedCreateNestedManyWithoutUserInput
    fractionings?: fractioningUncheckedCreateNestedManyWithoutUserInput
    meals?: mealUncheckedCreateNestedManyWithoutUsersInput
    messages_from?: messageUncheckedCreateNestedManyWithoutFromInput
    messages_to?: messageUncheckedCreateNestedManyWithoutToInput
    patients?: patient_caregiverUncheckedCreateNestedManyWithoutPatientInput
    caregivers?: patient_caregiverUncheckedCreateNestedManyWithoutCaregiverInput
    user_centers?: user_centerUncheckedCreateNestedManyWithoutUserInput
    user_goals?: user_goalUncheckedCreateNestedManyWithoutUserInput
    user_measurements?: user_measurementUncheckedCreateNestedManyWithoutUserInput
    user_withings?: user_withingsUncheckedCreateNestedManyWithoutUserInput
    user_patients?: user_patientUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUser_qcuanswersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_qcuanswersInput, userUncheckedCreateWithoutUser_qcuanswersInput>
  }

  export type qcu_questionCreateWithoutAnswersInput = {
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemCreateNestedManyWithoutQuestionInput
    images?: qcu_imageCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionUncheckedCreateWithoutAnswersInput = {
    id?: number
    created_at?: Date | string | null
    note: string
    type: string
    level: string
    question: string
    diabete: string
    sssel: string
    chol: string
    trigly: string
    items?: qcu_itemUncheckedCreateNestedManyWithoutQuestionInput
    images?: qcu_imageUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type qcu_questionCreateOrConnectWithoutAnswersInput = {
    where: qcu_questionWhereUniqueInput
    create: XOR<qcu_questionCreateWithoutAnswersInput, qcu_questionUncheckedCreateWithoutAnswersInput>
  }

  export type userUpsertWithoutUser_qcuanswersInput = {
    update: XOR<userUpdateWithoutUser_qcuanswersInput, userUncheckedUpdateWithoutUser_qcuanswersInput>
    create: XOR<userCreateWithoutUser_qcuanswersInput, userUncheckedCreateWithoutUser_qcuanswersInput>
  }

  export type userUpdateWithoutUser_qcuanswersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUpdateManyWithoutUserNestedInput
    favorites?: favoriteUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUpdateManyWithoutUserNestedInput
    meals?: mealUpdateManyWithoutUsersNestedInput
    messages_from?: messageUpdateManyWithoutFromNestedInput
    messages_to?: messageUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUser_qcuanswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sub?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: NullableStringFieldUpdateOperationsInput | string | null
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    install_token?: NullableStringFieldUpdateOperationsInput | string | null
    subscription?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableIntFieldUpdateOperationsInput | number | null
    height_cm?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actsport?: NullableIntFieldUpdateOperationsInput | number | null
    actprof?: NullableIntFieldUpdateOperationsInput | number | null
    diabetes_type?: NullableIntFieldUpdateOperationsInput | number | null
    hypertriglyceridemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hypercholesterolemia?: NullableBoolFieldUpdateOperationsInput | boolean | null
    salt_diet?: NullableIntFieldUpdateOperationsInput | number | null
    energy_goal?: NullableIntFieldUpdateOperationsInput | number | null
    user_actions?: user_actionUncheckedUpdateManyWithoutUserNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutUserNestedInput
    fractionings?: fractioningUncheckedUpdateManyWithoutUserNestedInput
    meals?: mealUncheckedUpdateManyWithoutUsersNestedInput
    messages_from?: messageUncheckedUpdateManyWithoutFromNestedInput
    messages_to?: messageUncheckedUpdateManyWithoutToNestedInput
    patients?: patient_caregiverUncheckedUpdateManyWithoutPatientNestedInput
    caregivers?: patient_caregiverUncheckedUpdateManyWithoutCaregiverNestedInput
    user_centers?: user_centerUncheckedUpdateManyWithoutUserNestedInput
    user_goals?: user_goalUncheckedUpdateManyWithoutUserNestedInput
    user_measurements?: user_measurementUncheckedUpdateManyWithoutUserNestedInput
    user_withings?: user_withingsUncheckedUpdateManyWithoutUserNestedInput
    user_patients?: user_patientUncheckedUpdateManyWithoutUserNestedInput
  }

  export type qcu_questionUpsertWithoutAnswersInput = {
    update: XOR<qcu_questionUpdateWithoutAnswersInput, qcu_questionUncheckedUpdateWithoutAnswersInput>
    create: XOR<qcu_questionCreateWithoutAnswersInput, qcu_questionUncheckedCreateWithoutAnswersInput>
  }

  export type qcu_questionUpdateWithoutAnswersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUpdateManyWithoutQuestionNestedInput
    images?: qcu_imageUpdateManyWithoutQuestionNestedInput
  }

  export type qcu_questionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    diabete?: StringFieldUpdateOperationsInput | string
    sssel?: StringFieldUpdateOperationsInput | string
    chol?: StringFieldUpdateOperationsInput | string
    trigly?: StringFieldUpdateOperationsInput | string
    items?: qcu_itemUncheckedUpdateManyWithoutQuestionNestedInput
    images?: qcu_imageUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type user_actionCreateManySessionInput = {
    id?: number
    time: Date | string
    user_id: number
    action: string
  }

  export type user_actionUpdateWithoutSessionInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutUser_actionsNestedInput
  }

  export type user_actionUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
  }

  export type user_actionUncheckedUpdateManyWithoutUser_actionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
  }

  export type user_centerCreateManyCenterInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    role: CenterRole
  }

  export type user_centerUpdateWithoutCenterInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
    user?: userUpdateOneRequiredWithoutUser_centersNestedInput
  }

  export type user_centerUncheckedUpdateWithoutCenterInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_centerUncheckedUpdateManyWithoutUser_centersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_actionCreateManyUserInput = {
    id?: number
    session_id: number
    time: Date | string
    action: string
  }

  export type favoriteCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type fractioningCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    date?: string | null
    meal_types?: string | null
  }

  export type mealCreateManyUsersInput = {
    id?: number
    created_at?: Date | string | null
    date?: string | null
    mealtype?: string | null
    really_eaten?: boolean | null
  }

  export type messageCreateManyFromInput = {
    id?: number
    created_at?: Date | string | null
    to_id: number
    read_on?: Date | string | null
    content: string
  }

  export type messageCreateManyToInput = {
    id?: number
    created_at?: Date | string | null
    from_id: number
    read_on?: Date | string | null
    content: string
  }

  export type patient_caregiverCreateManyPatientInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    caregiver_id: number
    role: PatientCaregiverType
  }

  export type patient_caregiverCreateManyCaregiverInput = {
    id?: number
    created_at?: Date | string | null
    confirmed?: boolean
    patient_id: number
    role: PatientCaregiverType
  }

  export type user_centerCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    center_id: number
    role: CenterRole
  }

  export type user_goalCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    date: Date | string
    type: GoalType
    value: string
  }

  export type user_measurementCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    date: Date | string
    type: MeasurementType
    value?: Decimal | DecimalJsLike | number | string | null
  }

  export type user_withingsCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    withings_userid: string
    access_token: string
    refresh_token: string
  }

  export type user_patientCreateManyUserInput = {
    id?: number
    created_at?: Date | string | null
    protocol_code?: string | null
    protocol_inclusion_date?: string | null
  }

  export type user_qcuanswerCreateManyUserInput = {
    id?: number
    timestamp?: Date | string | null
    qcuquestion_id: number
    success: boolean
  }

  export type user_actionUpdateWithoutUserInput = {
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
    session?: sessionUpdateOneRequiredWithoutUser_actionsNestedInput
  }

  export type user_actionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_id?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    action?: StringFieldUpdateOperationsInput | string
  }

  export type favoriteUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutFavoritesNestedInput
    foodPortion?: food_portionUpdateOneWithoutFavoritesNestedInput
  }

  export type favoriteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUncheckedUpdateManyWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type fractioningUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fractioningUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fractioningUncheckedUpdateManyWithoutFractioningsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    meal_types?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mealUpdateWithoutUsersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meal_elements?: meal_elementUpdateManyWithoutMealNestedInput
  }

  export type mealUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
    meal_elements?: meal_elementUncheckedUpdateManyWithoutMealNestedInput
  }

  export type mealUncheckedUpdateManyWithoutMealsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    really_eaten?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type messageUpdateWithoutFromInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    to?: userUpdateOneRequiredWithoutMessages_toNestedInput
  }

  export type messageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyWithoutMessages_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    to_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type messageUpdateWithoutToInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
    from?: userUpdateOneRequiredWithoutMessages_fromNestedInput
  }

  export type messageUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    from_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type messageUncheckedUpdateManyWithoutMessages_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    from_id?: IntFieldUpdateOperationsInput | number
    read_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: StringFieldUpdateOperationsInput | string
  }

  export type patient_caregiverUpdateWithoutPatientInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
    caregiver?: userUpdateOneRequiredWithoutCaregiversNestedInput
  }

  export type patient_caregiverUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    caregiver_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type patient_caregiverUncheckedUpdateManyWithoutPatientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    caregiver_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type patient_caregiverUpdateWithoutCaregiverInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
    patient?: userUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patient_caregiverUncheckedUpdateWithoutCaregiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    patient_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type patient_caregiverUncheckedUpdateManyWithoutCaregiversInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmed?: BoolFieldUpdateOperationsInput | boolean
    patient_id?: IntFieldUpdateOperationsInput | number
    role?: EnumPatientCaregiverTypeFieldUpdateOperationsInput | PatientCaregiverType
  }

  export type user_centerUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
    center?: centerUpdateOneRequiredWithoutUser_centersNestedInput
  }

  export type user_centerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    center_id?: IntFieldUpdateOperationsInput | number
    role?: EnumCenterRoleFieldUpdateOperationsInput | CenterRole
  }

  export type user_goalUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_goalUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_goalUncheckedUpdateManyWithoutUser_goalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumGoalTypeFieldUpdateOperationsInput | GoalType
    value?: StringFieldUpdateOperationsInput | string
  }

  export type user_measurementUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_measurementUncheckedUpdateManyWithoutUser_measurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumMeasurementTypeFieldUpdateOperationsInput | MeasurementType
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type user_withingsUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_withingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_withingsUncheckedUpdateManyWithoutUser_withingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    withings_userid?: StringFieldUpdateOperationsInput | string
    access_token?: StringFieldUpdateOperationsInput | string
    refresh_token?: StringFieldUpdateOperationsInput | string
  }

  export type user_patientUpdateWithoutUserInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_patientUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_patientUncheckedUpdateManyWithoutUser_patientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    protocol_code?: NullableStringFieldUpdateOperationsInput | string | null
    protocol_inclusion_date?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_qcuanswerUpdateWithoutUserInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    question?: qcu_questionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type user_qcuanswerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcuquestion_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_qcuanswerUncheckedUpdateManyWithoutUser_qcuanswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qcuquestion_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type meal_elementCreateManyMealInput = {
    id?: number
    created_at?: Date | string | null
    food_id?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUpdateWithoutMealInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutMealElementsNestedInput
    foodPortion?: food_portionUpdateOneWithoutMealElementsNestedInput
  }

  export type meal_elementUncheckedUpdateWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUncheckedUpdateManyWithoutMeal_elementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type food_categoryCreateManyCategoriyInput = {
    id?: number
    created_at?: Date | string | null
    food_id: number
  }

  export type food_categoryUpdateWithoutCategoriyInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food?: foodUpdateOneRequiredWithoutFood_categoriesNestedInput
  }

  export type food_categoryUncheckedUpdateWithoutCategoriyInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: IntFieldUpdateOperationsInput | number
  }

  export type food_categoryUncheckedUpdateManyWithoutFood_categoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    food_id?: IntFieldUpdateOperationsInput | number
  }

  export type meal_elementCreateManyFoodPortionInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    food_id?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateManyFoodPortionInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    food_id?: number | null
    weight?: string | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUpdateWithoutFoodPortionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutMealElementsNestedInput
    meal?: mealUpdateOneRequiredWithoutMeal_elementsNestedInput
  }

  export type meal_elementUncheckedUpdateWithoutFoodPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meal_id?: IntFieldUpdateOperationsInput | number
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type meal_elementUncheckedUpdateManyWithoutMealElementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meal_id?: IntFieldUpdateOperationsInput | number
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUpdateWithoutFoodPortionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    food?: foodUpdateOneWithoutFavoritesNestedInput
    user?: userUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type favoriteUncheckedUpdateWithoutFoodPortionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    food_id?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type food_categoryCreateManyFoodInput = {
    id?: number
    created_at?: Date | string | null
    category_id: number
  }

  export type food_portionCreateManyFoodInput = {
    id?: number
    created_at?: Date | string | null
    qty: string
    shrt_desc: string
    long_desc?: string | null
    note?: string | null
    pict?: string | null
  }

  export type nutdataCreateManyFoodInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    nutr_no: string
    source_id: number
  }

  export type meal_elementCreateManyFoodInput = {
    id?: number
    created_at?: Date | string | null
    meal_id: number
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteCreateManyFoodInput = {
    id?: number
    created_at?: Date | string | null
    user_id: number
    mealtype?: string | null
    count?: number | null
    weight?: string | null
    portion_id?: number | null
    portion_cnt?: Decimal | DecimalJsLike | number | string | null
  }

  export type food_categoryUpdateWithoutFoodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoriy?: categoryUpdateOneRequiredWithoutFood_categoriesNestedInput
  }

  export type food_categoryUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category_id?: IntFieldUpdateOperationsInput | number
  }

  export type food_portionUpdateWithoutFoodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    mealElements?: meal_elementUpdateManyWithoutFoodPortionNestedInput
    favorites?: favoriteUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodPortionNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodPortionNestedInput
  }

  export type food_portionUncheckedUpdateManyWithoutFood_portionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qty?: StringFieldUpdateOperationsInput | string
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nutdataUpdateWithoutFoodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nutrient?: nutrientUpdateOneRequiredWithoutNutdataNestedInput
    source?: sourceUpdateOneRequiredWithoutNutdataNestedInput
  }

  export type nutdataUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nutr_no?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type nutdataUncheckedUpdateManyWithoutNutdataInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nutr_no?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type meal_elementUpdateWithoutFoodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    meal?: mealUpdateOneRequiredWithoutMeal_elementsNestedInput
    foodPortion?: food_portionUpdateOneWithoutMealElementsNestedInput
  }

  export type meal_elementUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meal_id?: IntFieldUpdateOperationsInput | number
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type favoriteUpdateWithoutFoodInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    foodPortion?: food_portionUpdateOneWithoutFavoritesNestedInput
    user?: userUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type favoriteUncheckedUpdateWithoutFoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    mealtype?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    portion_id?: NullableIntFieldUpdateOperationsInput | number | null
    portion_cnt?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type nutdataCreateManyNutrientInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    source_id: number
  }

  export type nutdataUpdateWithoutNutrientInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutNutdataNestedInput
    source?: sourceUpdateOneRequiredWithoutNutdataNestedInput
  }

  export type nutdataUncheckedUpdateWithoutNutrientInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    source_id?: IntFieldUpdateOperationsInput | number
  }

  export type foodCreateManySourceInput = {
    id?: number
    created_at?: Date | string | null
    shrt_desc: string
    long_desc?: string | null
    ciqual_name?: string | null
    ctdit_shrt_desc?: string | null
    ctdit_long_desc?: string | null
    keywords?: string | null
    ciqual_num?: string | null
    note?: string | null
    max_qty?: string | null
    pict?: string | null
    is_brand?: boolean | null
    is_raw?: boolean | null
    is_indivisible?: boolean | null
    is_chu?: boolean | null
    is_demo?: boolean | null
    is_patient_full?: boolean | null
    is_patient_simplified?: boolean | null
    pack_pict?: string | null
    is_validated?: boolean | null
  }

  export type nutdataCreateManySourceInput = {
    id?: number
    created_at?: Date | string | null
    val?: string | null
    note?: string | null
    food_id: number
    nutr_no: string
  }

  export type foodUpdateWithoutSourceInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateWithoutSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
    food_categories?: food_categoryUncheckedUpdateManyWithoutFoodNestedInput
    food_portions?: food_portionUncheckedUpdateManyWithoutFoodNestedInput
    nutdata?: nutdataUncheckedUpdateManyWithoutFoodNestedInput
    mealElements?: meal_elementUncheckedUpdateManyWithoutFoodNestedInput
    favorites?: favoriteUncheckedUpdateManyWithoutFoodNestedInput
  }

  export type foodUncheckedUpdateManyWithoutFoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shrt_desc?: StringFieldUpdateOperationsInput | string
    long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_name?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_shrt_desc?: NullableStringFieldUpdateOperationsInput | string | null
    ctdit_long_desc?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    ciqual_num?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    max_qty?: NullableStringFieldUpdateOperationsInput | string | null
    pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_brand?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_raw?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_indivisible?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_chu?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_full?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_patient_simplified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pack_pict?: NullableStringFieldUpdateOperationsInput | string | null
    is_validated?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type nutdataUpdateWithoutSourceInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food?: foodUpdateOneRequiredWithoutNutdataNestedInput
    nutrient?: nutrientUpdateOneRequiredWithoutNutdataNestedInput
  }

  export type nutdataUncheckedUpdateWithoutSourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    val?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    food_id?: IntFieldUpdateOperationsInput | number
    nutr_no?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_itemCreateManyQuestionInput = {
    id?: number
    created_at?: Date | string | null
    proposition: string
    pict: string
    answer: string
    success: boolean
  }

  export type qcu_imageCreateManyQuestionInput = {
    id?: number
    created_at?: Date | string | null
    pict: string
  }

  export type user_qcuanswerCreateManyQuestionInput = {
    id?: number
    timestamp?: Date | string | null
    user_id: number
    success: boolean
  }

  export type qcu_itemUpdateWithoutQuestionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qcu_itemUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qcu_itemUncheckedUpdateManyWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    proposition?: StringFieldUpdateOperationsInput | string
    pict?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type qcu_imageUpdateWithoutQuestionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_imageUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
  }

  export type qcu_imageUncheckedUpdateManyWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pict?: StringFieldUpdateOperationsInput | string
  }

  export type user_qcuanswerUpdateWithoutQuestionInput = {
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutUser_qcuanswersNestedInput
  }

  export type user_qcuanswerUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_qcuanswerUncheckedUpdateManyWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}